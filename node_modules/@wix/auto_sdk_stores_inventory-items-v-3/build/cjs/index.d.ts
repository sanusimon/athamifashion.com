import { HttpClient, NonNullablePaths, EventDefinition, MaybeContext, BuildRESTFunction, BuildEventDefinition } from '@wix/sdk-types';
import { I as InventoryItem, C as CreateInventoryItemApplicationErrors, a as CreateInventoryItemValidationErrors, B as BulkCreateInventoryItemsOptions, b as BulkCreateInventoryItemsResponse, c as BulkCreateInventoryItemsApplicationErrors, d as BulkCreateInventoryItemsValidationErrors, U as UpdateInventoryItem, e as UpdateInventoryItemOptions, f as UpdateInventoryItemApplicationErrors, M as MaskedInventoryItem, g as BulkUpdateInventoryItemsOptions, h as BulkUpdateInventoryItemsResponse, i as BulkUpdateInventoryItemsApplicationErrors, j as BulkUpdateInventoryItemsByFilterOptions, k as BulkUpdateInventoryItemsByFilterResponse, l as BulkUpdateInventoryItemsByFilterApplicationErrors, m as BulkDeleteInventoryItemsResponse, n as InventoryItemSearch, S as SearchInventoryItemsResponse, D as DecrementDataById, o as BulkDecrementInventoryItemsOptions, p as BulkDecrementInventoryItemsResponse, q as BulkDecrementInventoryItemsApplicationErrors, r as IncrementDataById, s as BulkIncrementInventoryItemsOptions, t as BulkIncrementInventoryItemsResponse, u as BulkIncrementInventoryItemsApplicationErrors, v as DecrementDataByVariantAndLocation, w as BulkDecrementInventoryItemsByVariantAndLocationOptions, x as BulkDecrementInventoryItemsByVariantAndLocationResponse, y as BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors, z as IncrementDataByVariantAndLocation, A as BulkIncrementInventoryItemsByVariantAndLocationOptions, E as BulkIncrementInventoryItemsByVariantAndLocationResponse, F as BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors, G as InventoryItemCreatedEnvelope, H as InventoryItemDeletedEnvelope, J as InventoryItemStockStatusUpdatedEnvelope, K as InventoryItemUpdatedEnvelope, L as InventoryItemUpdatedWithReasonEnvelope, N as InventoryItemsQueryBuilder, O as InventoryItemQuery, P as typedQueryInventoryItems } from './stores-catalog-v3-inventory-item-inventory-items-v-3.universal-B3z4CepI.js';
export { bz as ActionEvent, bE as AdjustInventoryAction, bF as AdjustInventoryActionActionOneOf, aL as Aggregation, a$ as AggregationData, aM as AggregationKindOneOf, bi as AggregationResults, bj as AggregationResultsResultOneOf, b6 as AggregationResultsScalarResult, a1 as AggregationType, b$ as AggregationTypeWithLiterals, a9 as App, ak as ApplicationError, Q as AvailabilityStatus, bQ as AvailabilityStatusWithLiterals, bK as BaseEventMetadata, al as BulkActionMetadata, ah as BulkCreateInventoryItemsRequest, br as BulkDecrementInventoryItemsByVariantAndLocationRequest, bp as BulkDecrementInventoryItemsRequest, ax as BulkDeleteInventoryItemsRequest, bs as BulkIncrementInventoryItemsByVariantAndLocationRequest, bq as BulkIncrementInventoryItemsRequest, ae as BulkInventoryItemAction, ay as BulkInventoryItemResult, c1 as BulkSetOrAdjustInventoryItemsByFilterApplicationErrors, bP as BulkSetOrAdjustInventoryItemsByFilterOptions, bD as BulkSetOrAdjustInventoryItemsByFilterRequest, bG as BulkSetOrAdjustInventoryItemsByFilterResponse, at as BulkUpdateInventoryItemsByFilterRequest, as as BulkUpdateInventoryItemsRequest, aH as CommonCursors, c2 as CommonQueryWithEntityContext, c3 as CommonSearchWithEntityContext, af as CreateInventoryItemRequest, ag as CreateInventoryItemResponse, aE as CursorPaging, aZ as CursorPagingMetadata, aJ as CursorSearch, aK as CursorSearchPagingMethodOneOf, a_ as Cursors, ad as CustomTag, aT as DateHistogramAggregation, be as DateHistogramResult, bg as DateHistogramResults, av as DeleteInventoryItemRequest, aw as DeleteInventoryItemResponse, bt as DomainEvent, bu as DomainEventBodyOneOf, bA as Empty, bv as EntityCreatedEvent, by as EntityDeletedEvent, bx as EntityUpdatedEvent, bL as EventMetadata, R as EventType, bR as EventTypeWithLiterals, a6 as ExtendedFields, ac as File, am as GetInventoryItemRequest, an as GetInventoryItemResponse, aX as GroupByAggregation, aY as GroupByAggregationKindOneOf, bf as GroupByValueResults, bI as IdentificationData, bJ as IdentificationDataIdOneOf, aO as IncludeMissingValuesOptions, a0 as Interval, b_ as IntervalWithLiterals, a7 as InvalidateCache, a8 as InvalidateCacheGetByOneOf, bN as InventoryItemQuerySpec, bO as InventoryItemSearchSpec, aq as InventoryItemStockStatusUpdatedEvent, a3 as InventoryItemTrackingMethodOneOf, ar as InventoryItemUpdatedWithReason, bM as InventoryItemsQueryResult, aj as ItemMetadata, bH as MessageEnvelope, Z as MissingValues, bX as MissingValuesWithLiterals, V as Mode, bT as ModeWithLiterals, aW as NestedAggregation, aU as NestedAggregationItem, aV as NestedAggregationItemKindOneOf, b2 as NestedAggregationResults, b3 as NestedAggregationResultsResultOneOf, $ as NestedAggregationType, bZ as NestedAggregationTypeWithLiterals, bb as NestedResultValue, bc as NestedResultValueResultOneOf, bh as NestedResults, b7 as NestedValueAggregationResult, bl as OffsetSearch, bm as OffsetSearchPagingMethodOneOf, aa as Page, aD as Paging, bo as PagingMetadata, aG as PlatformPagingMetadataV2, a4 as PreorderInfo, a5 as Product, az as QueryInventoryItemsRequest, aF as QueryInventoryItemsResponse, aA as QueryV2, aB as QueryV2PagingMethodOneOf, aR as RangeAggregation, b1 as RangeAggregationResult, aN as RangeBucket, b9 as RangeResult, b5 as RangeResults, T as ReasonType, bS as ReasonTypeWithLiterals, bB as RecloneSiteRequest, bC as RecloneSiteResponse, bw as RestoreInfo, bd as Results, aS as ScalarAggregation, ba as ScalarResult, _ as ScalarType, bY as ScalarTypeWithLiterals, au as SearchDetails, aI as SearchInventoryItemsRequest, bk as SearchInventoryItemsWithOffsetRequest, bn as SearchInventoryItemsWithOffsetResponse, Y as SortDirection, bW as SortDirectionWithLiterals, W as SortOrder, bU as SortOrderWithLiterals, X as SortType, bV as SortTypeWithLiterals, aC as Sorting, ab as URI, ao as UpdateInventoryItemRequest, ap as UpdateInventoryItemResponse, ai as V3BulkInventoryItemResult, aP as ValueAggregation, aQ as ValueAggregationOptionsOneOf, b0 as ValueAggregationResult, b8 as ValueResult, b4 as ValueResults, a2 as WebhookIdentityType, c0 as WebhookIdentityTypeWithLiterals } from './stores-catalog-v3-inventory-item-inventory-items-v-3.universal-B3z4CepI.js';

declare function createInventoryItem$1(httpClient: HttpClient): CreateInventoryItemSignature;
interface CreateInventoryItemSignature {
    /**
     * Creates an inventory item.
     * The combination of `variantId` and `locationId` is unique.
     * @param - Inventory item to create.
     * @returns Created inventory item.
     */
    (inventoryItem: NonNullablePaths<InventoryItem, `productId` | `variantId`, 2>): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3> & {
        __applicationErrorsType?: CreateInventoryItemApplicationErrors;
        __validationErrorsType?: CreateInventoryItemValidationErrors;
    }>;
}
declare function bulkCreateInventoryItems$1(httpClient: HttpClient): BulkCreateInventoryItemsSignature;
interface BulkCreateInventoryItemsSignature {
    /**
     * Creates multiple inventory items.
     * @param - Inventory items to create.
     */
    (inventoryItems: NonNullablePaths<InventoryItem, `productId` | `variantId`, 2>[], options?: BulkCreateInventoryItemsOptions): Promise<NonNullablePaths<BulkCreateInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkCreateInventoryItemsApplicationErrors;
        __validationErrorsType?: BulkCreateInventoryItemsValidationErrors;
    }>;
}
declare function getInventoryItem$1(httpClient: HttpClient): GetInventoryItemSignature;
interface GetInventoryItemSignature {
    /**
     * Retrieves an inventory item.
     * @param - Inventory item ID.
     * @returns Inventory item.
     */
    (inventoryItemId: string): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3>>;
}
declare function updateInventoryItem$1(httpClient: HttpClient): UpdateInventoryItemSignature;
interface UpdateInventoryItemSignature {
    /**
     * Updates an inventory item.
     *
     *
     * Each time the inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating the inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Inventory item ID.
     * @returns Updated inventory item.
     */
    (_id: string, inventoryItem: NonNullablePaths<UpdateInventoryItem, `revision`, 2>, options?: UpdateInventoryItemOptions): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3> & {
        __applicationErrorsType?: UpdateInventoryItemApplicationErrors;
    }>;
}
declare function bulkUpdateInventoryItems$1(httpClient: HttpClient): BulkUpdateInventoryItemsSignature;
interface BulkUpdateInventoryItemsSignature {
    /**
     * Updates multiple inventory items.
     *
     * Each time an inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Inventory items to update.
     */
    (inventoryItems: NonNullablePaths<MaskedInventoryItem, `inventoryItem._id` | `inventoryItem.revision`, 3>[], options?: BulkUpdateInventoryItemsOptions): Promise<NonNullablePaths<BulkUpdateInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkUpdateInventoryItemsApplicationErrors;
    }>;
}
declare function bulkUpdateInventoryItemsByFilter$1(httpClient: HttpClient): BulkUpdateInventoryItemsByFilterSignature;
interface BulkUpdateInventoryItemsByFilterSignature {
    /**
     * Updates multiple inventory items, given the provided filter.
     *
     * Each time an inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Filter object.
     */
    (filter: Record<string, any>, options?: NonNullablePaths<BulkUpdateInventoryItemsByFilterOptions, `inventoryItem`, 2>): Promise<NonNullablePaths<BulkUpdateInventoryItemsByFilterResponse, `jobId`, 2> & {
        __applicationErrorsType?: BulkUpdateInventoryItemsByFilterApplicationErrors;
    }>;
}
declare function deleteInventoryItem$1(httpClient: HttpClient): DeleteInventoryItemSignature;
interface DeleteInventoryItemSignature {
    /**
     * Deletes an inventory item.
     * @param - Inventory item ID.
     */
    (inventoryItemId: string): Promise<void>;
}
declare function bulkDeleteInventoryItems$1(httpClient: HttpClient): BulkDeleteInventoryItemsSignature;
interface BulkDeleteInventoryItemsSignature {
    /**
     * Deletes multiple inventory items.
     * @param - IDs of inventory items to delete.
     */
    (inventoryItemIds: string[]): Promise<NonNullablePaths<BulkDeleteInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
}
declare function searchInventoryItems$1(httpClient: HttpClient): SearchInventoryItemsSignature;
interface SearchInventoryItemsSignature {
    /**
     * Retrieves a list of inventory items, given the provided filtering, sorting, and cursor paging.
     *
     *
     * Search Inventory Items runs with these defaults, which you can override:
     *
     * - `createdDate` is sorted in `DESC` order
     * - `cursorPaging.limit` is `100`
     *
     * For field support for filters and sorting,
     * see [Inventory Items: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/inventory-items-v3/supported-filters-and-sorting).
     *
     * To learn about working with _Search_ endpoints, see
     * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
     * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     * @param - Search options.
     */
    (search: InventoryItemSearch): Promise<NonNullablePaths<SearchInventoryItemsResponse, `inventoryItems` | `inventoryItems.${number}.inStock` | `inventoryItems.${number}.quantity` | `inventoryItems.${number}.variantId` | `inventoryItems.${number}.productId` | `inventoryItems.${number}.trackQuantity` | `inventoryItems.${number}.availabilityStatus` | `aggregationData.results` | `aggregationData.results.${number}.scalar.type` | `aggregationData.results.${number}.scalar.value` | `aggregationData.results.${number}.name` | `aggregationData.results.${number}.type` | `aggregationData.results.${number}.fieldPath`, 6>>;
}
declare function bulkDecrementInventoryItems$1(httpClient: HttpClient): BulkDecrementInventoryItemsSignature;
interface BulkDecrementInventoryItemsSignature {
    /**
     * Decrements quantities of multiple inventory items.
     *
     * > **Notes:**:
     * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
     * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
     * > + Pass `restrictInventory: false` to allow for negative quantities.
     * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
     * @param - Inventory item IDs and decrement data.
     */
    (decrementData: NonNullablePaths<DecrementDataById, `decrementBy` | `inventoryItemId`, 2>[], options?: BulkDecrementInventoryItemsOptions): Promise<NonNullablePaths<BulkDecrementInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkDecrementInventoryItemsApplicationErrors;
    }>;
}
declare function bulkIncrementInventoryItems$1(httpClient: HttpClient): BulkIncrementInventoryItemsSignature;
interface BulkIncrementInventoryItemsSignature {
    /**
     * Increments quantities of multiple inventory items.
     *
     * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
     * @param - Inventory item IDs and increment data.
     */
    (incrementData: NonNullablePaths<IncrementDataById, `incrementBy` | `inventoryItemId`, 2>[], options?: BulkIncrementInventoryItemsOptions): Promise<NonNullablePaths<BulkIncrementInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkIncrementInventoryItemsApplicationErrors;
    }>;
}
declare function bulkDecrementInventoryItemsByVariantAndLocation$1(httpClient: HttpClient): BulkDecrementInventoryItemsByVariantAndLocationSignature;
interface BulkDecrementInventoryItemsByVariantAndLocationSignature {
    /**
     * Decrements quantities of multiple inventory items by variant and location.
     *
     * > **Notes:**:
     * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
     * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
     * > + Pass `restrictInventory: false` to allow for negative quantities.
     * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
     * @param - Variant and location IDs, as well as decrement data.
     */
    (decrementData: NonNullablePaths<DecrementDataByVariantAndLocation, `decrementBy` | `variantId`, 2>[], options?: BulkDecrementInventoryItemsByVariantAndLocationOptions): Promise<NonNullablePaths<BulkDecrementInventoryItemsByVariantAndLocationResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors;
    }>;
}
declare function bulkIncrementInventoryItemsByVariantAndLocation$1(httpClient: HttpClient): BulkIncrementInventoryItemsByVariantAndLocationSignature;
interface BulkIncrementInventoryItemsByVariantAndLocationSignature {
    /**
     * Increments quantities of multiple inventory items by variant and location.
     *
     * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
     * @param - Variant and location IDs, as well as increment data.
     */
    (incrementData: NonNullablePaths<IncrementDataByVariantAndLocation, `incrementBy` | `variantId`, 2>[], options?: BulkIncrementInventoryItemsByVariantAndLocationOptions): Promise<NonNullablePaths<BulkIncrementInventoryItemsByVariantAndLocationResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors;
    }>;
}
declare const onInventoryItemCreated$1: EventDefinition<InventoryItemCreatedEnvelope, "wix.stores.catalog.v3.inventory_item_created">;
declare const onInventoryItemDeleted$1: EventDefinition<InventoryItemDeletedEnvelope, "wix.stores.catalog.v3.inventory_item_deleted">;
declare const onInventoryItemStockStatusUpdated$1: EventDefinition<InventoryItemStockStatusUpdatedEnvelope, "wix.stores.catalog.v3.inventory_item_stock_status_updated">;
declare const onInventoryItemUpdated$1: EventDefinition<InventoryItemUpdatedEnvelope, "wix.stores.catalog.v3.inventory_item_updated">;
declare const onInventoryItemUpdatedWithReason$1: EventDefinition<InventoryItemUpdatedWithReasonEnvelope, "wix.stores.catalog.v3.inventory_item_updated_with_reason">;

declare function customQueryInventoryItems(httpClient: HttpClient): {
    (): InventoryItemsQueryBuilder;
    (query: InventoryItemQuery): ReturnType<typeof typedQueryInventoryItems>;
};
declare const createInventoryItem: MaybeContext<BuildRESTFunction<typeof createInventoryItem$1> & typeof createInventoryItem$1>;
declare const bulkCreateInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkCreateInventoryItems$1> & typeof bulkCreateInventoryItems$1>;
declare const getInventoryItem: MaybeContext<BuildRESTFunction<typeof getInventoryItem$1> & typeof getInventoryItem$1>;
declare const updateInventoryItem: MaybeContext<BuildRESTFunction<typeof updateInventoryItem$1> & typeof updateInventoryItem$1>;
declare const bulkUpdateInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkUpdateInventoryItems$1> & typeof bulkUpdateInventoryItems$1>;
declare const bulkUpdateInventoryItemsByFilter: MaybeContext<BuildRESTFunction<typeof bulkUpdateInventoryItemsByFilter$1> & typeof bulkUpdateInventoryItemsByFilter$1>;
declare const deleteInventoryItem: MaybeContext<BuildRESTFunction<typeof deleteInventoryItem$1> & typeof deleteInventoryItem$1>;
declare const bulkDeleteInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkDeleteInventoryItems$1> & typeof bulkDeleteInventoryItems$1>;
declare const searchInventoryItems: MaybeContext<BuildRESTFunction<typeof searchInventoryItems$1> & typeof searchInventoryItems$1>;
declare const bulkDecrementInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkDecrementInventoryItems$1> & typeof bulkDecrementInventoryItems$1>;
declare const bulkIncrementInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkIncrementInventoryItems$1> & typeof bulkIncrementInventoryItems$1>;
declare const bulkDecrementInventoryItemsByVariantAndLocation: MaybeContext<BuildRESTFunction<typeof bulkDecrementInventoryItemsByVariantAndLocation$1> & typeof bulkDecrementInventoryItemsByVariantAndLocation$1>;
declare const bulkIncrementInventoryItemsByVariantAndLocation: MaybeContext<BuildRESTFunction<typeof bulkIncrementInventoryItemsByVariantAndLocation$1> & typeof bulkIncrementInventoryItemsByVariantAndLocation$1>;
declare const queryInventoryItems: MaybeContext<BuildRESTFunction<typeof customQueryInventoryItems> & typeof customQueryInventoryItems>;
/**
 * Triggered when an inventory item is created.
 */
declare const onInventoryItemCreated: BuildEventDefinition<typeof onInventoryItemCreated$1> & typeof onInventoryItemCreated$1;
/**
 * Triggered when an inventory item is deleted.
 */
declare const onInventoryItemDeleted: BuildEventDefinition<typeof onInventoryItemDeleted$1> & typeof onInventoryItemDeleted$1;
/**
 * Triggered when an inventory item's stock is updated.
 */
declare const onInventoryItemStockStatusUpdated: BuildEventDefinition<typeof onInventoryItemStockStatusUpdated$1> & typeof onInventoryItemStockStatusUpdated$1;
/**
 * Triggered when an inventory item is updated.
 */
declare const onInventoryItemUpdated: BuildEventDefinition<typeof onInventoryItemUpdated$1> & typeof onInventoryItemUpdated$1;
/**
 * Triggered when an inventory item is updated.
 */
declare const onInventoryItemUpdatedWithReason: BuildEventDefinition<typeof onInventoryItemUpdatedWithReason$1> & typeof onInventoryItemUpdatedWithReason$1;

export { BulkCreateInventoryItemsApplicationErrors, BulkCreateInventoryItemsOptions, BulkCreateInventoryItemsResponse, BulkCreateInventoryItemsValidationErrors, BulkDecrementInventoryItemsApplicationErrors, BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors, BulkDecrementInventoryItemsByVariantAndLocationOptions, BulkDecrementInventoryItemsByVariantAndLocationResponse, BulkDecrementInventoryItemsOptions, BulkDecrementInventoryItemsResponse, BulkDeleteInventoryItemsResponse, BulkIncrementInventoryItemsApplicationErrors, BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors, BulkIncrementInventoryItemsByVariantAndLocationOptions, BulkIncrementInventoryItemsByVariantAndLocationResponse, BulkIncrementInventoryItemsOptions, BulkIncrementInventoryItemsResponse, BulkUpdateInventoryItemsApplicationErrors, BulkUpdateInventoryItemsByFilterApplicationErrors, BulkUpdateInventoryItemsByFilterOptions, BulkUpdateInventoryItemsByFilterResponse, BulkUpdateInventoryItemsOptions, BulkUpdateInventoryItemsResponse, CreateInventoryItemApplicationErrors, CreateInventoryItemValidationErrors, DecrementDataById, DecrementDataByVariantAndLocation, IncrementDataById, IncrementDataByVariantAndLocation, InventoryItem, InventoryItemCreatedEnvelope, InventoryItemDeletedEnvelope, InventoryItemQuery, InventoryItemSearch, InventoryItemStockStatusUpdatedEnvelope, InventoryItemUpdatedEnvelope, InventoryItemUpdatedWithReasonEnvelope, InventoryItemsQueryBuilder, MaskedInventoryItem, SearchInventoryItemsResponse, UpdateInventoryItem, UpdateInventoryItemApplicationErrors, UpdateInventoryItemOptions, bulkCreateInventoryItems, bulkDecrementInventoryItems, bulkDecrementInventoryItemsByVariantAndLocation, bulkDeleteInventoryItems, bulkIncrementInventoryItems, bulkIncrementInventoryItemsByVariantAndLocation, bulkUpdateInventoryItems, bulkUpdateInventoryItemsByFilter, createInventoryItem, deleteInventoryItem, getInventoryItem, onInventoryItemCreated, onInventoryItemDeleted, onInventoryItemStockStatusUpdated, onInventoryItemUpdated, onInventoryItemUpdatedWithReason, queryInventoryItems, searchInventoryItems, updateInventoryItem };
