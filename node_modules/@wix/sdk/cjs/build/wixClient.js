"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.X_WIX_CONSISTENT_HEADER = void 0;
exports.createClient = createClient;
const sdk_context_1 = require("@wix/sdk-context");
const sdk_types_1 = require("@wix/sdk-types");
const ambassador_modules_js_1 = require("./ambassador-modules.js");
const common_js_1 = require("./common.js");
const fetch_error_js_1 = require("./fetch-error.js");
const helpers_js_1 = require("./helpers.js");
const host_modules_js_1 = require("./host-modules.js");
const rest_modules_js_1 = require("./rest-modules.js");
const event_handlers_modules_js_1 = require("./event-handlers-modules.js");
const service_plugin_modules_js_1 = require("./service-plugin-modules.js");
const context_1 = require("@wix/sdk-runtime/context");
exports.X_WIX_CONSISTENT_HEADER = 'X-Wix-Consistent';
function createClient(config) {
    const _headers = config.headers || { Authorization: '' };
    const authStrategy = config.auth ||
        {
            getAuthHeaders: (_) => Promise.resolve({ headers: {} }),
        };
    const boundGetAuthHeaders = authStrategy.getAuthHeaders.bind(undefined, config.host);
    authStrategy.getAuthHeaders = boundGetAuthHeaders;
    const fetchWithAuth = async (urlOrRequest, requestInit) => {
        const authHeaders = await boundGetAuthHeaders();
        const headers = {
            ...(requestInit?.headers ?? {}),
            ...authHeaders.headers,
            ...config.host?.essentials?.passThroughHeaders,
            ...(_headers[exports.X_WIX_CONSISTENT_HEADER]
                ? { [exports.X_WIX_CONSISTENT_HEADER]: _headers[exports.X_WIX_CONSISTENT_HEADER] }
                : {}),
        };
        const errorHandler = config.host?.getErrorHandler?.();
        try {
            if (typeof urlOrRequest === 'string' || urlOrRequest instanceof URL) {
                const response = await fetch(urlOrRequest, {
                    ...requestInit,
                    headers,
                });
                errorHandler?.handleError(response, {
                    requestOptions: {
                        url: urlOrRequest.toString(),
                        method: requestInit?.method,
                    },
                });
                const consistentHeader = findConsistentHeader(response);
                if (consistentHeader) {
                    _headers[exports.X_WIX_CONSISTENT_HEADER] = consistentHeader;
                }
                return response;
            }
            else {
                for (const [k, v] of Object.entries(headers)) {
                    if (typeof v === 'string') {
                        urlOrRequest.headers.set(k, v);
                    }
                }
                const response = await fetch(urlOrRequest, requestInit);
                errorHandler?.handleError(response, {
                    requestOptions: {
                        url: urlOrRequest.url,
                        method: requestInit?.method,
                    },
                });
                const consistentHeader = findConsistentHeader(response);
                if (consistentHeader) {
                    _headers[exports.X_WIX_CONSISTENT_HEADER] = consistentHeader;
                }
                return response;
            }
        }
        catch (e) {
            errorHandler?.handleError(e, {
                requestOptions: {
                    url: typeof urlOrRequest === 'string' || urlOrRequest instanceof URL
                        ? urlOrRequest.toString()
                        : urlOrRequest.url,
                    method: requestInit?.method,
                },
            });
            throw e;
        }
    };
    const { client: servicePluginsClient, initModule: initServicePluginModule } = (0, service_plugin_modules_js_1.servicePluginsModules)(authStrategy);
    const { client: eventHandlersClient, initModule: initEventHandlerModule } = (0, event_handlers_modules_js_1.eventHandlersModules)(authStrategy);
    const boundFetch = async (url, options) => {
        const authHeaders = await boundGetAuthHeaders();
        const defaultContentTypeHeader = (0, helpers_js_1.getDefaultContentHeader)(options);
        const response = await fetch(url, {
            ...options,
            headers: {
                ...defaultContentTypeHeader,
                ..._headers,
                ...authHeaders?.headers,
                ...options?.headers,
                ...config.host?.essentials?.passThroughHeaders,
                // Ensure consistent header always takes precedence
                ...(_headers[exports.X_WIX_CONSISTENT_HEADER]
                    ? { [exports.X_WIX_CONSISTENT_HEADER]: _headers[exports.X_WIX_CONSISTENT_HEADER] }
                    : {}),
            },
        });
        const consistentHeader = findConsistentHeader(response);
        if (consistentHeader) {
            _headers[exports.X_WIX_CONSISTENT_HEADER] = consistentHeader;
        }
        return response;
    };
    // This is typed as `any` because when trying to properly type it as defined
    // on the WixClient, typescript starts failing with `Type instantiation is
    // excessively deep and possibly infinite.`
    const use = (modules, metadata) => {
        if ((0, event_handlers_modules_js_1.isEventHandlerModule)(modules)) {
            return initEventHandlerModule(modules);
        }
        else if ((0, service_plugin_modules_js_1.isServicePluginModule)(modules)) {
            return initServicePluginModule(modules);
        }
        else if ((0, host_modules_js_1.isHostModule)(modules) && config.host) {
            return (0, host_modules_js_1.buildHostModule)(modules, config.host);
        }
        else if (typeof modules === 'function') {
            // The generated namespaces all have the error classes on them and
            // a class is also a function, so we need to explicitly ignore these
            // error classes using a static field that exists on them.
            if ('__type' in modules && modules.__type === sdk_types_1.SERVICE_PLUGIN_ERROR_TYPE) {
                return modules;
            }
            const apiBaseUrl = config.host?.apiBaseUrl ?? common_js_1.DEFAULT_API_URL;
            const shouldUseCDN = config.useCDN === undefined ? config.auth?.shouldUseCDN : config.useCDN;
            return (0, rest_modules_js_1.buildRESTDescriptor)((0, context_1.runWithoutContext)(() => (0, ambassador_modules_js_1.isAmbassadorModule)(modules))
                ? (0, ambassador_modules_js_1.toHTTPModule)(modules)
                : modules, metadata ?? {}, boundFetch, config.host?.getErrorHandler?.(), (relativeUrl, fetchOptions) => {
                const finalUrl = new URL(relativeUrl, `https://${apiBaseUrl}`);
                finalUrl.host = apiBaseUrl;
                finalUrl.protocol = 'https';
                return boundFetch(finalUrl.toString(), fetchOptions);
            }, authStrategy.getActiveToken, { HTTPHost: apiBaseUrl }, config.host?.name, shouldUseCDN);
        }
        else if ((0, helpers_js_1.isObject)(modules)) {
            return Object.fromEntries(Object.entries(modules).map(([key, value]) => {
                return [key, use(value, modules[common_js_1.PUBLIC_METADATA_KEY])];
            }));
        }
        else {
            return modules;
        }
    };
    const setHeaders = (headers) => {
        for (const k in headers) {
            _headers[k] = headers[k];
        }
    };
    const wrappedModules = config.modules
        ? use(config.modules)
        : {};
    return {
        ...wrappedModules,
        auth: authStrategy,
        setHeaders,
        use,
        enableContext(contextType, opts = { elevated: false }) {
            if (contextType === 'global') {
                if (globalThis.__wix_context__ != null) {
                    if (opts.elevated) {
                        globalThis.__wix_context__.elevatedClient = this;
                    }
                    else {
                        globalThis.__wix_context__.client = this;
                    }
                }
                else {
                    if (opts.elevated) {
                        globalThis.__wix_context__ = { elevatedClient: this };
                    }
                    else {
                        globalThis.__wix_context__ = { client: this };
                    }
                }
            }
            else {
                if (opts.elevated) {
                    sdk_context_1.wixContext.elevatedClient = this;
                }
                else {
                    sdk_context_1.wixContext.client = this;
                }
            }
        },
        /**
         * @param relativeUrl The URL to fetch relative to the API base URL
         * @param options The fetch options
         * @returns The fetch Response object
         * @deprecated Use `fetchWithAuth` instead
         */
        fetch: (relativeUrl, options) => {
            const apiBaseUrl = config.host?.apiBaseUrl ?? common_js_1.DEFAULT_API_URL;
            const finalUrl = new URL(relativeUrl, `https://${apiBaseUrl}`);
            finalUrl.host = apiBaseUrl;
            finalUrl.protocol = 'https';
            return boundFetch(finalUrl.toString(), options);
        },
        fetchWithAuth,
        async graphql(query, variables, opts = {
            apiVersion: 'alpha',
        }) {
            const apiBaseUrl = config?.host?.apiBaseUrl ?? common_js_1.DEFAULT_API_URL;
            const res = await boundFetch(`https://${apiBaseUrl}/graphql/${opts.apiVersion}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query, variables }),
            });
            if (res.status !== 200) {
                throw new fetch_error_js_1.FetchErrorResponse(`GraphQL request failed with status ${res.status}`, res);
            }
            const { data, errors } = await res.json();
            return { data: data ?? {}, errors };
        },
        webhooks: eventHandlersClient,
        servicePlugins: servicePluginsClient,
    };
}
function findConsistentHeader(response) {
    return (response.headers?.get(exports.X_WIX_CONSISTENT_HEADER) ??
        response.headers?.get(exports.X_WIX_CONSISTENT_HEADER.toLowerCase()));
}
