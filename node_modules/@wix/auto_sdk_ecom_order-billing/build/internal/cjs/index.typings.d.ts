import { NonNullablePaths } from '@wix/sdk-types';

interface OrderBilling {
    /**
     * Entity ID.
     * @format GUID
     */
    _id?: string | null;
}
interface GetOrderRefundabilityRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
}
interface GetOrderRefundabilityResponse {
    /**
     * Payment refundability status and amounts for each payment method used in the order.
     *
     * Shows whether payments can be refunded automatically, manually, or not at all.
     * @maxSize 100
     */
    payments?: PaymentRefundability[];
    /** Aggregated summary of all payment amounts across all payment methods. */
    paymentsSummary?: PaymentsSummary;
    /**
     * Line item refundability showing available refund quantities for each product.
     * @maxSize 300
     */
    lineItems?: LineItemRefundability[];
    /**
     * Shipping refundability including original amount, previously refunded amount, and remaining refundable amount.
     *
     * Only present if the order includes shipping charges.
     */
    shipping?: ShippingRefundability;
    /**
     * List of additional fee refund amounts - both previously refunded and the amount still available for refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefundability[];
}
interface PaymentRefundability extends PaymentRefundabilityStatusOneOf {
    /**
     * Whether the payment supports automatic API-based refunds.
     * Choose automatic refunds for faster processing when possible.
     */
    refundable?: boolean;
    /**
     * Payment requires manual/external refund processing. Can be manually marked as refunded.
     * Use the provided `providerLink` to access the provider's refund interface.
     */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /**
     * Payment cannot be refunded due to business rules, provider restrictions, or payment state.
     * Check the specific reason to understand why refunding is not possible.
     */
    nonRefundable?: NonRefundablePaymentStatus;
    /** Payment details including method, amounts, and transaction information. */
    payment?: PaymentInfo;
    /**
     * URL to the payment provider's dashboard for manual refund processing.
     * Required when payment has manual refund status.
     * @format WEB_URL
     */
    providerLink?: string | null;
}
/** @oneof */
interface PaymentRefundabilityStatusOneOf {
    /**
     * Whether the payment supports automatic API-based refunds.
     * Choose automatic refunds for faster processing when possible.
     */
    refundable?: boolean;
    /**
     * Payment requires manual/external refund processing. Can be manually marked as refunded.
     * Use the provided `providerLink` to access the provider's refund interface.
     */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /**
     * Payment cannot be refunded due to business rules, provider restrictions, or payment state.
     * Check the specific reason to understand why refunding is not possible.
     */
    nonRefundable?: NonRefundablePaymentStatus;
}
interface PaymentInfo extends PaymentInfoSummaryOneOf, PaymentInfoPaymentMethodDetailsOneOf {
    /** Monetary payment details with amounts for cash-based payments. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment details for payments made using membership credits or plans. */
    membership?: MembershipPaymentSummary;
    /** Credit card information for credit card payments, including card type and last 4 digits. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Payment ID used to reference this payment in refund operations.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Payment method type used for this transaction.
     *
     * Non-exhaustive list of supported values: `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 50
     */
    paymentMethod?: string | null;
    /**
     * Whether this payment was processed offline (not through an online payment gateway).
     * Offline payments typically require manual refund processing.
     */
    offlinePayment?: boolean;
}
/** @oneof */
interface PaymentInfoSummaryOneOf {
    /** Monetary payment details with amounts for cash-based payments. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment details for payments made using membership credits or plans. */
    membership?: MembershipPaymentSummary;
}
/** @oneof */
interface PaymentInfoPaymentMethodDetailsOneOf {
    /** Credit card information for credit card payments, including card type and last 4 digits. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
interface MonetaryPaymentSummary {
    /** Amount paid. */
    paid?: Price;
    /** Total amount already refunded from this payment method. */
    refunded?: Price;
    /** Amount currently being processed for refund but not yet completed. */
    refundPending?: Price;
    /**
     * Maximum amount available for additional refunds if the payment is refundable.
     * Calculated as: `paid` - `refunded` - `refundPending`
     */
    maxRefund?: Price;
}
interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
interface MembershipPaymentSummary {
    /**
     * Line item IDs that were originally paid using membership credits or benefits.
     * @format GUID
     * @maxSize 100
     */
    paidLineItemIds?: string[];
    /**
     * Line item IDs that were previously refunded and had been paid with membership benefits.
     * These items have already been processed for membership credit restoration.
     * @format GUID
     * @maxSize 100
     */
    refundedLineItemIds?: string[];
    /**
     * Line item IDs paid with membership benefits that can still be refunded.
     * Refunding these items may restore membership credits to the customer's account.
     * @format GUID
     * @maxSize 100
     */
    refundableLineItemIds?: string[];
}
interface CreditCardPaymentMethodDetails {
    /**
     * The last 4 digits of the card number.
     * @maxLength 4
     */
    lastFourDigits?: string | null;
    /**
     * Card issuer's brand.
     * @maxLength 100
     */
    brand?: string | null;
}
interface ManuallyRefundablePaymentStatus {
    /** Specific reason why this payment requires manual refund processing. */
    reason?: ManuallyRefundableReasonWithLiterals;
}
declare enum ManuallyRefundableReason {
    /** Unknown manual refund reason. */
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /**
     * Payment authorization or refund window has expired with the payment provider.
     * Refunds must be processed manually through the provider's dashboard.
     */
    EXPIRED = "EXPIRED",
    /**
     * Payment provider does not support automatic refunds for this payment method.
     * Manual refund through provider dashboard is required.
     */
    NOT_SUPPORTED = "NOT_SUPPORTED",
    /**
     * Payment was processed offline (cash, check, or manually marked as paid).
     * Refund must be handled manually outside the payment system.
     */
    OFFLINE = "OFFLINE",
    /**
     * Payment requires a physical card reader device to process the refund.
     * Typically applies to in-person credit card transactions.
     */
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
/** @enumType */
type ManuallyRefundableReasonWithLiterals = ManuallyRefundableReason | 'UNKNOWN_REASON' | 'EXPIRED' | 'NOT_SUPPORTED' | 'OFFLINE' | 'REQUIRES_CARD_READER';
interface NonRefundablePaymentStatus {
    /** Specific reason why this payment cannot be refunded through any method. */
    reason?: NonRefundableReasonWithLiterals;
}
declare enum NonRefundableReason {
    /** Unknown non-refundable reason. */
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Payment has already been fully refunded. No additional refund amount is available. */
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    /**
     * Payment provider's system is currently unavailable for refund processing.
     * Try again later or contact the provider directly.
     */
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    /** Payment has not been successfully completed. Only paid transactions can be refunded. */
    NOT_PAID = "NOT_PAID",
    /** Payment amount is zero, so there is nothing to refund. */
    ZERO_PRICE = "ZERO_PRICE",
    /** Payment provider has disabled refunds for this payment method or account. */
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    /** A refund is already in progress for this payment. Wait for completion before initiating another refund. */
    PENDING_REFUND = "PENDING_REFUND",
    /** Refund is not allowed due to business rules, compliance restrictions, or account limitations. */
    FORBIDDEN = "FORBIDDEN",
    /** Payment transaction cannot be found in the provider's system, preventing refund processing. */
    TRANSACTION_NOT_FOUND = "TRANSACTION_NOT_FOUND",
    /** Order is still pending confirmation and has not been finalized for refund processing. */
    ORDER_IS_PENDING = "ORDER_IS_PENDING",
    /** Order was rejected or cancelled before payment completion, making refunds unnecessary. */
    ORDER_IS_REJECTED = "ORDER_IS_REJECTED",
    /** Payment amount has been offset by chargeback claims, preventing standard refund processing. */
    AMOUNT_OFFSET_BY_CHARGEBACK = "AMOUNT_OFFSET_BY_CHARGEBACK"
}
/** @enumType */
type NonRefundableReasonWithLiterals = NonRefundableReason | 'UNKNOWN_REASON' | 'ALREADY_REFUNDED' | 'PROVIDER_IS_DOWN' | 'NOT_PAID' | 'ZERO_PRICE' | 'DISABLED_BY_PROVIDER' | 'PENDING_REFUND' | 'FORBIDDEN' | 'TRANSACTION_NOT_FOUND' | 'ORDER_IS_PENDING' | 'ORDER_IS_REJECTED' | 'AMOUNT_OFFSET_BY_CHARGEBACK';
interface PaymentsSummary {
    /** Summary of cash-based payment methods (credit cards, PayPal, etc.). */
    monetary?: MonetaryPaymentSummary;
    /** Summary of membership-based payments using credits, plans, or benefits. */
    membership?: MembershipPaymentSummary;
}
interface LineItemRefundability {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /** Total quantity of this item originally ordered. */
    originalQuantity?: number;
    /** Quantity of this item previously refunded across all refund transactions. */
    refundedQuantity?: number;
    /** Maximum quantity of this item that can still be refunded. */
    availableRefundQuantity?: number;
}
interface ShippingRefundability {
    /** Original shipping fee amount. */
    amount?: Price;
    /** Previously refunded shipping fee amount. */
    refundedAmount?: Price;
    /** Shipping fee amount available for refund. */
    availableRefundAmount?: Price;
}
interface AdditionalFeeRefundability {
    /**
     * Additional fee ID.
     * @format GUID
     */
    additionalFeeId?: string;
    /** Original additional fee amount. */
    amount?: Price;
    /** Previously refunded additional fee amount. */
    refundedAmount?: Price;
    /** Additional fee amount available for refund. */
    availableRefundAmount?: Price;
}
interface CalculateRefundRequest {
    /**
     * Order ID to calculate refund for.
     * @format GUID
     */
    orderId: string;
    /**
     * Items to include in the refund calculation with their respective quantities and amounts.
     *
     * Specify which line items, shipping charges, and additional fees to refund.
     */
    refundItems?: RefundItems;
}
interface RefundItems {
    /**
     * Line items and their quantities to refund.
     * @maxSize 300
     */
    lineItems?: LineItemRefund[];
    /**
     * Additional fees and their amounts to refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefund[];
    /** Shipping amount to refund. */
    shipping?: ShippingRefund;
}
interface LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity of this product to refund.
     * Cannot exceed the available refund quantity for this line item.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface AdditionalFeeRefund {
    /**
     * Additional fee ID to refund.
     * @format GUID
     */
    additionalFeeId?: string;
    /**
     * Amount of the additional fee to refund.
     * If not specified, the full remaining refundable amount for this fee will be refunded.
     */
    amount?: Price;
}
interface ShippingRefund {
    /**
     * Amount of shipping charges to refund.
     * If not specified, the full remaining refundable shipping amount will be refunded.
     */
    amount?: Price;
}
interface CalculateRefundResponse extends CalculateRefundResponseStatusOneOf {
    /**
     * Whether the refund is available for all requested items.
     *
     * `true` indicates all items can be refunded as requested.
     */
    available?: boolean;
    /**
     * Refund unavailability details when some or all items cannot be refunded.
     *
     * Contains specific error information for each problematic item.
     */
    notAvailable?: CalculatedRefundNotAvailableStatus;
    /**
     * Aggregated summary of all items provided for refund.
     *
     * This field is not returned when refund is not available for the given list of items.
     */
    summary?: AggregatedRefundSummary;
    /** Detailed refund calculations broken down by each requested item type. */
    calculatedRefundItems?: CalculatedRefundItems;
}
/** @oneof */
interface CalculateRefundResponseStatusOneOf {
    /**
     * Whether the refund is available for all requested items.
     *
     * `true` indicates all items can be refunded as requested.
     */
    available?: boolean;
    /**
     * Refund unavailability details when some or all items cannot be refunded.
     *
     * Contains specific error information for each problematic item.
     */
    notAvailable?: CalculatedRefundNotAvailableStatus;
}
interface AggregatedRefundSummary {
    /** Total refund amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
    /** Total cost of the line items being refunded (without tax and discount). */
    lineItemsSubtotal?: Price;
    /** Total cost of the additional fees being refunded. */
    additionalFeesTotal?: Price;
}
interface CalculatedRefundItems {
    /**
     * Calculated refund details for each line item.
     * @maxSize 300
     */
    lineItems?: CalculatedLineItemRefund[];
    /**
     * Calculated refund details for each additional fee.
     * @maxSize 100
     */
    additionalFees?: CalculatedAdditionalFeeRefund[];
    /** Calculated refund details for the shipping fee. */
    shipping?: CalculatedShippingRefund;
}
interface CalculatedLineItemRefund {
    /** Line item refund details. */
    item?: LineItemRefund;
    /** Calculated refund summary for this line item. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedRefundSummary {
    /** Total refundable amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
}
interface CalculatedAdditionalFeeRefund {
    /** Additional fee refund details. */
    additionalFee?: AdditionalFeeRefund;
    /** Calculated refund summary for this additional fee. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedShippingRefund {
    /** Shipping refund details. */
    shipping?: ShippingRefund;
    /** Calculated refund summary for shipping. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedRefundNotAvailableStatus {
    /**
     * Refund calculation errors.
     * @maxSize 401
     */
    errors?: CalculationError[];
}
interface CalculationError extends CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
    /** Error details */
    error?: Details;
}
/** @oneof */
interface CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
}
interface Details extends DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
    /**
     * deprecated in API's - to enable migration from rendering arbitrary tracing to rest response
     * @deprecated
     */
    tracing?: Record<string, string>;
}
/** @oneof */
interface DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/**
 * example result:
 * {
 * "fieldViolations": [
 * {
 * "field": "fieldA",
 * "description": "invalid music note. supported notes: [do,re,mi,fa,sol,la,ti]",
 * "violatedRule": "OTHER",
 * "ruleName": "INVALID_NOTE",
 * "data": {
 * "value": "FI"
 * }
 * },
 * {
 * "field": "fieldB",
 * "description": "field value out of range. supported range: [0-20]",
 * "violatedRule": "MAX",
 * "data": {
 * "threshold": 20
 * }
 * },
 * {
 * "field": "fieldC",
 * "description": "invalid phone number. provide a valid phone number of size: [7-12], supported characters: [0-9, +, -, (, )]",
 * "violatedRule": "FORMAT",
 * "data": {
 * "type": "PHONE"
 * }
 * }
 * ]
 * }
 */
interface ValidationError {
    fieldViolations?: FieldViolation[];
}
declare enum RuleType {
    VALIDATION = "VALIDATION",
    OTHER = "OTHER",
    MAX = "MAX",
    MIN = "MIN",
    MAX_LENGTH = "MAX_LENGTH",
    MIN_LENGTH = "MIN_LENGTH",
    MAX_SIZE = "MAX_SIZE",
    MIN_SIZE = "MIN_SIZE",
    FORMAT = "FORMAT",
    DECIMAL_LTE = "DECIMAL_LTE",
    DECIMAL_GTE = "DECIMAL_GTE",
    DECIMAL_LT = "DECIMAL_LT",
    DECIMAL_GT = "DECIMAL_GT",
    DECIMAL_MAX_SCALE = "DECIMAL_MAX_SCALE",
    INVALID_ENUM_VALUE = "INVALID_ENUM_VALUE",
    REQUIRED_FIELD = "REQUIRED_FIELD",
    FIELD_NOT_ALLOWED = "FIELD_NOT_ALLOWED",
    ONE_OF_ALIGNMENT = "ONE_OF_ALIGNMENT",
    EXACT_LENGTH = "EXACT_LENGTH",
    EXACT_SIZE = "EXACT_SIZE",
    REQUIRED_ONE_OF_FIELD = "REQUIRED_ONE_OF_FIELD"
}
/** @enumType */
type RuleTypeWithLiterals = RuleType | 'VALIDATION' | 'OTHER' | 'MAX' | 'MIN' | 'MAX_LENGTH' | 'MIN_LENGTH' | 'MAX_SIZE' | 'MIN_SIZE' | 'FORMAT' | 'DECIMAL_LTE' | 'DECIMAL_GTE' | 'DECIMAL_LT' | 'DECIMAL_GT' | 'DECIMAL_MAX_SCALE' | 'INVALID_ENUM_VALUE' | 'REQUIRED_FIELD' | 'FIELD_NOT_ALLOWED' | 'ONE_OF_ALIGNMENT' | 'EXACT_LENGTH' | 'EXACT_SIZE' | 'REQUIRED_ONE_OF_FIELD';
interface FieldViolation {
    field?: string;
    description?: string;
    violatedRule?: RuleTypeWithLiterals;
    /** applicable when violated_rule=OTHER */
    ruleName?: string | null;
    data?: Record<string, any> | null;
}
interface SystemError {
    /** Error code. */
    errorCode?: string | null;
}
interface RefundPaymentsRequest {
    /**
     * Order ID to process refunds for.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment refunds specifying which payments to refund and their amounts.
     * Set `externalRefund` to `true` for manual refunds processed outside the system.
     * @minSize 1
     * @maxSize 50
     */
    paymentRefunds: PaymentRefund[];
    /** Additional actions to perform alongside the refund, such as restocking inventory or sending notifications. */
    sideEffects?: RefundSideEffects;
    /** Specific items being refunded including line items, shipping, and additional fees. */
    refundItems?: RefundItems;
    /**
     * Optional customer-provided reason for the refund for record-keeping purposes.
     * @maxLength 200
     */
    customerReason?: string | null;
}
interface PaymentRefund {
    /**
     * ID of the payment to refund from the order's payment transactions.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Amount to refund from this payment.
     * Not applicable for membership payments and gift card refunds where the full credit is refunded.
     */
    amount?: Price;
    /**
     * Whether this refund is processed externally through the payment provider's dashboard.
     *
     * + **Automatic refund** (`false`, default): Calls the payment provider's API to process the refund.
     * The system handles the refund transaction and updates the payment status automatically.
     *
     * + **External refund** (`true`): Marks the payment as refunded without calling the provider's API.
     * Use this when you've manually processed the refund and only need to update the order records.
     */
    externalRefund?: boolean;
    /**
     * If set, indicates that refund is made externally and manually (on the payment provider's side) and payment gateway will NOT be called to make an actual refund.
     * When not set (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * @internal
     */
    externalRefundInfo?: ExternalRefundInfo;
}
interface ExternalRefundInfo {
    /**
     * Status of the external refund transaction affecting how the system handles the refund.
     *
     * + **SUCCEEDED**: Refund has been completed externally. The payment is immediately marked as refunded.
     * + **PENDING**: Refund is in progress externally. The system waits for provider notification or manual status update.
     * While pending, additional refunds for this payment are blocked.
     */
    refundStatus?: ExternalRefundStatusWithLiterals;
}
declare enum ExternalRefundStatus {
    /**
     * External refund has been successfully completed by the payment provider.
     * The payment will be immediately marked as refunded in the system.
     */
    SUCCEEDED = "SUCCEEDED",
    /**
     * External refund has been initiated or is in progress at the payment provider.
     * The system will wait for confirmation before marking the payment as refunded.
     */
    PENDING = "PENDING"
}
/** @enumType */
type ExternalRefundStatusWithLiterals = ExternalRefundStatus | 'SUCCEEDED' | 'PENDING';
interface RefundSideEffects {
    /** Inventory restocking actions to perform alongside the refund. */
    restock?: RestockSideEffects;
    /** Customer notification actions for the refund. */
    notifications?: NotificationSideEffects;
}
interface RestockItem {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity to add back to inventory.
     * Cannot exceed the quantity being refunded for this line item.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface RestockSideEffects {
    /**
     * Items to add back to inventory when processing the refund.
     * Use this to automatically restock returned items.
     * @maxSize 300
     */
    lineItems?: RestockItem[];
}
interface NotificationSideEffects {
    /**
     * Whether to send a refund confirmation email to the customer.
     * The email includes refund details and any custom message provided.
     *
     * Default: `false`
     */
    sendCustomerEmail?: boolean;
    /**
     * Custom message to include in the refund confirmation email sent to the customer.
     * Use this to provide additional context about the refund, return instructions, or customer service information.
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
interface RefundPaymentsResponse {
    /** Complete refund information including refund ID, status, and amounts processed. */
    refund?: Refund;
    /** Updated order transaction history reflecting all payments and refunds after processing. */
    orderTransactions?: OrderTransactions;
}
interface Refund {
    /**
     * Refund ID.
     * @format GUID
     * @readonly
     */
    _id?: string;
    /**
     * List of transactions.
     * @maxSize 50
     */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Aggregated refund summary.
     * @readonly
     */
    summary?: V1AggregatedRefundSummary;
    /**
     * ID of the app that initiated this refund.
     * @format GUID
     * @readonly
     * @immutable
     */
    requestingServiceAppId?: string | null;
}
interface RefundTransaction {
    /**
     * ID of the payment associated with this refund.
     * @format GUID
     * @immutable
     */
    paymentId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatusWithLiterals;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID.
     * This field is only returned when the value of `external_refund` is `false`.
     * @format GUID
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /**
     * Whether refund was made externally and manually on the payment provider's side.
     * @immutable
     */
    externalRefund?: boolean;
}
/** Refund transaction status. */
declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
/** @enumType */
type RefundStatusWithLiterals = RefundStatus | 'PENDING' | 'SUCCEEDED' | 'FAILED' | 'SCHEDULED' | 'STARTED';
interface RefundStatusInfo {
    /**
     * Reason code for the refund's current status.
     *
     * Learn more about [reason codes](https://dev.wix.com/docs/rest/business-management/payments/service-plugins/payment-service-provider-service-plugin/reason-codes).
     * @minLength 1
     * @maxLength 10
     */
    paymentGatewayReasonCode?: string | null;
    /**
     * Free text explanation of current refund status.
     * @minLength 1
     * @maxLength 1000
     */
    description?: string | null;
}
/** Business model of a refund request */
interface RefundDetails {
    /**
     * Order line item IDs and quantities that were refunded.
     * @maxSize 300
     */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /**
     * Reason for the refund, provided by customer (optional).
     * @maxLength 200
     */
    reason?: string | null;
    /**
     * Line items that were refunded.
     * @maxSize 300
     */
    lineItems?: V1LineItemRefund[];
    /**
     * Additional fees that were refunded.
     * @maxSize 100
     */
    additionalFees?: V1AdditionalFeeRefund[];
    /** Shipping amount that was refunded. */
    shipping?: V1ShippingRefund;
}
interface RefundItem {
    /**
     * Line item ID the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity refunded.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface V1LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     * @immutable
     */
    lineItemId?: string;
    /**
     * Refund quantity.
     * @min 1
     * @max 100000
     * @immutable
     */
    quantity?: number;
}
interface V1AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     * @immutable
     */
    additionalFeeId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface V1ShippingRefund {
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface V1AggregatedRefundSummary {
    /** Total amount requested for refund. */
    requestedRefund?: Price;
    /** Pending refund amount - the portion of `requestedRefund` that is still pending. */
    pendingRefund?: Price;
    /** Refunded amount - the portion of `requestedRefund` that refunded successfully. */
    refunded?: Price;
    /** Failed refund amount - the portion of `requestedRefund` that failed. */
    failedRefundAmount?: Price;
    /** Whether at least one refund transaction is still in `"PENDING"` status. */
    pending?: boolean;
    /** Breakdown of refunded items. Available only after refund is complete. */
    breakdown?: RefundItemsBreakdown;
}
interface RefundItemsBreakdown {
    /**
     * Refunded line items and the amount refunded for each.
     * @maxSize 300
     */
    lineItems?: LineItemRefundSummary[];
}
interface LineItemRefundSummary {
    /**
     * ID of the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /** Total refunded amount for the line item. */
    totalRefundedAmount?: Price;
}
interface OrderTransactions {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Record of payments made to the merchant.
     * @maxSize 100
     */
    payments?: Payment[];
    /**
     * Record of refunds made to the buyer.
     * @maxSize 300
     */
    refunds?: Refund[];
}
interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Receipt created by Wix
     * @internal
     */
    wixReceipt?: WixReceiptInfo;
    /**
     * Receipt created by an external system.
     * @internal
     */
    externalReceipt?: ExternalReceiptInfo;
    /**
     * Payment ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
    /**
     * Whether receipt generation for this payment are allowed.
     * + `true`: This payment supports receipt generation.
     * + `false`: This payment not supports receipt generation, or receipt already generated
     * @internal
     * @readonly
     */
    supportReceiptGeneration?: boolean;
}
/** @oneof */
interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
interface PaymentReceiptInfoOneOf {
    /**
     * Receipt created by Wix
     * @internal
     */
    wixReceipt?: WixReceiptInfo;
    /**
     * Receipt created by an external system.
     * @internal
     */
    externalReceipt?: ExternalReceiptInfo;
}
interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Credit card details. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Wix Payments order ID.
     * @maxLength 100
     */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID.
     * This field is only returned when the value of `offline_payment` is `false`.
     * @maxLength 100
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 100
     */
    paymentMethod?: string | null;
    /**
     * Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments.
     * @maxLength 100
     */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
    /**
     * Whether there is a payment agreement that allows for future charges.
     * @immutable
     */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
    /**
     * Payment service provider display name. Non-exhaustive list of supported values: Wix Payments, PayPal, Square, Stripe, etc.
     * @internal
     * @maxLength 300
     */
    paymentProvider?: string | null;
    /**
     * Record of chargebacks made by the buyer.
     * @maxSize 6
     */
    chargebacks?: Chargeback[];
    /**
     * Payment method ID.
     * @internal
     * @maxLength 36
     */
    paymentMethodId?: string | null;
    /**
     * Platform fee amount.
     * @internal
     */
    platformFee?: Price;
}
/** @oneof */
interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Credit card details. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
/** @enumType */
type TransactionStatusWithLiterals = TransactionStatus | 'UNDEFINED' | 'APPROVED' | 'PENDING' | 'PENDING_MERCHANT' | 'CANCELED' | 'DECLINED' | 'REFUNDED' | 'PARTIALLY_REFUNDED' | 'AUTHORIZED' | 'VOIDED';
interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     * @maxSize 1
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: V1ScheduledAction;
}
interface AuthorizationCapture {
    /**
     * Capture ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatusWithLiterals;
    /**
     * Amount of this capture
     * @immutable
     */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    _createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationCaptureStatusWithLiterals = AuthorizationCaptureStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
interface AuthorizationActionFailureDetails {
    /** @maxLength 100 */
    failureCode?: string;
}
interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatusWithLiterals;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: ReasonWithLiterals;
}
declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationVoidStatusWithLiterals = AuthorizationVoidStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
/** Reason the authorization was voided. */
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'MANUAL' | 'SCHEDULED';
interface V1ScheduledAction {
    /** Type of the action. */
    actionType?: ActionTypeWithLiterals;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ActionTypeWithLiterals = ActionType | 'UNKNOWN_ACTION_TYPE' | 'VOID' | 'CAPTURE';
interface Chargeback {
    /**
     * Chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    _id?: string;
    /**
     * Date and time the chargeback was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Date and time the chargeback was updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Amount.
     * @readonly
     * @immutable
     */
    amount?: Price;
    /**
     * Reversal amount. Present only when status is REVERSED.
     * @readonly
     */
    reversalAmount?: Price;
    /**
     * Status.
     *
     * Default: `"APPROVED"`.
     */
    status?: ChargebackStatusWithLiterals;
    /**
     * External chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    externalId?: string | null;
}
declare enum ChargebackStatus {
    UNSPECIFIED = "UNSPECIFIED",
    /** Chargeback was approved. */
    APPROVED = "APPROVED",
    /** Chargeback was reversed. */
    REVERSED = "REVERSED"
}
/** @enumType */
type ChargebackStatusWithLiterals = ChargebackStatus | 'UNSPECIFIED' | 'APPROVED' | 'REVERSED';
interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @minLength 1
     * @maxLength 100
     */
    giftCardPaymentId?: string;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
    /**
     * Gift card obfuscated code.
     * @internal
     * @maxLength 30
     * @immutable
     */
    obfuscatedCode?: string | null;
}
interface MembershipPaymentDetails {
    /**
     * Membership ID.
     * @minLength 1
     * @maxLength 100
     */
    membershipId?: string;
    /**
     * ID of the line item this membership applies to.
     * @minLength 1
     * @maxLength 100
     */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatusWithLiterals;
    /** Membership name. */
    name?: MembershipName;
    /**
     * The transaction ID in the membership system. Can be used to void the transaction.
     * @minLength 1
     * @maxLength 100
     */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /**
     * ID of the application providing this payment option.
     * @format GUID
     */
    providerAppId?: string;
}
declare enum MembershipPaymentStatus {
    /** Payment was charged. */
    CHARGED = "CHARGED",
    /** The attempt to charge the payment failed, for example, due to lack of credits. */
    CHARGE_FAILED = "CHARGE_FAILED"
}
/** @enumType */
type MembershipPaymentStatusWithLiterals = MembershipPaymentStatus | 'CHARGED' | 'CHARGE_FAILED';
interface MembershipName {
    /**
     * Membership name.
     * @maxLength 100
     */
    original?: string;
    /**
     * Translated membership name. Defaults to `original` when not provided.
     * @maxLength 100
     */
    translated?: string | null;
}
interface WixReceiptInfo {
    /**
     * Receipt ID
     * @format GUID
     */
    receiptId?: string;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface ExternalReceiptInfo {
    /**
     * External receipt ID
     * @maxLength 100
     */
    receiptId?: string | null;
    /**
     * ID of the app providing the receipt
     * @format GUID
     */
    appId?: string | null;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface PaymentNotRefundableDetails {
    /**
     * Payment ID that cannot be refunded.
     * @format GUID
     */
    paymentId?: string;
    /** Specific reason why this payment cannot be refunded, such as already being fully refunded or provider restrictions. */
    nonRefundableReason?: NonRefundableReasonWithLiterals;
}
interface AuthorizeChargeWithSavedPaymentMethodRequest {
    /**
     * Order ID.
     *
     * The order must have a saved payment method associated with it.
     * Verify a saved payment method exists by calling List Transactions For Single Order and checking for `regularPaymentDetails.savedPaymentMethod: true`
     * in the order's payment details before calling this method.
     * @format GUID
     */
    orderId: string;
    /**
     * Amount to authorize on the customer's saved payment method.
     * This creates a hold for this amount but doesn't charge the customer until captured.
     */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
    /**
     * Automatic action settings for the authorization.
     * Configure whether to automatically capture or void the authorization after a delay.
     */
    delayedCaptureSettings: DelayedCaptureSettings;
}
interface DelayedCaptureSettings {
    /** Automatic action to perform on the authorization after the specified delay period. */
    scheduledAction?: ScheduledActionWithLiterals;
    /**
     * Time to wait before performing the scheduled action.
     *
     * If not specified, the payment provider's default period will be used.
     */
    delayDuration?: Duration;
}
declare enum ScheduledAction {
    /** Unspecified action - not implemented. */
    UNSPECIFIED = "UNSPECIFIED",
    /**
     * Automatically **void** the authorization after the delay period.
     *
     * Use this when you want to automatically release the hold if payment isn't captured.
     */
    VOID = "VOID",
    /**
     * Automatically **capture** (charge) the authorization after the delay period.
     *
     * Use this for delayed billing or when you want to ensure payment is collected after fulfillment.
     */
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ScheduledActionWithLiterals = ScheduledAction | 'UNSPECIFIED' | 'VOID' | 'CAPTURE';
interface Duration {
    /**
     * Amount of units. For example, 30 MINUTES, 1 HOURS, 7 DAYS, etc
     * @min 1
     */
    count?: number;
    /** Duration unit: MINUTES, HOURS and DAYS */
    unit?: DurationUnitWithLiterals;
}
declare enum DurationUnit {
    UNKNOWN_DURATION_UNIT = "UNKNOWN_DURATION_UNIT",
    MINUTES = "MINUTES",
    HOURS = "HOURS",
    DAYS = "DAYS"
}
/** @enumType */
type DurationUnitWithLiterals = DurationUnit | 'UNKNOWN_DURATION_UNIT' | 'MINUTES' | 'HOURS' | 'DAYS';
interface AuthorizeChargeWithSavedPaymentMethodResponse {
    /** Created payment authorization with `AUTHORIZED` status. */
    payment?: Payment;
    /** Updated order transaction history including the new authorization. */
    orderTransactions?: OrderTransactions;
}
interface VoidAuthorizedPaymentsRequest {
    /**
     * ID of the order containing the payments to void.
     * @format GUID
     */
    orderId: string;
    /**
     * IDs of authorized payments to void (cancel).
     *
     * Only payments with `AUTHORIZED` status can be voided.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    paymentIds: string[];
}
interface VoidAuthorizedPaymentsResponse {
    /** Updated order transaction history with voided payments marked as cancelled. */
    orderTransactions?: OrderTransactions;
}
interface CaptureAuthorizedPaymentsRequest {
    /**
     * ID of the order containing the payments to capture.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment authorizations to capture with their respective amounts.
     *
     * If no amount is specified, the full authorized amount will be captured.
     * @minSize 1
     * @maxSize 100
     */
    payments: PaymentCapture[];
}
interface PaymentCapture {
    /**
     * ID of the payment to capture.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Capture amount.
     *
     * > **Note:** If not provided, the full authorized amount will be captured.
     */
    amount?: Price;
}
interface CaptureAuthorizedPaymentsResponse {
    /** Updated order transaction history with captured payments marked as paid. */
    orderTransactions?: OrderTransactions;
}
interface GenerateReceiptsRequest {
    /**
     * ID of the order containing the payments to generate receipts for.
     * @format GUID
     */
    orderId: string;
    /**
     * IDs of the payments to generate receipts for.
     *
     * Only successful payments with valid payment types can have receipts generated.
     * @minSize 1
     * @maxSize 1
     * @format GUID
     */
    paymentIds: string[];
}
interface GenerateReceiptsResponse {
    /** Information about the generated receipts including receipt IDs for each payment. */
    receipts?: ReceiptInfo[];
}
interface ReceiptInfo {
    /**
     * ID of the payment that the receipt was generated for.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Generated receipt ID that can be used to retrieve the receipt details.
     * @format GUID
     */
    receiptId?: string;
}
interface RedeemGiftCardRequest {
    /**
     * Order ID to apply the gift card payment to.
     * @format GUID
     */
    orderId: string;
    /**
     * Gift card redemption code.
     *
     * The gift card must be active, not expired, and have sufficient balance.
     * @minLength 8
     * @maxLength 20
     */
    giftCardCode: string;
    /**
     * Amount to redeem from the gift card balance.
     *
     * Cannot exceed the gift card's available balance or the order's outstanding amount.
     */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
}
interface RedeemGiftCardResponse {
    /** Updated order transaction history including the gift card payment. */
    orderTransactions?: OrderTransactions;
    /** Created gift card payment transaction with the redeemed amount. */
    payment?: Payment;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
/** @docsIgnore */
type RefundPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'LINE_ITEM_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ADDITIONAL_FEE_NOT_FOUND';
    description?: string;
    data?: AdditionalFeeRefund;
} | {
    code?: 'SHIPPING_NOT_FOUND';
    description?: string;
    data?: ShippingRefund;
} | {
    code?: 'INVALID_PAYMENT_REFUND_AMOUNT';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'INVALID_ADDITIONAL_FEE_REFUND_AMOUNT';
    description?: string;
    data?: AdditionalFeeRefund;
} | {
    code?: 'INVALID_SHIPPING_REFUND_AMOUNT';
    description?: string;
    data?: ShippingRefund;
} | {
    code?: 'INVALID_LINE_ITEM_REFUND_QUANTITY';
    description?: string;
    data?: LineItemRefund;
} | {
    code?: 'INVALID_LINE_ITEM_RESTOCK_QUANTITY';
    description?: string;
    data?: RestockItem;
} | {
    code?: 'PAYMENT_NOT_REFUNDABLE';
    description?: string;
    data?: PaymentNotRefundableDetails;
} | {
    code?: 'EXTERNAL_REFUND_EXPECTED';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'PARTIAL_REFUND_FOR_MULTIPLE_LOCATIONS_NOT_ALLOWED';
    description?: string;
    data?: RestockItem;
};
/** @docsIgnore */
type AuthorizeChargeWithSavedPaymentMethodApplicationErrors = {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_CANCELED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_PAID';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'NO_SAVED_PAYMENT_METHOD';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_HAS_CHARGEBACKS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_AMOUNT';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_CURRENCY';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type VoidAuthorizedPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GATEWAY_TRANSACTION_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_ALREADY_VOIDED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_ALREADY_CAPTURED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_NOT_AUTHORIZED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CaptureAuthorizedPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'INVALID_AMOUNT';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_ALREADY_VOIDED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_ALREADY_CAPTURED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_NOT_AUTHORIZED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_HAS_PENDING_CAPTURE';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'ORDER_HAS_CHARGEBACKS';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type GenerateReceiptsApplicationErrors = {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'RECEIPT_ALREADY_EXIST';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'RECEIPT_GENERATION_IN_PROGRESS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_PAYMENT_TYPE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_PAYMENT_STATUS';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type RedeemGiftCardApplicationErrors = {
    code?: 'GIFT_CARD_ALREADY_APPLIED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CURRENCY_MISMATCH';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_EXPIRED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_DISABLED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INSUFFICIENT_FUNDS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CURRENCY_NOT_SUPPORTED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ALREADY_REDEEMED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_CANCELED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_PAID';
    description?: string;
    data?: Record<string, any>;
};
/**
 * Retrieves refund information about an order's payments, line items, shipping, and additional fees.
 *
 * Returns detailed refundability status for each payment:
 * - `refundable`: Automatic refund is available.
 * - `manuallyRefundable`: Refund is expected to be processed externally. Can be manually marked as refunded.
 * - `nonRefundable`: Refund cannot be performed.
 *
 * Use this method before processing refunds to understand what can be refunded and through which method (automatic vs manual).
 * @param orderId - Order ID.
 * @public
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_GET_ORDER_REFUNDABILITY
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.GetOrderRefundability
 */
declare function getOrderRefundability(orderId: string): Promise<NonNullablePaths<GetOrderRefundabilityResponse, `payments` | `payments.${number}.refundable` | `payments.${number}.manuallyRefundable.reason` | `payments.${number}.nonRefundable.reason` | `payments.${number}.payment.paymentId` | `payments.${number}.payment.offlinePayment` | `paymentsSummary.monetary.paid.amount` | `paymentsSummary.monetary.paid.formattedAmount` | `paymentsSummary.membership.paidLineItemIds` | `paymentsSummary.membership.refundedLineItemIds` | `paymentsSummary.membership.refundableLineItemIds` | `lineItems` | `lineItems.${number}.lineItemId` | `lineItems.${number}.originalQuantity` | `lineItems.${number}.refundedQuantity` | `lineItems.${number}.availableRefundQuantity` | `shipping.amount.amount` | `shipping.amount.formattedAmount` | `additionalFees` | `additionalFees.${number}.additionalFeeId` | `additionalFees.${number}.amount.amount` | `additionalFees.${number}.amount.formattedAmount`, 5>>;
/**
 * Calculates the total refund amount and breakdown for specified line items, shipping, and additional fees.
 *
 * Returns detailed calculations including:
 * - Total refund amount with tax, discount, and subtotal breakdowns
 * - Individual item calculations with pricing details
 * - Validation of whether the requested refund items are available
 *
 * Use this method to preview refund amounts before calling Refund Payments.
 * @param orderId - Order ID to calculate refund for.
 * @public
 * @requiredField options.refundItems.additionalFees.additionalFeeId
 * @requiredField options.refundItems.lineItems.lineItemId
 * @requiredField options.refundItems.lineItems.quantity
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_CALCULATE_REFUND
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.CalculateRefund
 */
declare function calculateRefund(orderId: string, options?: NonNullablePaths<CalculateRefundOptions, `refundItems.additionalFees.${number}.additionalFeeId` | `refundItems.lineItems.${number}.lineItemId` | `refundItems.lineItems.${number}.quantity`, 5>): Promise<NonNullablePaths<CalculateRefundResponse, `available` | `notAvailable.errors` | `notAvailable.errors.${number}.lineItem.lineItemId` | `notAvailable.errors.${number}.lineItem.quantity` | `notAvailable.errors.${number}.additionalFee.additionalFeeId` | `notAvailable.errors.${number}.additionalFee.amount.amount` | `notAvailable.errors.${number}.additionalFee.amount.formattedAmount` | `notAvailable.errors.${number}.error.applicationError.code` | `notAvailable.errors.${number}.error.applicationError.description` | `summary.total.amount` | `summary.total.formattedAmount` | `calculatedRefundItems.lineItems` | `calculatedRefundItems.lineItems.${number}.item.lineItemId` | `calculatedRefundItems.lineItems.${number}.item.quantity` | `calculatedRefundItems.lineItems.${number}.summary.total.amount` | `calculatedRefundItems.lineItems.${number}.summary.total.formattedAmount` | `calculatedRefundItems.additionalFees` | `calculatedRefundItems.additionalFees.${number}.additionalFee.additionalFeeId`, 7>>;
interface CalculateRefundOptions {
    /**
     * Items to include in the refund calculation with their respective quantities and amounts.
     *
     * Specify which line items, shipping charges, and additional fees to refund.
     */
    refundItems?: RefundItems;
}
/**
 * Processes payment refunds by calling payment providers and creating refund transactions.
 *
 * Supports two refund methods:
 * - **Automatic refunds**: Calls the payment provider's API to process the refund.
 * - **External refunds**: Marks payments as refunded without calling providers (for manual provider-side refunds).
 *
 * Set `paymentRefunds.externalRefund = true` for external refunds when you've manually processed the refund and only need to update the order's transaction records.
 *
 * The method also handles restocking inventory and sending customer notifications when specified in `sideEffects`.
 * @param orderId - Order ID to process refunds for.
 * @public
 * @requiredField options.paymentRefunds
 * @requiredField options.paymentRefunds.paymentId
 * @requiredField options.refundItems.additionalFees.additionalFeeId
 * @requiredField options.refundItems.lineItems.lineItemId
 * @requiredField options.refundItems.lineItems.quantity
 * @requiredField options.sideEffects.restock.lineItems.lineItemId
 * @requiredField options.sideEffects.restock.lineItems.quantity
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_REFUND_PAYMENTS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.RefundPayments
 */
declare function refundPayments(orderId: string, options?: NonNullablePaths<RefundPaymentsOptions, `paymentRefunds` | `paymentRefunds.${number}.paymentId` | `refundItems.additionalFees.${number}.additionalFeeId` | `refundItems.lineItems.${number}.lineItemId` | `refundItems.lineItems.${number}.quantity` | `sideEffects.restock.lineItems.${number}.lineItemId` | `sideEffects.restock.lineItems.${number}.quantity`, 6>): Promise<NonNullablePaths<RefundPaymentsResponse, `refund._id` | `refund.transactions` | `refund.transactions.${number}.paymentId` | `refund.transactions.${number}.amount.amount` | `refund.transactions.${number}.amount.formattedAmount` | `refund.transactions.${number}.refundStatus` | `refund.transactions.${number}.externalRefund` | `refund.details.items` | `refund.details.items.${number}.lineItemId` | `refund.details.items.${number}.quantity` | `refund.details.shippingIncluded` | `refund.details.lineItems` | `refund.details.lineItems.${number}.lineItemId` | `refund.details.lineItems.${number}.quantity` | `refund.details.additionalFees` | `refund.details.additionalFees.${number}.additionalFeeId` | `refund.summary.pending` | `refund.summary.breakdown.lineItems` | `refund.summary.breakdown.lineItems.${number}.lineItemId` | `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
    __applicationErrorsType?: RefundPaymentsApplicationErrors;
}>;
interface RefundPaymentsOptions {
    /**
     * Payment refunds specifying which payments to refund and their amounts.
     * Set `externalRefund` to `true` for manual refunds processed outside the system.
     * @minSize 1
     * @maxSize 50
     */
    paymentRefunds: PaymentRefund[];
    /** Additional actions to perform alongside the refund, such as restocking inventory or sending notifications. */
    sideEffects?: RefundSideEffects;
    /** Specific items being refunded including line items, shipping, and additional fees. */
    refundItems?: RefundItems;
    /**
     * Optional customer-provided reason for the refund for record-keeping purposes.
     * @maxLength 200
     */
    customerReason?: string | null;
}
/**
 * Authorizes a payment using an order's previously saved payment method.
 *
 * Creates an authorization hold on the customer's payment method for the specified amount.
 * The authorization reserves funds but does not charge the customer until captured.
 *
 * Use `delayedCaptureSettings` to configure automatic behavior:
 * - `CAPTURE`: Automatically charge the customer after the specified delay
 * - `VOID`: Automatically release the hold after the specified delay
 *
 * Alternatively, manually control the authorization using Capture Authorized Payments or Void Authorized Payments.
 *
 * *Note**: The order must have a saved payment method. Check for `savedPaymentMethod: true` in the order's payment details.
 * @param orderId - Order ID.
 *
 * The order must have a saved payment method associated with it.
 * Verify a saved payment method exists by calling List Transactions For Single Order and checking for `regularPaymentDetails.savedPaymentMethod: true`
 * in the order's payment details before calling this method.
 * @public
 * @requiredField options
 * @requiredField options.amount
 * @requiredField options.amount.amount
 * @requiredField options.currency
 * @requiredField options.delayedCaptureSettings
 * @requiredField options.delayedCaptureSettings.scheduledAction
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_AUTHORIZE_CHARGE_WITH_SAVED_PAYMENT_METHOD
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.AuthorizeChargeWithSavedPaymentMethod
 */
declare function authorizeChargeWithSavedPaymentMethod(orderId: string, options: NonNullablePaths<AuthorizeChargeWithSavedPaymentMethodOptions, `amount` | `amount.amount` | `currency` | `delayedCaptureSettings` | `delayedCaptureSettings.scheduledAction`, 3>): Promise<NonNullablePaths<AuthorizeChargeWithSavedPaymentMethodResponse, `payment.regularPaymentDetails.offlinePayment` | `payment.regularPaymentDetails.status` | `payment.regularPaymentDetails.savedPaymentMethod` | `payment.regularPaymentDetails.authorizationDetails.delayedCapture` | `payment.regularPaymentDetails.authorizationDetails.captures` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.status` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.amount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.formattedAmount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.failureDetails.failureCode` | `payment.regularPaymentDetails.authorizationDetails.void.status` | `payment.regularPaymentDetails.authorizationDetails.void.reason` | `payment.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `payment.regularPaymentDetails.chargebacks` | `payment.regularPaymentDetails.chargebacks.${number}._id` | `payment.regularPaymentDetails.chargebacks.${number}.status` | `payment.giftcardPaymentDetails.giftCardPaymentId` | `payment.giftcardPaymentDetails.appId` | `payment.giftcardPaymentDetails.voided` | `payment.refundDisabled` | `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 8> & {
    __applicationErrorsType?: AuthorizeChargeWithSavedPaymentMethodApplicationErrors;
}>;
interface AuthorizeChargeWithSavedPaymentMethodOptions {
    /**
     * Amount to authorize on the customer's saved payment method.
     * This creates a hold for this amount but doesn't charge the customer until captured.
     */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
    /**
     * Automatic action settings for the authorization.
     * Configure whether to automatically capture or void the authorization after a delay.
     */
    delayedCaptureSettings: DelayedCaptureSettings;
}
/**
 * Voids (cancels) previously authorized payments, releasing the authorization hold without charging the customer.
 *
 * Use this method when you no longer need to capture an authorized payment, such as when an order is cancelled
 * or when inventory becomes unavailable after authorization.
 *
 * *Note**: Only payments with `AUTHORIZED` status can be voided. Already captured payments cannot be voided.
 * @param orderId - ID of the order containing the payments to void.
 * @public
 * @requiredField options
 * @requiredField options.paymentIds
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_VOID_AUTHORIZED_PAYMENTS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.VoidAuthorizedPayments
 */
declare function voidAuthorizedPayments(orderId: string, options: NonNullablePaths<VoidAuthorizedPaymentsOptions, `paymentIds`, 2>): Promise<NonNullablePaths<VoidAuthorizedPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
    __applicationErrorsType?: VoidAuthorizedPaymentsApplicationErrors;
}>;
interface VoidAuthorizedPaymentsOptions {
    /**
     * IDs of authorized payments to void (cancel).
     *
     * Only payments with `AUTHORIZED` status can be voided.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    paymentIds: string[];
}
/**
 * Captures (charges) previously authorized payments, converting the authorization hold into an actual charge.
 *
 * Use this method to complete payment when you're ready to fulfill an order, typically after confirming
 * inventory availability and preparing for shipment.
 *
 * *Note**: Only payments with `AUTHORIZED` status can be captured. The capture amount cannot exceed the authorized amount.
 * @param orderId - ID of the order containing the payments to capture.
 * @public
 * @requiredField options
 * @requiredField options.payments
 * @requiredField options.payments.paymentId
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_CAPTURE_AUTHORIZED_PAYMENTS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.CaptureAuthorizedPayments
 */
declare function captureAuthorizedPayments(orderId: string, options: NonNullablePaths<CaptureAuthorizedPaymentsOptions, `payments` | `payments.${number}.paymentId`, 4>): Promise<NonNullablePaths<CaptureAuthorizedPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
    __applicationErrorsType?: CaptureAuthorizedPaymentsApplicationErrors;
}>;
interface CaptureAuthorizedPaymentsOptions {
    /**
     * Payment authorizations to capture with their respective amounts.
     *
     * If no amount is specified, the full authorized amount will be captured.
     * @minSize 1
     * @maxSize 100
     */
    payments: PaymentCapture[];
}
/**
 * Generates digital receipts for an order's completed payments.
 *
 * Creates formal receipt documents for successful payments that can be provided to customers
 * for record-keeping and tax purposes.
 *
 * *Note**: Only `PAID` status payments with valid payment types can have receipts generated.
 * @param orderId - ID of the order containing the payments to generate receipts for.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.paymentIds
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_GENERATE_RECEIPTS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.GenerateReceipts
 */
declare function generateReceipts(orderId: string, options: NonNullablePaths<GenerateReceiptsOptions, `paymentIds`, 2>): Promise<NonNullablePaths<GenerateReceiptsResponse, `receipts` | `receipts.${number}.paymentId` | `receipts.${number}.receiptId`, 4> & {
    __applicationErrorsType?: GenerateReceiptsApplicationErrors;
}>;
interface GenerateReceiptsOptions {
    /**
     * IDs of the payments to generate receipts for.
     *
     * Only successful payments with valid payment types can have receipts generated.
     * @minSize 1
     * @maxSize 1
     * @format GUID
     */
    paymentIds: string[];
}
/**
 * Redeems a gift card as payment for an order by applying the gift card balance to the order total.
 *
 * Creates a gift card payment transaction and deducts the specified amount from the gift card balance.
 * The redeemed amount reduces the order's outstanding balance.
 *
 * *Prerequisites**:
 * - Gift card must be active and not expired
 * - Gift card must have sufficient balance
 * - Order must not be cancelled or fully paid
 * - Gift card currency must match order currency
 * @param orderId - Order ID to apply the gift card payment to.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.amount
 * @requiredField options.currency
 * @requiredField options.giftCardCode
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_REDEEM_GIFT_CARD
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.RedeemGiftCard
 */
declare function redeemGiftCard(orderId: string, options: NonNullablePaths<RedeemGiftCardOptions, `amount` | `currency` | `giftCardCode`, 2>): Promise<NonNullablePaths<RedeemGiftCardResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending` | `payment.regularPaymentDetails.offlinePayment` | `payment.regularPaymentDetails.status` | `payment.regularPaymentDetails.savedPaymentMethod` | `payment.regularPaymentDetails.authorizationDetails.delayedCapture` | `payment.regularPaymentDetails.authorizationDetails.captures` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.status` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.amount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.formattedAmount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.failureDetails.failureCode` | `payment.regularPaymentDetails.authorizationDetails.void.status` | `payment.regularPaymentDetails.authorizationDetails.void.reason` | `payment.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `payment.regularPaymentDetails.chargebacks` | `payment.regularPaymentDetails.chargebacks.${number}._id` | `payment.regularPaymentDetails.chargebacks.${number}.status` | `payment.giftcardPaymentDetails.giftCardPaymentId` | `payment.giftcardPaymentDetails.appId` | `payment.giftcardPaymentDetails.voided` | `payment.refundDisabled`, 8> & {
    __applicationErrorsType?: RedeemGiftCardApplicationErrors;
}>;
interface RedeemGiftCardOptions {
    /**
     * Gift card redemption code.
     *
     * The gift card must be active, not expired, and have sufficient balance.
     * @minLength 8
     * @maxLength 20
     */
    giftCardCode: string;
    /**
     * Amount to redeem from the gift card balance.
     *
     * Cannot exceed the gift card's available balance or the order's outstanding amount.
     */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
}

export { type ActionEvent, ActionType, type ActionTypeWithLiterals, type AdditionalFeeRefund, type AdditionalFeeRefundability, type AggregatedRefundSummary, type ApplicationError, type AuthorizationActionFailureDetails, type AuthorizationCapture, AuthorizationCaptureStatus, type AuthorizationCaptureStatusWithLiterals, type AuthorizationDetails, type AuthorizationVoid, AuthorizationVoidStatus, type AuthorizationVoidStatusWithLiterals, type AuthorizeChargeWithSavedPaymentMethodApplicationErrors, type AuthorizeChargeWithSavedPaymentMethodOptions, type AuthorizeChargeWithSavedPaymentMethodRequest, type AuthorizeChargeWithSavedPaymentMethodResponse, type CalculateRefundOptions, type CalculateRefundRequest, type CalculateRefundResponse, type CalculateRefundResponseStatusOneOf, type CalculatedAdditionalFeeRefund, type CalculatedLineItemRefund, type CalculatedRefundItems, type CalculatedRefundNotAvailableStatus, type CalculatedRefundSummary, type CalculatedShippingRefund, type CalculationError, type CalculationErrorItemOneOf, type CaptureAuthorizedPaymentsApplicationErrors, type CaptureAuthorizedPaymentsOptions, type CaptureAuthorizedPaymentsRequest, type CaptureAuthorizedPaymentsResponse, type Chargeback, ChargebackStatus, type ChargebackStatusWithLiterals, type CreditCardPaymentMethodDetails, type DelayedCaptureSettings, type Details, type DetailsKindOneOf, type DomainEvent, type DomainEventBodyOneOf, type Duration, DurationUnit, type DurationUnitWithLiterals, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type ExternalReceiptInfo, type ExternalRefundInfo, ExternalRefundStatus, type ExternalRefundStatusWithLiterals, type FieldViolation, type GenerateReceiptsApplicationErrors, type GenerateReceiptsOptions, type GenerateReceiptsRequest, type GenerateReceiptsResponse, type GetOrderRefundabilityRequest, type GetOrderRefundabilityResponse, type GiftCardPaymentDetails, type LineItemRefund, type LineItemRefundSummary, type LineItemRefundability, type ManuallyRefundablePaymentStatus, ManuallyRefundableReason, type ManuallyRefundableReasonWithLiterals, type MembershipName, type MembershipPaymentDetails, MembershipPaymentStatus, type MembershipPaymentStatusWithLiterals, type MembershipPaymentSummary, type MonetaryPaymentSummary, type NonRefundablePaymentStatus, NonRefundableReason, type NonRefundableReasonWithLiterals, type NotificationSideEffects, type OrderBilling, type OrderTransactions, type Payment, type PaymentCapture, type PaymentInfo, type PaymentInfoPaymentMethodDetailsOneOf, type PaymentInfoSummaryOneOf, type PaymentNotRefundableDetails, type PaymentPaymentDetailsOneOf, type PaymentReceiptInfoOneOf, type PaymentRefund, type PaymentRefundability, type PaymentRefundabilityStatusOneOf, type PaymentsSummary, type Price, Reason, type ReasonWithLiterals, type ReceiptInfo, type RedeemGiftCardApplicationErrors, type RedeemGiftCardOptions, type RedeemGiftCardRequest, type RedeemGiftCardResponse, type Refund, type RefundDetails, type RefundItem, type RefundItems, type RefundItemsBreakdown, type RefundPaymentsApplicationErrors, type RefundPaymentsOptions, type RefundPaymentsRequest, type RefundPaymentsResponse, type RefundSideEffects, RefundStatus, type RefundStatusInfo, type RefundStatusWithLiterals, type RefundTransaction, type RegularPaymentDetails, type RegularPaymentDetailsPaymentMethodDetailsOneOf, type RestockItem, type RestockSideEffects, type RestoreInfo, RuleType, type RuleTypeWithLiterals, ScheduledAction, type ScheduledActionWithLiterals, type ShippingRefund, type ShippingRefundability, type SystemError, TransactionStatus, type TransactionStatusWithLiterals, type V1AdditionalFeeRefund, type V1AggregatedRefundSummary, type V1LineItemRefund, type V1ScheduledAction, type V1ShippingRefund, type ValidationError, type VoidAuthorizedPaymentsApplicationErrors, type VoidAuthorizedPaymentsOptions, type VoidAuthorizedPaymentsRequest, type VoidAuthorizedPaymentsResponse, type WixReceiptInfo, authorizeChargeWithSavedPaymentMethod, calculateRefund, captureAuthorizedPayments, generateReceipts, getOrderRefundability, redeemGiftCard, refundPayments, voidAuthorizedPayments };
