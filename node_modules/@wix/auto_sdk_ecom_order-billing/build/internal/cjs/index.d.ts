import { HttpClient, NonNullablePaths, MaybeContext, BuildRESTFunction } from '@wix/sdk-types';
import { GetOrderRefundabilityResponse, CalculateRefundOptions, CalculateRefundResponse, RefundPaymentsOptions, RefundPaymentsResponse, RefundPaymentsApplicationErrors, AuthorizeChargeWithSavedPaymentMethodOptions, AuthorizeChargeWithSavedPaymentMethodResponse, AuthorizeChargeWithSavedPaymentMethodApplicationErrors, VoidAuthorizedPaymentsOptions, VoidAuthorizedPaymentsResponse, VoidAuthorizedPaymentsApplicationErrors, CaptureAuthorizedPaymentsOptions, CaptureAuthorizedPaymentsResponse, CaptureAuthorizedPaymentsApplicationErrors, GenerateReceiptsOptions, GenerateReceiptsResponse, GenerateReceiptsApplicationErrors, RedeemGiftCardOptions, RedeemGiftCardResponse, RedeemGiftCardApplicationErrors } from './index.typings.js';
export { ActionEvent, ActionType, ActionTypeWithLiterals, AdditionalFeeRefund, AdditionalFeeRefundability, AggregatedRefundSummary, ApplicationError, AuthorizationActionFailureDetails, AuthorizationCapture, AuthorizationCaptureStatus, AuthorizationCaptureStatusWithLiterals, AuthorizationDetails, AuthorizationVoid, AuthorizationVoidStatus, AuthorizationVoidStatusWithLiterals, AuthorizeChargeWithSavedPaymentMethodRequest, CalculateRefundRequest, CalculateRefundResponseStatusOneOf, CalculatedAdditionalFeeRefund, CalculatedLineItemRefund, CalculatedRefundItems, CalculatedRefundNotAvailableStatus, CalculatedRefundSummary, CalculatedShippingRefund, CalculationError, CalculationErrorItemOneOf, CaptureAuthorizedPaymentsRequest, Chargeback, ChargebackStatus, ChargebackStatusWithLiterals, CreditCardPaymentMethodDetails, DelayedCaptureSettings, Details, DetailsKindOneOf, DomainEvent, DomainEventBodyOneOf, Duration, DurationUnit, DurationUnitWithLiterals, Empty, EntityCreatedEvent, EntityDeletedEvent, EntityUpdatedEvent, ExternalReceiptInfo, ExternalRefundInfo, ExternalRefundStatus, ExternalRefundStatusWithLiterals, FieldViolation, GenerateReceiptsRequest, GetOrderRefundabilityRequest, GiftCardPaymentDetails, LineItemRefund, LineItemRefundSummary, LineItemRefundability, ManuallyRefundablePaymentStatus, ManuallyRefundableReason, ManuallyRefundableReasonWithLiterals, MembershipName, MembershipPaymentDetails, MembershipPaymentStatus, MembershipPaymentStatusWithLiterals, MembershipPaymentSummary, MonetaryPaymentSummary, NonRefundablePaymentStatus, NonRefundableReason, NonRefundableReasonWithLiterals, NotificationSideEffects, OrderBilling, OrderTransactions, Payment, PaymentCapture, PaymentInfo, PaymentInfoPaymentMethodDetailsOneOf, PaymentInfoSummaryOneOf, PaymentNotRefundableDetails, PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf, PaymentRefund, PaymentRefundability, PaymentRefundabilityStatusOneOf, PaymentsSummary, Price, Reason, ReasonWithLiterals, ReceiptInfo, RedeemGiftCardRequest, Refund, RefundDetails, RefundItem, RefundItems, RefundItemsBreakdown, RefundPaymentsRequest, RefundSideEffects, RefundStatus, RefundStatusInfo, RefundStatusWithLiterals, RefundTransaction, RegularPaymentDetails, RegularPaymentDetailsPaymentMethodDetailsOneOf, RestockItem, RestockSideEffects, RestoreInfo, RuleType, RuleTypeWithLiterals, ScheduledAction, ScheduledActionWithLiterals, ShippingRefund, ShippingRefundability, SystemError, TransactionStatus, TransactionStatusWithLiterals, V1AdditionalFeeRefund, V1AggregatedRefundSummary, V1LineItemRefund, V1ScheduledAction, V1ShippingRefund, ValidationError, VoidAuthorizedPaymentsRequest, WixReceiptInfo } from './index.typings.js';

declare function getOrderRefundability$1(httpClient: HttpClient): GetOrderRefundabilitySignature;
interface GetOrderRefundabilitySignature {
    /**
     * Retrieves refund information about an order's payments, line items, shipping, and additional fees.
     *
     * Returns detailed refundability status for each payment:
     * - `refundable`: Automatic refund is available.
     * - `manuallyRefundable`: Refund is expected to be processed externally. Can be manually marked as refunded.
     * - `nonRefundable`: Refund cannot be performed.
     *
     * Use this method before processing refunds to understand what can be refunded and through which method (automatic vs manual).
     * @param - Order ID.
     */
    (orderId: string): Promise<NonNullablePaths<GetOrderRefundabilityResponse, `payments` | `payments.${number}.refundable` | `payments.${number}.manuallyRefundable.reason` | `payments.${number}.nonRefundable.reason` | `payments.${number}.payment.paymentId` | `payments.${number}.payment.offlinePayment` | `paymentsSummary.monetary.paid.amount` | `paymentsSummary.monetary.paid.formattedAmount` | `paymentsSummary.membership.paidLineItemIds` | `paymentsSummary.membership.refundedLineItemIds` | `paymentsSummary.membership.refundableLineItemIds` | `lineItems` | `lineItems.${number}.lineItemId` | `lineItems.${number}.originalQuantity` | `lineItems.${number}.refundedQuantity` | `lineItems.${number}.availableRefundQuantity` | `shipping.amount.amount` | `shipping.amount.formattedAmount` | `additionalFees` | `additionalFees.${number}.additionalFeeId` | `additionalFees.${number}.amount.amount` | `additionalFees.${number}.amount.formattedAmount`, 5>>;
}
declare function calculateRefund$1(httpClient: HttpClient): CalculateRefundSignature;
interface CalculateRefundSignature {
    /**
     * Calculates the total refund amount and breakdown for specified line items, shipping, and additional fees.
     *
     * Returns detailed calculations including:
     * - Total refund amount with tax, discount, and subtotal breakdowns
     * - Individual item calculations with pricing details
     * - Validation of whether the requested refund items are available
     *
     * Use this method to preview refund amounts before calling Refund Payments.
     * @param - Order ID to calculate refund for.
     */
    (orderId: string, options?: NonNullablePaths<CalculateRefundOptions, `refundItems.additionalFees.${number}.additionalFeeId` | `refundItems.lineItems.${number}.lineItemId` | `refundItems.lineItems.${number}.quantity`, 5>): Promise<NonNullablePaths<CalculateRefundResponse, `available` | `notAvailable.errors` | `notAvailable.errors.${number}.lineItem.lineItemId` | `notAvailable.errors.${number}.lineItem.quantity` | `notAvailable.errors.${number}.additionalFee.additionalFeeId` | `notAvailable.errors.${number}.additionalFee.amount.amount` | `notAvailable.errors.${number}.additionalFee.amount.formattedAmount` | `notAvailable.errors.${number}.error.applicationError.code` | `notAvailable.errors.${number}.error.applicationError.description` | `summary.total.amount` | `summary.total.formattedAmount` | `calculatedRefundItems.lineItems` | `calculatedRefundItems.lineItems.${number}.item.lineItemId` | `calculatedRefundItems.lineItems.${number}.item.quantity` | `calculatedRefundItems.lineItems.${number}.summary.total.amount` | `calculatedRefundItems.lineItems.${number}.summary.total.formattedAmount` | `calculatedRefundItems.additionalFees` | `calculatedRefundItems.additionalFees.${number}.additionalFee.additionalFeeId`, 7>>;
}
declare function refundPayments$1(httpClient: HttpClient): RefundPaymentsSignature;
interface RefundPaymentsSignature {
    /**
     * Processes payment refunds by calling payment providers and creating refund transactions.
     *
     * Supports two refund methods:
     * - **Automatic refunds**: Calls the payment provider's API to process the refund.
     * - **External refunds**: Marks payments as refunded without calling providers (for manual provider-side refunds).
     *
     * Set `paymentRefunds.externalRefund = true` for external refunds when you've manually processed the refund and only need to update the order's transaction records.
     *
     * The method also handles restocking inventory and sending customer notifications when specified in `sideEffects`.
     * @param - Order ID to process refunds for.
     */
    (orderId: string, options?: NonNullablePaths<RefundPaymentsOptions, `paymentRefunds` | `paymentRefunds.${number}.paymentId` | `refundItems.additionalFees.${number}.additionalFeeId` | `refundItems.lineItems.${number}.lineItemId` | `refundItems.lineItems.${number}.quantity` | `sideEffects.restock.lineItems.${number}.lineItemId` | `sideEffects.restock.lineItems.${number}.quantity`, 6>): Promise<NonNullablePaths<RefundPaymentsResponse, `refund._id` | `refund.transactions` | `refund.transactions.${number}.paymentId` | `refund.transactions.${number}.amount.amount` | `refund.transactions.${number}.amount.formattedAmount` | `refund.transactions.${number}.refundStatus` | `refund.transactions.${number}.externalRefund` | `refund.details.items` | `refund.details.items.${number}.lineItemId` | `refund.details.items.${number}.quantity` | `refund.details.shippingIncluded` | `refund.details.lineItems` | `refund.details.lineItems.${number}.lineItemId` | `refund.details.lineItems.${number}.quantity` | `refund.details.additionalFees` | `refund.details.additionalFees.${number}.additionalFeeId` | `refund.summary.pending` | `refund.summary.breakdown.lineItems` | `refund.summary.breakdown.lineItems.${number}.lineItemId` | `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
        __applicationErrorsType?: RefundPaymentsApplicationErrors;
    }>;
}
declare function authorizeChargeWithSavedPaymentMethod$1(httpClient: HttpClient): AuthorizeChargeWithSavedPaymentMethodSignature;
interface AuthorizeChargeWithSavedPaymentMethodSignature {
    /**
     * Authorizes a payment using an order's previously saved payment method.
     *
     * Creates an authorization hold on the customer's payment method for the specified amount.
     * The authorization reserves funds but does not charge the customer until captured.
     *
     * Use `delayedCaptureSettings` to configure automatic behavior:
     * - `CAPTURE`: Automatically charge the customer after the specified delay
     * - `VOID`: Automatically release the hold after the specified delay
     *
     * Alternatively, manually control the authorization using Capture Authorized Payments or Void Authorized Payments.
     *
     * *Note**: The order must have a saved payment method. Check for `savedPaymentMethod: true` in the order's payment details.
     * @param - Order ID.
     *
     * The order must have a saved payment method associated with it.
     * Verify a saved payment method exists by calling List Transactions For Single Order and checking for `regularPaymentDetails.savedPaymentMethod: true`
     * in the order's payment details before calling this method.
     */
    (orderId: string, options: NonNullablePaths<AuthorizeChargeWithSavedPaymentMethodOptions, `amount` | `amount.amount` | `currency` | `delayedCaptureSettings` | `delayedCaptureSettings.scheduledAction`, 3>): Promise<NonNullablePaths<AuthorizeChargeWithSavedPaymentMethodResponse, `payment.regularPaymentDetails.offlinePayment` | `payment.regularPaymentDetails.status` | `payment.regularPaymentDetails.savedPaymentMethod` | `payment.regularPaymentDetails.authorizationDetails.delayedCapture` | `payment.regularPaymentDetails.authorizationDetails.captures` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.status` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.amount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.formattedAmount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.failureDetails.failureCode` | `payment.regularPaymentDetails.authorizationDetails.void.status` | `payment.regularPaymentDetails.authorizationDetails.void.reason` | `payment.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `payment.regularPaymentDetails.chargebacks` | `payment.regularPaymentDetails.chargebacks.${number}._id` | `payment.regularPaymentDetails.chargebacks.${number}.status` | `payment.giftcardPaymentDetails.giftCardPaymentId` | `payment.giftcardPaymentDetails.appId` | `payment.giftcardPaymentDetails.voided` | `payment.refundDisabled` | `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 8> & {
        __applicationErrorsType?: AuthorizeChargeWithSavedPaymentMethodApplicationErrors;
    }>;
}
declare function voidAuthorizedPayments$1(httpClient: HttpClient): VoidAuthorizedPaymentsSignature;
interface VoidAuthorizedPaymentsSignature {
    /**
     * Voids (cancels) previously authorized payments, releasing the authorization hold without charging the customer.
     *
     * Use this method when you no longer need to capture an authorized payment, such as when an order is cancelled
     * or when inventory becomes unavailable after authorization.
     *
     * *Note**: Only payments with `AUTHORIZED` status can be voided. Already captured payments cannot be voided.
     * @param - ID of the order containing the payments to void.
     */
    (orderId: string, options: NonNullablePaths<VoidAuthorizedPaymentsOptions, `paymentIds`, 2>): Promise<NonNullablePaths<VoidAuthorizedPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
        __applicationErrorsType?: VoidAuthorizedPaymentsApplicationErrors;
    }>;
}
declare function captureAuthorizedPayments$1(httpClient: HttpClient): CaptureAuthorizedPaymentsSignature;
interface CaptureAuthorizedPaymentsSignature {
    /**
     * Captures (charges) previously authorized payments, converting the authorization hold into an actual charge.
     *
     * Use this method to complete payment when you're ready to fulfill an order, typically after confirming
     * inventory availability and preparing for shipment.
     *
     * *Note**: Only payments with `AUTHORIZED` status can be captured. The capture amount cannot exceed the authorized amount.
     * @param - ID of the order containing the payments to capture.
     */
    (orderId: string, options: NonNullablePaths<CaptureAuthorizedPaymentsOptions, `payments` | `payments.${number}.paymentId`, 4>): Promise<NonNullablePaths<CaptureAuthorizedPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7> & {
        __applicationErrorsType?: CaptureAuthorizedPaymentsApplicationErrors;
    }>;
}
declare function generateReceipts$1(httpClient: HttpClient): GenerateReceiptsSignature;
interface GenerateReceiptsSignature {
    /**
     * Generates digital receipts for an order's completed payments.
     *
     * Creates formal receipt documents for successful payments that can be provided to customers
     * for record-keeping and tax purposes.
     *
     * *Note**: Only `PAID` status payments with valid payment types can have receipts generated.
     * @param - ID of the order containing the payments to generate receipts for.
     */
    (orderId: string, options: NonNullablePaths<GenerateReceiptsOptions, `paymentIds`, 2>): Promise<NonNullablePaths<GenerateReceiptsResponse, `receipts` | `receipts.${number}.paymentId` | `receipts.${number}.receiptId`, 4> & {
        __applicationErrorsType?: GenerateReceiptsApplicationErrors;
    }>;
}
declare function redeemGiftCard$1(httpClient: HttpClient): RedeemGiftCardSignature;
interface RedeemGiftCardSignature {
    /**
     * Redeems a gift card as payment for an order by applying the gift card balance to the order total.
     *
     * Creates a gift card payment transaction and deducts the specified amount from the gift card balance.
     * The redeemed amount reduces the order's outstanding balance.
     *
     * *Prerequisites**:
     * - Gift card must be active and not expired
     * - Gift card must have sufficient balance
     * - Order must not be cancelled or fully paid
     * - Gift card currency must match order currency
     * @param - Order ID to apply the gift card payment to.
     */
    (orderId: string, options: NonNullablePaths<RedeemGiftCardOptions, `amount` | `currency` | `giftCardCode`, 2>): Promise<NonNullablePaths<RedeemGiftCardResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending` | `payment.regularPaymentDetails.offlinePayment` | `payment.regularPaymentDetails.status` | `payment.regularPaymentDetails.savedPaymentMethod` | `payment.regularPaymentDetails.authorizationDetails.delayedCapture` | `payment.regularPaymentDetails.authorizationDetails.captures` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.status` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.amount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.formattedAmount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.failureDetails.failureCode` | `payment.regularPaymentDetails.authorizationDetails.void.status` | `payment.regularPaymentDetails.authorizationDetails.void.reason` | `payment.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `payment.regularPaymentDetails.chargebacks` | `payment.regularPaymentDetails.chargebacks.${number}._id` | `payment.regularPaymentDetails.chargebacks.${number}.status` | `payment.giftcardPaymentDetails.giftCardPaymentId` | `payment.giftcardPaymentDetails.appId` | `payment.giftcardPaymentDetails.voided` | `payment.refundDisabled`, 8> & {
        __applicationErrorsType?: RedeemGiftCardApplicationErrors;
    }>;
}

declare const getOrderRefundability: MaybeContext<BuildRESTFunction<typeof getOrderRefundability$1> & typeof getOrderRefundability$1>;
declare const calculateRefund: MaybeContext<BuildRESTFunction<typeof calculateRefund$1> & typeof calculateRefund$1>;
declare const refundPayments: MaybeContext<BuildRESTFunction<typeof refundPayments$1> & typeof refundPayments$1>;
declare const authorizeChargeWithSavedPaymentMethod: MaybeContext<BuildRESTFunction<typeof authorizeChargeWithSavedPaymentMethod$1> & typeof authorizeChargeWithSavedPaymentMethod$1>;
declare const voidAuthorizedPayments: MaybeContext<BuildRESTFunction<typeof voidAuthorizedPayments$1> & typeof voidAuthorizedPayments$1>;
declare const captureAuthorizedPayments: MaybeContext<BuildRESTFunction<typeof captureAuthorizedPayments$1> & typeof captureAuthorizedPayments$1>;
declare const generateReceipts: MaybeContext<BuildRESTFunction<typeof generateReceipts$1> & typeof generateReceipts$1>;
declare const redeemGiftCard: MaybeContext<BuildRESTFunction<typeof redeemGiftCard$1> & typeof redeemGiftCard$1>;

export { AuthorizeChargeWithSavedPaymentMethodApplicationErrors, AuthorizeChargeWithSavedPaymentMethodOptions, AuthorizeChargeWithSavedPaymentMethodResponse, CalculateRefundOptions, CalculateRefundResponse, CaptureAuthorizedPaymentsApplicationErrors, CaptureAuthorizedPaymentsOptions, CaptureAuthorizedPaymentsResponse, GenerateReceiptsApplicationErrors, GenerateReceiptsOptions, GenerateReceiptsResponse, GetOrderRefundabilityResponse, RedeemGiftCardApplicationErrors, RedeemGiftCardOptions, RedeemGiftCardResponse, RefundPaymentsApplicationErrors, RefundPaymentsOptions, RefundPaymentsResponse, VoidAuthorizedPaymentsApplicationErrors, VoidAuthorizedPaymentsOptions, VoidAuthorizedPaymentsResponse, authorizeChargeWithSavedPaymentMethod, calculateRefund, captureAuthorizedPayments, generateReceipts, getOrderRefundability, redeemGiftCard, refundPayments, voidAuthorizedPayments };
