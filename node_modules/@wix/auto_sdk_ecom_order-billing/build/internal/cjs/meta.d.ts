import { GetOrderRefundabilityRequest as GetOrderRefundabilityRequest$1, GetOrderRefundabilityResponse as GetOrderRefundabilityResponse$1, CalculateRefundRequest as CalculateRefundRequest$1, CalculateRefundResponse as CalculateRefundResponse$1, RefundPaymentsRequest as RefundPaymentsRequest$1, RefundPaymentsResponse as RefundPaymentsResponse$1, AuthorizeChargeWithSavedPaymentMethodRequest as AuthorizeChargeWithSavedPaymentMethodRequest$1, AuthorizeChargeWithSavedPaymentMethodResponse as AuthorizeChargeWithSavedPaymentMethodResponse$1, VoidAuthorizedPaymentsRequest as VoidAuthorizedPaymentsRequest$1, VoidAuthorizedPaymentsResponse as VoidAuthorizedPaymentsResponse$1, CaptureAuthorizedPaymentsRequest as CaptureAuthorizedPaymentsRequest$1, CaptureAuthorizedPaymentsResponse as CaptureAuthorizedPaymentsResponse$1, GenerateReceiptsRequest as GenerateReceiptsRequest$1, GenerateReceiptsResponse as GenerateReceiptsResponse$1, RedeemGiftCardRequest as RedeemGiftCardRequest$1, RedeemGiftCardResponse as RedeemGiftCardResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

interface OrderBilling {
    /**
     * Entity ID.
     * @format GUID
     */
    id?: string | null;
}
interface GetOrderRefundabilityRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
}
interface GetOrderRefundabilityResponse {
    /**
     * Payment refundability status and amounts for each payment method used in the order.
     *
     * Shows whether payments can be refunded automatically, manually, or not at all.
     * @maxSize 100
     */
    payments?: PaymentRefundability[];
    /** Aggregated summary of all payment amounts across all payment methods. */
    paymentsSummary?: PaymentsSummary;
    /**
     * Line item refundability showing available refund quantities for each product.
     * @maxSize 300
     */
    lineItems?: LineItemRefundability[];
    /**
     * Shipping refundability including original amount, previously refunded amount, and remaining refundable amount.
     *
     * Only present if the order includes shipping charges.
     */
    shipping?: ShippingRefundability;
    /**
     * List of additional fee refund amounts - both previously refunded and the amount still available for refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefundability[];
}
interface PaymentRefundability extends PaymentRefundabilityStatusOneOf {
    /**
     * Whether the payment supports automatic API-based refunds.
     * Choose automatic refunds for faster processing when possible.
     */
    refundable?: boolean;
    /**
     * Payment requires manual/external refund processing. Can be manually marked as refunded.
     * Use the provided `providerLink` to access the provider's refund interface.
     */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /**
     * Payment cannot be refunded due to business rules, provider restrictions, or payment state.
     * Check the specific reason to understand why refunding is not possible.
     */
    nonRefundable?: NonRefundablePaymentStatus;
    /** Payment details including method, amounts, and transaction information. */
    payment?: PaymentInfo;
    /**
     * URL to the payment provider's dashboard for manual refund processing.
     * Required when payment has manual refund status.
     * @format WEB_URL
     */
    providerLink?: string | null;
}
/** @oneof */
interface PaymentRefundabilityStatusOneOf {
    /**
     * Whether the payment supports automatic API-based refunds.
     * Choose automatic refunds for faster processing when possible.
     */
    refundable?: boolean;
    /**
     * Payment requires manual/external refund processing. Can be manually marked as refunded.
     * Use the provided `providerLink` to access the provider's refund interface.
     */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /**
     * Payment cannot be refunded due to business rules, provider restrictions, or payment state.
     * Check the specific reason to understand why refunding is not possible.
     */
    nonRefundable?: NonRefundablePaymentStatus;
}
interface PaymentInfo extends PaymentInfoSummaryOneOf, PaymentInfoPaymentMethodDetailsOneOf {
    /** Monetary payment details with amounts for cash-based payments. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment details for payments made using membership credits or plans. */
    membership?: MembershipPaymentSummary;
    /** Credit card information for credit card payments, including card type and last 4 digits. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Payment ID used to reference this payment in refund operations.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Payment method type used for this transaction.
     *
     * Non-exhaustive list of supported values: `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 50
     */
    paymentMethod?: string | null;
    /**
     * Whether this payment was processed offline (not through an online payment gateway).
     * Offline payments typically require manual refund processing.
     */
    offlinePayment?: boolean;
}
/** @oneof */
interface PaymentInfoSummaryOneOf {
    /** Monetary payment details with amounts for cash-based payments. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment details for payments made using membership credits or plans. */
    membership?: MembershipPaymentSummary;
}
/** @oneof */
interface PaymentInfoPaymentMethodDetailsOneOf {
    /** Credit card information for credit card payments, including card type and last 4 digits. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
interface MonetaryPaymentSummary {
    /** Amount paid. */
    paid?: Price;
    /** Total amount already refunded from this payment method. */
    refunded?: Price;
    /** Amount currently being processed for refund but not yet completed. */
    refundPending?: Price;
    /**
     * Maximum amount available for additional refunds if the payment is refundable.
     * Calculated as: `paid` - `refunded` - `refundPending`
     */
    maxRefund?: Price;
}
interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
interface MembershipPaymentSummary {
    /**
     * Line item IDs that were originally paid using membership credits or benefits.
     * @format GUID
     * @maxSize 100
     */
    paidLineItemIds?: string[];
    /**
     * Line item IDs that were previously refunded and had been paid with membership benefits.
     * These items have already been processed for membership credit restoration.
     * @format GUID
     * @maxSize 100
     */
    refundedLineItemIds?: string[];
    /**
     * Line item IDs paid with membership benefits that can still be refunded.
     * Refunding these items may restore membership credits to the customer's account.
     * @format GUID
     * @maxSize 100
     */
    refundableLineItemIds?: string[];
}
interface CreditCardPaymentMethodDetails {
    /**
     * The last 4 digits of the card number.
     * @maxLength 4
     */
    lastFourDigits?: string | null;
    /**
     * Card issuer's brand.
     * @maxLength 100
     */
    brand?: string | null;
}
interface ManuallyRefundablePaymentStatus {
    /** Specific reason why this payment requires manual refund processing. */
    reason?: ManuallyRefundableReasonWithLiterals;
}
declare enum ManuallyRefundableReason {
    /** Unknown manual refund reason. */
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /**
     * Payment authorization or refund window has expired with the payment provider.
     * Refunds must be processed manually through the provider's dashboard.
     */
    EXPIRED = "EXPIRED",
    /**
     * Payment provider does not support automatic refunds for this payment method.
     * Manual refund through provider dashboard is required.
     */
    NOT_SUPPORTED = "NOT_SUPPORTED",
    /**
     * Payment was processed offline (cash, check, or manually marked as paid).
     * Refund must be handled manually outside the payment system.
     */
    OFFLINE = "OFFLINE",
    /**
     * Payment requires a physical card reader device to process the refund.
     * Typically applies to in-person credit card transactions.
     */
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
/** @enumType */
type ManuallyRefundableReasonWithLiterals = ManuallyRefundableReason | 'UNKNOWN_REASON' | 'EXPIRED' | 'NOT_SUPPORTED' | 'OFFLINE' | 'REQUIRES_CARD_READER';
interface NonRefundablePaymentStatus {
    /** Specific reason why this payment cannot be refunded through any method. */
    reason?: NonRefundableReasonWithLiterals;
}
declare enum NonRefundableReason {
    /** Unknown non-refundable reason. */
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Payment has already been fully refunded. No additional refund amount is available. */
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    /**
     * Payment provider's system is currently unavailable for refund processing.
     * Try again later or contact the provider directly.
     */
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    /** Payment has not been successfully completed. Only paid transactions can be refunded. */
    NOT_PAID = "NOT_PAID",
    /** Payment amount is zero, so there is nothing to refund. */
    ZERO_PRICE = "ZERO_PRICE",
    /** Payment provider has disabled refunds for this payment method or account. */
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    /** A refund is already in progress for this payment. Wait for completion before initiating another refund. */
    PENDING_REFUND = "PENDING_REFUND",
    /** Refund is not allowed due to business rules, compliance restrictions, or account limitations. */
    FORBIDDEN = "FORBIDDEN",
    /** Payment transaction cannot be found in the provider's system, preventing refund processing. */
    TRANSACTION_NOT_FOUND = "TRANSACTION_NOT_FOUND",
    /** Order is still pending confirmation and has not been finalized for refund processing. */
    ORDER_IS_PENDING = "ORDER_IS_PENDING",
    /** Order was rejected or cancelled before payment completion, making refunds unnecessary. */
    ORDER_IS_REJECTED = "ORDER_IS_REJECTED",
    /** Payment amount has been offset by chargeback claims, preventing standard refund processing. */
    AMOUNT_OFFSET_BY_CHARGEBACK = "AMOUNT_OFFSET_BY_CHARGEBACK"
}
/** @enumType */
type NonRefundableReasonWithLiterals = NonRefundableReason | 'UNKNOWN_REASON' | 'ALREADY_REFUNDED' | 'PROVIDER_IS_DOWN' | 'NOT_PAID' | 'ZERO_PRICE' | 'DISABLED_BY_PROVIDER' | 'PENDING_REFUND' | 'FORBIDDEN' | 'TRANSACTION_NOT_FOUND' | 'ORDER_IS_PENDING' | 'ORDER_IS_REJECTED' | 'AMOUNT_OFFSET_BY_CHARGEBACK';
interface PaymentsSummary {
    /** Summary of cash-based payment methods (credit cards, PayPal, etc.). */
    monetary?: MonetaryPaymentSummary;
    /** Summary of membership-based payments using credits, plans, or benefits. */
    membership?: MembershipPaymentSummary;
}
interface LineItemRefundability {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /** Total quantity of this item originally ordered. */
    originalQuantity?: number;
    /** Quantity of this item previously refunded across all refund transactions. */
    refundedQuantity?: number;
    /** Maximum quantity of this item that can still be refunded. */
    availableRefundQuantity?: number;
}
interface ShippingRefundability {
    /** Original shipping fee amount. */
    amount?: Price;
    /** Previously refunded shipping fee amount. */
    refundedAmount?: Price;
    /** Shipping fee amount available for refund. */
    availableRefundAmount?: Price;
}
interface AdditionalFeeRefundability {
    /**
     * Additional fee ID.
     * @format GUID
     */
    additionalFeeId?: string;
    /** Original additional fee amount. */
    amount?: Price;
    /** Previously refunded additional fee amount. */
    refundedAmount?: Price;
    /** Additional fee amount available for refund. */
    availableRefundAmount?: Price;
}
interface CalculateRefundRequest {
    /**
     * Order ID to calculate refund for.
     * @format GUID
     */
    orderId: string;
    /**
     * Items to include in the refund calculation with their respective quantities and amounts.
     *
     * Specify which line items, shipping charges, and additional fees to refund.
     */
    refundItems?: RefundItems;
}
interface RefundItems {
    /**
     * Line items and their quantities to refund.
     * @maxSize 300
     */
    lineItems?: LineItemRefund[];
    /**
     * Additional fees and their amounts to refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefund[];
    /** Shipping amount to refund. */
    shipping?: ShippingRefund;
}
interface LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity of this product to refund.
     * Cannot exceed the available refund quantity for this line item.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface AdditionalFeeRefund {
    /**
     * Additional fee ID to refund.
     * @format GUID
     */
    additionalFeeId?: string;
    /**
     * Amount of the additional fee to refund.
     * If not specified, the full remaining refundable amount for this fee will be refunded.
     */
    amount?: Price;
}
interface ShippingRefund {
    /**
     * Amount of shipping charges to refund.
     * If not specified, the full remaining refundable shipping amount will be refunded.
     */
    amount?: Price;
}
interface CalculateRefundResponse extends CalculateRefundResponseStatusOneOf {
    /**
     * Whether the refund is available for all requested items.
     *
     * `true` indicates all items can be refunded as requested.
     */
    available?: boolean;
    /**
     * Refund unavailability details when some or all items cannot be refunded.
     *
     * Contains specific error information for each problematic item.
     */
    notAvailable?: CalculatedRefundNotAvailableStatus;
    /**
     * Aggregated summary of all items provided for refund.
     *
     * This field is not returned when refund is not available for the given list of items.
     */
    summary?: AggregatedRefundSummary;
    /** Detailed refund calculations broken down by each requested item type. */
    calculatedRefundItems?: CalculatedRefundItems;
}
/** @oneof */
interface CalculateRefundResponseStatusOneOf {
    /**
     * Whether the refund is available for all requested items.
     *
     * `true` indicates all items can be refunded as requested.
     */
    available?: boolean;
    /**
     * Refund unavailability details when some or all items cannot be refunded.
     *
     * Contains specific error information for each problematic item.
     */
    notAvailable?: CalculatedRefundNotAvailableStatus;
}
interface AggregatedRefundSummary {
    /** Total refund amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
    /** Total cost of the line items being refunded (without tax and discount). */
    lineItemsSubtotal?: Price;
    /** Total cost of the additional fees being refunded. */
    additionalFeesTotal?: Price;
}
interface CalculatedRefundItems {
    /**
     * Calculated refund details for each line item.
     * @maxSize 300
     */
    lineItems?: CalculatedLineItemRefund[];
    /**
     * Calculated refund details for each additional fee.
     * @maxSize 100
     */
    additionalFees?: CalculatedAdditionalFeeRefund[];
    /** Calculated refund details for the shipping fee. */
    shipping?: CalculatedShippingRefund;
}
interface CalculatedLineItemRefund {
    /** Line item refund details. */
    item?: LineItemRefund;
    /** Calculated refund summary for this line item. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedRefundSummary {
    /** Total refundable amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
}
interface CalculatedAdditionalFeeRefund {
    /** Additional fee refund details. */
    additionalFee?: AdditionalFeeRefund;
    /** Calculated refund summary for this additional fee. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedShippingRefund {
    /** Shipping refund details. */
    shipping?: ShippingRefund;
    /** Calculated refund summary for shipping. */
    summary?: CalculatedRefundSummary;
}
interface CalculatedRefundNotAvailableStatus {
    /**
     * Refund calculation errors.
     * @maxSize 401
     */
    errors?: CalculationError[];
}
interface CalculationError extends CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
    /** Error details */
    error?: Details;
}
/** @oneof */
interface CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
}
interface Details extends DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
    /**
     * deprecated in API's - to enable migration from rendering arbitrary tracing to rest response
     * @deprecated
     */
    tracing?: Record<string, string>;
}
/** @oneof */
interface DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/**
 * example result:
 * {
 * "fieldViolations": [
 * {
 * "field": "fieldA",
 * "description": "invalid music note. supported notes: [do,re,mi,fa,sol,la,ti]",
 * "violatedRule": "OTHER",
 * "ruleName": "INVALID_NOTE",
 * "data": {
 * "value": "FI"
 * }
 * },
 * {
 * "field": "fieldB",
 * "description": "field value out of range. supported range: [0-20]",
 * "violatedRule": "MAX",
 * "data": {
 * "threshold": 20
 * }
 * },
 * {
 * "field": "fieldC",
 * "description": "invalid phone number. provide a valid phone number of size: [7-12], supported characters: [0-9, +, -, (, )]",
 * "violatedRule": "FORMAT",
 * "data": {
 * "type": "PHONE"
 * }
 * }
 * ]
 * }
 */
interface ValidationError {
    fieldViolations?: FieldViolation[];
}
declare enum RuleType {
    VALIDATION = "VALIDATION",
    OTHER = "OTHER",
    MAX = "MAX",
    MIN = "MIN",
    MAX_LENGTH = "MAX_LENGTH",
    MIN_LENGTH = "MIN_LENGTH",
    MAX_SIZE = "MAX_SIZE",
    MIN_SIZE = "MIN_SIZE",
    FORMAT = "FORMAT",
    DECIMAL_LTE = "DECIMAL_LTE",
    DECIMAL_GTE = "DECIMAL_GTE",
    DECIMAL_LT = "DECIMAL_LT",
    DECIMAL_GT = "DECIMAL_GT",
    DECIMAL_MAX_SCALE = "DECIMAL_MAX_SCALE",
    INVALID_ENUM_VALUE = "INVALID_ENUM_VALUE",
    REQUIRED_FIELD = "REQUIRED_FIELD",
    FIELD_NOT_ALLOWED = "FIELD_NOT_ALLOWED",
    ONE_OF_ALIGNMENT = "ONE_OF_ALIGNMENT",
    EXACT_LENGTH = "EXACT_LENGTH",
    EXACT_SIZE = "EXACT_SIZE",
    REQUIRED_ONE_OF_FIELD = "REQUIRED_ONE_OF_FIELD"
}
/** @enumType */
type RuleTypeWithLiterals = RuleType | 'VALIDATION' | 'OTHER' | 'MAX' | 'MIN' | 'MAX_LENGTH' | 'MIN_LENGTH' | 'MAX_SIZE' | 'MIN_SIZE' | 'FORMAT' | 'DECIMAL_LTE' | 'DECIMAL_GTE' | 'DECIMAL_LT' | 'DECIMAL_GT' | 'DECIMAL_MAX_SCALE' | 'INVALID_ENUM_VALUE' | 'REQUIRED_FIELD' | 'FIELD_NOT_ALLOWED' | 'ONE_OF_ALIGNMENT' | 'EXACT_LENGTH' | 'EXACT_SIZE' | 'REQUIRED_ONE_OF_FIELD';
interface FieldViolation {
    field?: string;
    description?: string;
    violatedRule?: RuleTypeWithLiterals;
    /** applicable when violated_rule=OTHER */
    ruleName?: string | null;
    data?: Record<string, any> | null;
}
interface SystemError {
    /** Error code. */
    errorCode?: string | null;
}
interface RefundPaymentsRequest {
    /**
     * Order ID to process refunds for.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment refunds specifying which payments to refund and their amounts.
     * Set `externalRefund` to `true` for manual refunds processed outside the system.
     * @minSize 1
     * @maxSize 50
     */
    paymentRefunds: PaymentRefund[];
    /** Additional actions to perform alongside the refund, such as restocking inventory or sending notifications. */
    sideEffects?: RefundSideEffects;
    /** Specific items being refunded including line items, shipping, and additional fees. */
    refundItems?: RefundItems;
    /**
     * Optional customer-provided reason for the refund for record-keeping purposes.
     * @maxLength 200
     */
    customerReason?: string | null;
}
interface PaymentRefund {
    /**
     * ID of the payment to refund from the order's payment transactions.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Amount to refund from this payment.
     * Not applicable for membership payments and gift card refunds where the full credit is refunded.
     */
    amount?: Price;
    /**
     * Whether this refund is processed externally through the payment provider's dashboard.
     *
     * + **Automatic refund** (`false`, default): Calls the payment provider's API to process the refund.
     * The system handles the refund transaction and updates the payment status automatically.
     *
     * + **External refund** (`true`): Marks the payment as refunded without calling the provider's API.
     * Use this when you've manually processed the refund and only need to update the order records.
     */
    externalRefund?: boolean;
}
interface ExternalRefundInfo {
    /**
     * Status of the external refund transaction affecting how the system handles the refund.
     *
     * + **SUCCEEDED**: Refund has been completed externally. The payment is immediately marked as refunded.
     * + **PENDING**: Refund is in progress externally. The system waits for provider notification or manual status update.
     * While pending, additional refunds for this payment are blocked.
     */
    refundStatus?: ExternalRefundStatusWithLiterals;
}
declare enum ExternalRefundStatus {
    /**
     * External refund has been successfully completed by the payment provider.
     * The payment will be immediately marked as refunded in the system.
     */
    SUCCEEDED = "SUCCEEDED",
    /**
     * External refund has been initiated or is in progress at the payment provider.
     * The system will wait for confirmation before marking the payment as refunded.
     */
    PENDING = "PENDING"
}
/** @enumType */
type ExternalRefundStatusWithLiterals = ExternalRefundStatus | 'SUCCEEDED' | 'PENDING';
interface RefundSideEffects {
    /** Inventory restocking actions to perform alongside the refund. */
    restock?: RestockSideEffects;
    /** Customer notification actions for the refund. */
    notifications?: NotificationSideEffects;
}
interface RestockItem {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity to add back to inventory.
     * Cannot exceed the quantity being refunded for this line item.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface RestockSideEffects {
    /**
     * Items to add back to inventory when processing the refund.
     * Use this to automatically restock returned items.
     * @maxSize 300
     */
    lineItems?: RestockItem[];
}
interface NotificationSideEffects {
    /**
     * Whether to send a refund confirmation email to the customer.
     * The email includes refund details and any custom message provided.
     *
     * Default: `false`
     */
    sendCustomerEmail?: boolean;
    /**
     * Custom message to include in the refund confirmation email sent to the customer.
     * Use this to provide additional context about the refund, return instructions, or customer service information.
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
interface RefundPaymentsResponse {
    /** Complete refund information including refund ID, status, and amounts processed. */
    refund?: Refund;
    /** Updated order transaction history reflecting all payments and refunds after processing. */
    orderTransactions?: OrderTransactions;
}
interface Refund {
    /**
     * Refund ID.
     * @format GUID
     * @readonly
     */
    id?: string;
    /**
     * List of transactions.
     * @maxSize 50
     */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    createdDate?: Date | null;
    /**
     * Aggregated refund summary.
     * @readonly
     */
    summary?: V1AggregatedRefundSummary;
    /**
     * ID of the app that initiated this refund.
     * @format GUID
     * @readonly
     * @immutable
     */
    requestingServiceAppId?: string | null;
}
interface RefundTransaction {
    /**
     * ID of the payment associated with this refund.
     * @format GUID
     * @immutable
     */
    paymentId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatusWithLiterals;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID.
     * This field is only returned when the value of `external_refund` is `false`.
     * @format GUID
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /**
     * Whether refund was made externally and manually on the payment provider's side.
     * @immutable
     */
    externalRefund?: boolean;
}
/** Refund transaction status. */
declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
/** @enumType */
type RefundStatusWithLiterals = RefundStatus | 'PENDING' | 'SUCCEEDED' | 'FAILED' | 'SCHEDULED' | 'STARTED';
interface RefundStatusInfo {
    /**
     * Reason code for the refund's current status.
     *
     * Learn more about [reason codes](https://dev.wix.com/docs/rest/business-management/payments/service-plugins/payment-service-provider-service-plugin/reason-codes).
     * @minLength 1
     * @maxLength 10
     */
    paymentGatewayReasonCode?: string | null;
    /**
     * Free text explanation of current refund status.
     * @minLength 1
     * @maxLength 1000
     */
    description?: string | null;
}
/** Business model of a refund request */
interface RefundDetails {
    /**
     * Order line item IDs and quantities that were refunded.
     * @maxSize 300
     */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /**
     * Reason for the refund, provided by customer (optional).
     * @maxLength 200
     */
    reason?: string | null;
    /**
     * Line items that were refunded.
     * @maxSize 300
     */
    lineItems?: V1LineItemRefund[];
    /**
     * Additional fees that were refunded.
     * @maxSize 100
     */
    additionalFees?: V1AdditionalFeeRefund[];
    /** Shipping amount that was refunded. */
    shipping?: V1ShippingRefund;
}
interface RefundItem {
    /**
     * Line item ID the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity refunded.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface V1LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     * @immutable
     */
    lineItemId?: string;
    /**
     * Refund quantity.
     * @min 1
     * @max 100000
     * @immutable
     */
    quantity?: number;
}
interface V1AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     * @immutable
     */
    additionalFeeId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface V1ShippingRefund {
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface V1AggregatedRefundSummary {
    /** Total amount requested for refund. */
    requestedRefund?: Price;
    /** Pending refund amount - the portion of `requestedRefund` that is still pending. */
    pendingRefund?: Price;
    /** Refunded amount - the portion of `requestedRefund` that refunded successfully. */
    refunded?: Price;
    /** Failed refund amount - the portion of `requestedRefund` that failed. */
    failedRefundAmount?: Price;
    /** Whether at least one refund transaction is still in `"PENDING"` status. */
    pending?: boolean;
    /** Breakdown of refunded items. Available only after refund is complete. */
    breakdown?: RefundItemsBreakdown;
}
interface RefundItemsBreakdown {
    /**
     * Refunded line items and the amount refunded for each.
     * @maxSize 300
     */
    lineItems?: LineItemRefundSummary[];
}
interface LineItemRefundSummary {
    /**
     * ID of the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /** Total refunded amount for the line item. */
    totalRefundedAmount?: Price;
}
interface OrderTransactions {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Record of payments made to the merchant.
     * @maxSize 100
     */
    payments?: Payment[];
    /**
     * Record of refunds made to the buyer.
     * @maxSize 300
     */
    refunds?: Refund[];
}
interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Payment ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
}
/** @oneof */
interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
interface PaymentReceiptInfoOneOf {
}
interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Wix Payments order ID.
     * @maxLength 100
     */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID.
     * This field is only returned when the value of `offline_payment` is `false`.
     * @maxLength 100
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 100
     */
    paymentMethod?: string | null;
    /**
     * Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments.
     * @maxLength 100
     */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
    /**
     * Whether there is a payment agreement that allows for future charges.
     * @immutable
     */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
    /**
     * Record of chargebacks made by the buyer.
     * @maxSize 6
     */
    chargebacks?: Chargeback[];
}
/** @oneof */
interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
/** @enumType */
type TransactionStatusWithLiterals = TransactionStatus | 'UNDEFINED' | 'APPROVED' | 'PENDING' | 'PENDING_MERCHANT' | 'CANCELED' | 'DECLINED' | 'REFUNDED' | 'PARTIALLY_REFUNDED' | 'AUTHORIZED' | 'VOIDED';
interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     * @maxSize 1
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: V1ScheduledAction;
}
interface AuthorizationCapture {
    /**
     * Capture ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatusWithLiterals;
    /**
     * Amount of this capture
     * @immutable
     */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationCaptureStatusWithLiterals = AuthorizationCaptureStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
interface AuthorizationActionFailureDetails {
    /** @maxLength 100 */
    failureCode?: string;
}
interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatusWithLiterals;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: ReasonWithLiterals;
}
declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationVoidStatusWithLiterals = AuthorizationVoidStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
/** Reason the authorization was voided. */
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'MANUAL' | 'SCHEDULED';
interface V1ScheduledAction {
    /** Type of the action. */
    actionType?: ActionTypeWithLiterals;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ActionTypeWithLiterals = ActionType | 'UNKNOWN_ACTION_TYPE' | 'VOID' | 'CAPTURE';
interface Chargeback {
    /**
     * Chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    id?: string;
    /**
     * Date and time the chargeback was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    createdDate?: Date | null;
    /**
     * Date and time the chargeback was updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Amount.
     * @readonly
     * @immutable
     */
    amount?: Price;
    /**
     * Reversal amount. Present only when status is REVERSED.
     * @readonly
     */
    reversalAmount?: Price;
    /**
     * Status.
     *
     * Default: `"APPROVED"`.
     */
    status?: ChargebackStatusWithLiterals;
    /**
     * External chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    externalId?: string | null;
}
declare enum ChargebackStatus {
    UNSPECIFIED = "UNSPECIFIED",
    /** Chargeback was approved. */
    APPROVED = "APPROVED",
    /** Chargeback was reversed. */
    REVERSED = "REVERSED"
}
/** @enumType */
type ChargebackStatusWithLiterals = ChargebackStatus | 'UNSPECIFIED' | 'APPROVED' | 'REVERSED';
interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @minLength 1
     * @maxLength 100
     */
    giftCardPaymentId?: string;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
}
interface MembershipPaymentDetails {
    /**
     * Membership ID.
     * @minLength 1
     * @maxLength 100
     */
    membershipId?: string;
    /**
     * ID of the line item this membership applies to.
     * @minLength 1
     * @maxLength 100
     */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatusWithLiterals;
    /** Membership name. */
    name?: MembershipName;
    /**
     * The transaction ID in the membership system. Can be used to void the transaction.
     * @minLength 1
     * @maxLength 100
     */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /**
     * ID of the application providing this payment option.
     * @format GUID
     */
    providerAppId?: string;
}
declare enum MembershipPaymentStatus {
    /** Payment was charged. */
    CHARGED = "CHARGED",
    /** The attempt to charge the payment failed, for example, due to lack of credits. */
    CHARGE_FAILED = "CHARGE_FAILED"
}
/** @enumType */
type MembershipPaymentStatusWithLiterals = MembershipPaymentStatus | 'CHARGED' | 'CHARGE_FAILED';
interface MembershipName {
    /**
     * Membership name.
     * @maxLength 100
     */
    original?: string;
    /**
     * Translated membership name. Defaults to `original` when not provided.
     * @maxLength 100
     */
    translated?: string | null;
}
interface WixReceiptInfo {
    /**
     * Receipt ID
     * @format GUID
     */
    receiptId?: string;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface ExternalReceiptInfo {
    /**
     * External receipt ID
     * @maxLength 100
     */
    receiptId?: string | null;
    /**
     * ID of the app providing the receipt
     * @format GUID
     */
    appId?: string | null;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface PaymentNotRefundableDetails {
    /**
     * Payment ID that cannot be refunded.
     * @format GUID
     */
    paymentId?: string;
    /** Specific reason why this payment cannot be refunded, such as already being fully refunded or provider restrictions. */
    nonRefundableReason?: NonRefundableReasonWithLiterals;
}
interface AuthorizeChargeWithSavedPaymentMethodRequest {
    /**
     * Order ID.
     *
     * The order must have a saved payment method associated with it.
     * Verify a saved payment method exists by calling List Transactions For Single Order and checking for `regularPaymentDetails.savedPaymentMethod: true`
     * in the order's payment details before calling this method.
     * @format GUID
     */
    orderId: string;
    /**
     * Amount to authorize on the customer's saved payment method.
     * This creates a hold for this amount but doesn't charge the customer until captured.
     */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
    /**
     * Automatic action settings for the authorization.
     * Configure whether to automatically capture or void the authorization after a delay.
     */
    delayedCaptureSettings: DelayedCaptureSettings;
}
interface DelayedCaptureSettings {
    /** Automatic action to perform on the authorization after the specified delay period. */
    scheduledAction?: ScheduledActionWithLiterals;
    /**
     * Time to wait before performing the scheduled action.
     *
     * If not specified, the payment provider's default period will be used.
     */
    delayDuration?: Duration;
}
declare enum ScheduledAction {
    /** Unspecified action - not implemented. */
    UNSPECIFIED = "UNSPECIFIED",
    /**
     * Automatically **void** the authorization after the delay period.
     *
     * Use this when you want to automatically release the hold if payment isn't captured.
     */
    VOID = "VOID",
    /**
     * Automatically **capture** (charge) the authorization after the delay period.
     *
     * Use this for delayed billing or when you want to ensure payment is collected after fulfillment.
     */
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ScheduledActionWithLiterals = ScheduledAction | 'UNSPECIFIED' | 'VOID' | 'CAPTURE';
interface Duration {
    /**
     * Amount of units. For example, 30 MINUTES, 1 HOURS, 7 DAYS, etc
     * @min 1
     */
    count?: number;
    /** Duration unit: MINUTES, HOURS and DAYS */
    unit?: DurationUnitWithLiterals;
}
declare enum DurationUnit {
    UNKNOWN_DURATION_UNIT = "UNKNOWN_DURATION_UNIT",
    MINUTES = "MINUTES",
    HOURS = "HOURS",
    DAYS = "DAYS"
}
/** @enumType */
type DurationUnitWithLiterals = DurationUnit | 'UNKNOWN_DURATION_UNIT' | 'MINUTES' | 'HOURS' | 'DAYS';
interface AuthorizeChargeWithSavedPaymentMethodResponse {
    /** Created payment authorization with `AUTHORIZED` status. */
    payment?: Payment;
    /** Updated order transaction history including the new authorization. */
    orderTransactions?: OrderTransactions;
}
interface VoidAuthorizedPaymentsRequest {
    /**
     * ID of the order containing the payments to void.
     * @format GUID
     */
    orderId: string;
    /**
     * IDs of authorized payments to void (cancel).
     *
     * Only payments with `AUTHORIZED` status can be voided.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    paymentIds: string[];
}
interface VoidAuthorizedPaymentsResponse {
    /** Updated order transaction history with voided payments marked as cancelled. */
    orderTransactions?: OrderTransactions;
}
interface CaptureAuthorizedPaymentsRequest {
    /**
     * ID of the order containing the payments to capture.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment authorizations to capture with their respective amounts.
     *
     * If no amount is specified, the full authorized amount will be captured.
     * @minSize 1
     * @maxSize 100
     */
    payments: PaymentCapture[];
}
interface PaymentCapture {
    /**
     * ID of the payment to capture.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Capture amount.
     *
     * > **Note:** If not provided, the full authorized amount will be captured.
     */
    amount?: Price;
}
interface CaptureAuthorizedPaymentsResponse {
    /** Updated order transaction history with captured payments marked as paid. */
    orderTransactions?: OrderTransactions;
}
interface GenerateReceiptsRequest {
    /**
     * ID of the order containing the payments to generate receipts for.
     * @format GUID
     */
    orderId: string;
    /**
     * IDs of the payments to generate receipts for.
     *
     * Only successful payments with valid payment types can have receipts generated.
     * @minSize 1
     * @maxSize 1
     * @format GUID
     */
    paymentIds: string[];
}
interface GenerateReceiptsResponse {
    /** Information about the generated receipts including receipt IDs for each payment. */
    receipts?: ReceiptInfo[];
}
interface ReceiptInfo {
    /**
     * ID of the payment that the receipt was generated for.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Generated receipt ID that can be used to retrieve the receipt details.
     * @format GUID
     */
    receiptId?: string;
}
interface RedeemGiftCardRequest {
    /**
     * Order ID to apply the gift card payment to.
     * @format GUID
     */
    orderId: string;
    /**
     * Gift card redemption code.
     *
     * The gift card must be active, not expired, and have sufficient balance.
     * @minLength 8
     * @maxLength 20
     */
    giftCardCode: string;
    /**
     * Amount to redeem from the gift card balance.
     *
     * Cannot exceed the gift card's available balance or the order's outstanding amount.
     */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
}
interface RedeemGiftCardResponse {
    /** Updated order transaction history including the gift card payment. */
    orderTransactions?: OrderTransactions;
    /** Created gift card payment transaction with the redeemed amount. */
    payment?: Payment;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface Empty {
}
/** @docsIgnore */
type RefundPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'LINE_ITEM_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ADDITIONAL_FEE_NOT_FOUND';
    description?: string;
    data?: AdditionalFeeRefund;
} | {
    code?: 'SHIPPING_NOT_FOUND';
    description?: string;
    data?: ShippingRefund;
} | {
    code?: 'INVALID_PAYMENT_REFUND_AMOUNT';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'INVALID_ADDITIONAL_FEE_REFUND_AMOUNT';
    description?: string;
    data?: AdditionalFeeRefund;
} | {
    code?: 'INVALID_SHIPPING_REFUND_AMOUNT';
    description?: string;
    data?: ShippingRefund;
} | {
    code?: 'INVALID_LINE_ITEM_REFUND_QUANTITY';
    description?: string;
    data?: LineItemRefund;
} | {
    code?: 'INVALID_LINE_ITEM_RESTOCK_QUANTITY';
    description?: string;
    data?: RestockItem;
} | {
    code?: 'PAYMENT_NOT_REFUNDABLE';
    description?: string;
    data?: PaymentNotRefundableDetails;
} | {
    code?: 'EXTERNAL_REFUND_EXPECTED';
    description?: string;
    data?: PaymentRefund;
} | {
    code?: 'PARTIAL_REFUND_FOR_MULTIPLE_LOCATIONS_NOT_ALLOWED';
    description?: string;
    data?: RestockItem;
};
/** @docsIgnore */
type AuthorizeChargeWithSavedPaymentMethodApplicationErrors = {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_CANCELED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_PAID';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'NO_SAVED_PAYMENT_METHOD';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_HAS_CHARGEBACKS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_AMOUNT';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_CURRENCY';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type VoidAuthorizedPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GATEWAY_TRANSACTION_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_ALREADY_VOIDED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_ALREADY_CAPTURED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_NOT_AUTHORIZED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CaptureAuthorizedPaymentsApplicationErrors = {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'INVALID_AMOUNT';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_ALREADY_VOIDED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_ALREADY_CAPTURED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_NOT_AUTHORIZED';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'PAYMENT_HAS_PENDING_CAPTURE';
    description?: string;
    data?: PaymentCapture;
} | {
    code?: 'ORDER_HAS_CHARGEBACKS';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type GenerateReceiptsApplicationErrors = {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'RECEIPT_ALREADY_EXIST';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'RECEIPT_GENERATION_IN_PROGRESS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_PAYMENT_TYPE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_PAYMENT_STATUS';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type RedeemGiftCardApplicationErrors = {
    code?: 'GIFT_CARD_ALREADY_APPLIED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CURRENCY_MISMATCH';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_EXPIRED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'GIFT_CARD_DISABLED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INSUFFICIENT_FUNDS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CURRENCY_NOT_SUPPORTED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ALREADY_REDEEMED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_CANCELED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_PAID';
    description?: string;
    data?: Record<string, any>;
};

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function getOrderRefundability(): __PublicMethodMetaInfo<'POST', {}, GetOrderRefundabilityRequest$1, GetOrderRefundabilityRequest, GetOrderRefundabilityResponse$1, GetOrderRefundabilityResponse>;
declare function calculateRefund(): __PublicMethodMetaInfo<'POST', {}, CalculateRefundRequest$1, CalculateRefundRequest, CalculateRefundResponse$1, CalculateRefundResponse>;
declare function refundPayments(): __PublicMethodMetaInfo<'POST', {}, RefundPaymentsRequest$1, RefundPaymentsRequest, RefundPaymentsResponse$1, RefundPaymentsResponse>;
declare function authorizeChargeWithSavedPaymentMethod(): __PublicMethodMetaInfo<'POST', {}, AuthorizeChargeWithSavedPaymentMethodRequest$1, AuthorizeChargeWithSavedPaymentMethodRequest, AuthorizeChargeWithSavedPaymentMethodResponse$1, AuthorizeChargeWithSavedPaymentMethodResponse>;
declare function voidAuthorizedPayments(): __PublicMethodMetaInfo<'POST', {}, VoidAuthorizedPaymentsRequest$1, VoidAuthorizedPaymentsRequest, VoidAuthorizedPaymentsResponse$1, VoidAuthorizedPaymentsResponse>;
declare function captureAuthorizedPayments(): __PublicMethodMetaInfo<'POST', {}, CaptureAuthorizedPaymentsRequest$1, CaptureAuthorizedPaymentsRequest, CaptureAuthorizedPaymentsResponse$1, CaptureAuthorizedPaymentsResponse>;
declare function generateReceipts(): __PublicMethodMetaInfo<'POST', {}, GenerateReceiptsRequest$1, GenerateReceiptsRequest, GenerateReceiptsResponse$1, GenerateReceiptsResponse>;
declare function redeemGiftCard(): __PublicMethodMetaInfo<'POST', {}, RedeemGiftCardRequest$1, RedeemGiftCardRequest, RedeemGiftCardResponse$1, RedeemGiftCardResponse>;

export { type ActionEvent as ActionEventOriginal, ActionType as ActionTypeOriginal, type ActionTypeWithLiterals as ActionTypeWithLiteralsOriginal, type AdditionalFeeRefund as AdditionalFeeRefundOriginal, type AdditionalFeeRefundability as AdditionalFeeRefundabilityOriginal, type AggregatedRefundSummary as AggregatedRefundSummaryOriginal, type ApplicationError as ApplicationErrorOriginal, type AuthorizationActionFailureDetails as AuthorizationActionFailureDetailsOriginal, type AuthorizationCapture as AuthorizationCaptureOriginal, AuthorizationCaptureStatus as AuthorizationCaptureStatusOriginal, type AuthorizationCaptureStatusWithLiterals as AuthorizationCaptureStatusWithLiteralsOriginal, type AuthorizationDetails as AuthorizationDetailsOriginal, type AuthorizationVoid as AuthorizationVoidOriginal, AuthorizationVoidStatus as AuthorizationVoidStatusOriginal, type AuthorizationVoidStatusWithLiterals as AuthorizationVoidStatusWithLiteralsOriginal, type AuthorizeChargeWithSavedPaymentMethodApplicationErrors as AuthorizeChargeWithSavedPaymentMethodApplicationErrorsOriginal, type AuthorizeChargeWithSavedPaymentMethodRequest as AuthorizeChargeWithSavedPaymentMethodRequestOriginal, type AuthorizeChargeWithSavedPaymentMethodResponse as AuthorizeChargeWithSavedPaymentMethodResponseOriginal, type CalculateRefundRequest as CalculateRefundRequestOriginal, type CalculateRefundResponse as CalculateRefundResponseOriginal, type CalculateRefundResponseStatusOneOf as CalculateRefundResponseStatusOneOfOriginal, type CalculatedAdditionalFeeRefund as CalculatedAdditionalFeeRefundOriginal, type CalculatedLineItemRefund as CalculatedLineItemRefundOriginal, type CalculatedRefundItems as CalculatedRefundItemsOriginal, type CalculatedRefundNotAvailableStatus as CalculatedRefundNotAvailableStatusOriginal, type CalculatedRefundSummary as CalculatedRefundSummaryOriginal, type CalculatedShippingRefund as CalculatedShippingRefundOriginal, type CalculationErrorItemOneOf as CalculationErrorItemOneOfOriginal, type CalculationError as CalculationErrorOriginal, type CaptureAuthorizedPaymentsApplicationErrors as CaptureAuthorizedPaymentsApplicationErrorsOriginal, type CaptureAuthorizedPaymentsRequest as CaptureAuthorizedPaymentsRequestOriginal, type CaptureAuthorizedPaymentsResponse as CaptureAuthorizedPaymentsResponseOriginal, type Chargeback as ChargebackOriginal, ChargebackStatus as ChargebackStatusOriginal, type ChargebackStatusWithLiterals as ChargebackStatusWithLiteralsOriginal, type CreditCardPaymentMethodDetails as CreditCardPaymentMethodDetailsOriginal, type DelayedCaptureSettings as DelayedCaptureSettingsOriginal, type DetailsKindOneOf as DetailsKindOneOfOriginal, type Details as DetailsOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type Duration as DurationOriginal, DurationUnit as DurationUnitOriginal, type DurationUnitWithLiterals as DurationUnitWithLiteralsOriginal, type Empty as EmptyOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, type ExternalReceiptInfo as ExternalReceiptInfoOriginal, type ExternalRefundInfo as ExternalRefundInfoOriginal, ExternalRefundStatus as ExternalRefundStatusOriginal, type ExternalRefundStatusWithLiterals as ExternalRefundStatusWithLiteralsOriginal, type FieldViolation as FieldViolationOriginal, type GenerateReceiptsApplicationErrors as GenerateReceiptsApplicationErrorsOriginal, type GenerateReceiptsRequest as GenerateReceiptsRequestOriginal, type GenerateReceiptsResponse as GenerateReceiptsResponseOriginal, type GetOrderRefundabilityRequest as GetOrderRefundabilityRequestOriginal, type GetOrderRefundabilityResponse as GetOrderRefundabilityResponseOriginal, type GiftCardPaymentDetails as GiftCardPaymentDetailsOriginal, type LineItemRefund as LineItemRefundOriginal, type LineItemRefundSummary as LineItemRefundSummaryOriginal, type LineItemRefundability as LineItemRefundabilityOriginal, type ManuallyRefundablePaymentStatus as ManuallyRefundablePaymentStatusOriginal, ManuallyRefundableReason as ManuallyRefundableReasonOriginal, type ManuallyRefundableReasonWithLiterals as ManuallyRefundableReasonWithLiteralsOriginal, type MembershipName as MembershipNameOriginal, type MembershipPaymentDetails as MembershipPaymentDetailsOriginal, MembershipPaymentStatus as MembershipPaymentStatusOriginal, type MembershipPaymentStatusWithLiterals as MembershipPaymentStatusWithLiteralsOriginal, type MembershipPaymentSummary as MembershipPaymentSummaryOriginal, type MonetaryPaymentSummary as MonetaryPaymentSummaryOriginal, type NonRefundablePaymentStatus as NonRefundablePaymentStatusOriginal, NonRefundableReason as NonRefundableReasonOriginal, type NonRefundableReasonWithLiterals as NonRefundableReasonWithLiteralsOriginal, type NotificationSideEffects as NotificationSideEffectsOriginal, type OrderBilling as OrderBillingOriginal, type OrderTransactions as OrderTransactionsOriginal, type PaymentCapture as PaymentCaptureOriginal, type PaymentInfo as PaymentInfoOriginal, type PaymentInfoPaymentMethodDetailsOneOf as PaymentInfoPaymentMethodDetailsOneOfOriginal, type PaymentInfoSummaryOneOf as PaymentInfoSummaryOneOfOriginal, type PaymentNotRefundableDetails as PaymentNotRefundableDetailsOriginal, type Payment as PaymentOriginal, type PaymentPaymentDetailsOneOf as PaymentPaymentDetailsOneOfOriginal, type PaymentReceiptInfoOneOf as PaymentReceiptInfoOneOfOriginal, type PaymentRefund as PaymentRefundOriginal, type PaymentRefundability as PaymentRefundabilityOriginal, type PaymentRefundabilityStatusOneOf as PaymentRefundabilityStatusOneOfOriginal, type PaymentsSummary as PaymentsSummaryOriginal, type Price as PriceOriginal, Reason as ReasonOriginal, type ReasonWithLiterals as ReasonWithLiteralsOriginal, type ReceiptInfo as ReceiptInfoOriginal, type RedeemGiftCardApplicationErrors as RedeemGiftCardApplicationErrorsOriginal, type RedeemGiftCardRequest as RedeemGiftCardRequestOriginal, type RedeemGiftCardResponse as RedeemGiftCardResponseOriginal, type RefundDetails as RefundDetailsOriginal, type RefundItem as RefundItemOriginal, type RefundItemsBreakdown as RefundItemsBreakdownOriginal, type RefundItems as RefundItemsOriginal, type Refund as RefundOriginal, type RefundPaymentsApplicationErrors as RefundPaymentsApplicationErrorsOriginal, type RefundPaymentsRequest as RefundPaymentsRequestOriginal, type RefundPaymentsResponse as RefundPaymentsResponseOriginal, type RefundSideEffects as RefundSideEffectsOriginal, type RefundStatusInfo as RefundStatusInfoOriginal, RefundStatus as RefundStatusOriginal, type RefundStatusWithLiterals as RefundStatusWithLiteralsOriginal, type RefundTransaction as RefundTransactionOriginal, type RegularPaymentDetails as RegularPaymentDetailsOriginal, type RegularPaymentDetailsPaymentMethodDetailsOneOf as RegularPaymentDetailsPaymentMethodDetailsOneOfOriginal, type RestockItem as RestockItemOriginal, type RestockSideEffects as RestockSideEffectsOriginal, type RestoreInfo as RestoreInfoOriginal, RuleType as RuleTypeOriginal, type RuleTypeWithLiterals as RuleTypeWithLiteralsOriginal, ScheduledAction as ScheduledActionOriginal, type ScheduledActionWithLiterals as ScheduledActionWithLiteralsOriginal, type ShippingRefund as ShippingRefundOriginal, type ShippingRefundability as ShippingRefundabilityOriginal, type SystemError as SystemErrorOriginal, TransactionStatus as TransactionStatusOriginal, type TransactionStatusWithLiterals as TransactionStatusWithLiteralsOriginal, type V1AdditionalFeeRefund as V1AdditionalFeeRefundOriginal, type V1AggregatedRefundSummary as V1AggregatedRefundSummaryOriginal, type V1LineItemRefund as V1LineItemRefundOriginal, type V1ScheduledAction as V1ScheduledActionOriginal, type V1ShippingRefund as V1ShippingRefundOriginal, type ValidationError as ValidationErrorOriginal, type VoidAuthorizedPaymentsApplicationErrors as VoidAuthorizedPaymentsApplicationErrorsOriginal, type VoidAuthorizedPaymentsRequest as VoidAuthorizedPaymentsRequestOriginal, type VoidAuthorizedPaymentsResponse as VoidAuthorizedPaymentsResponseOriginal, type WixReceiptInfo as WixReceiptInfoOriginal, type __PublicMethodMetaInfo, authorizeChargeWithSavedPaymentMethod, calculateRefund, captureAuthorizedPayments, generateReceipts, getOrderRefundability, redeemGiftCard, refundPayments, voidAuthorizedPayments };
