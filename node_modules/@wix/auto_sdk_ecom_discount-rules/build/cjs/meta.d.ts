import { CreateDiscountRuleRequest as CreateDiscountRuleRequest$1, CreateDiscountRuleResponse as CreateDiscountRuleResponse$1, GetDiscountRuleRequest as GetDiscountRuleRequest$1, GetDiscountRuleResponse as GetDiscountRuleResponse$1, UpdateDiscountRuleRequest as UpdateDiscountRuleRequest$1, UpdateDiscountRuleResponse as UpdateDiscountRuleResponse$1, DeleteDiscountRuleRequest as DeleteDiscountRuleRequest$1, DeleteDiscountRuleResponse as DeleteDiscountRuleResponse$1, QueryDiscountRulesRequest as QueryDiscountRulesRequest$1, QueryDiscountRulesResponse as QueryDiscountRulesResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

interface DiscountRule {
    /**
     * Discount rule ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the discount rule is updated.
     * To prevent conflicting changes, the current `revision` must be passed when updating the discount rule.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the discount rule was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the discount rule was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Whether the discount rule is active.
     *
     * Default: `true`
     */
    active?: boolean | null;
    /**
     * Discount rule name.
     * @minLength 1
     * @maxLength 50
     */
    name?: string | null;
    /**
     * Discount rule trigger.
     * A set of conditions that must be met for the `discounts` to be applied.
     * Not passing a trigger will cause the discount to always apply.
     */
    trigger?: DiscountTrigger;
    /** Time frame in which the discount rule is active. */
    activeTimeInfo?: ActiveTimeInfo;
    /**
     * List of discounts that are applied when one or more triggers are met.
     *
     * > **Notes:**
     * >
     * > + Currently, only 1 discount can be defined per discount rule.
     * > + A discount rule can be applied on multiple items per cart.
     * > + A discount rule can only be applied once per item.
     */
    discounts?: Discounts;
    /**
     * Discount rule status.
     * Default: `UNDEFINED`
     * @readonly
     */
    status?: StatusWithLiterals;
    /**
     * Number of times the discount rule was used.
     * @readonly
     */
    usageCount?: number;
}
/** DiscountTrigger - description of a set of conditions, that if met, will trigger the associated rule actions */
interface DiscountTrigger extends DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
    /** Trigger type. */
    triggerType?: TriggerTypeWithLiterals;
}
/** @oneof */
interface DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
}
/**
 * This object represents a scope of catalog items. Examples:
 * 1. All catalog items of a specific app - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id`
 * 2. Specific catalog item - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id` + `catalog_item_ids`
 * 3. External catalog filter - type = CUSTOM_FILTER, CustomFilter with 'app_id' + 'params'
 */
interface Scope extends ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
    /**
     * Scope ID.
     * @minLength 1
     * @maxLength 100
     */
    id?: string;
    /** Scope type. */
    type?: ScopeTypeWithLiterals;
}
/** @oneof */
interface ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
}
declare enum ScopeType {
    UNDEFINED_SCOPE = "UNDEFINED_SCOPE",
    /** Specific catalog items */
    CATALOG_ITEM = "CATALOG_ITEM",
    /** Specific items by custom filters */
    CUSTOM_FILTER = "CUSTOM_FILTER"
}
/** @enumType */
type ScopeTypeWithLiterals = ScopeType | 'UNDEFINED_SCOPE' | 'CATALOG_ITEM' | 'CUSTOM_FILTER';
interface CatalogItemFilter {
    /**
     * Catalog App ID. For example, the Wix Stores, Wix Bookings, or 3rd-party `appId`.
     * @format GUID
     */
    catalogAppId?: string;
    /**
     * ID of the item within its Wix or 3rd-party catalog. For example, `productId` for Wix Stores.
     * @minLength 1
     * @maxLength 36
     * @maxSize 50
     */
    catalogItemIds?: string[];
}
interface CustomFilter {
    /**
     * Custom filter app ID, when relevant.
     * @format GUID
     */
    appId?: string;
    /**
     * Custom filter in `{ "key": "value" }` form.
     * For example, an array of `collectionIDs`:
     * `{ ["collectionId": "12345"], ["collectionId": "67890"] }`.
     */
    params?: Record<string, any> | null;
}
interface And {
    /**
     * List of triggers to have an "AND" operator between their results.
     * @minSize 2
     * @maxSize 5
     */
    triggers?: DiscountTrigger[];
}
interface Or {
    /**
     * List of triggers to have an "OR" operator between their results.
     * @minSize 2
     * @maxSize 5
     */
    triggers?: DiscountTrigger[];
}
interface Custom {
    /**
     * Trigger ID.
     * @minLength 1
     * @maxLength 100
     */
    id?: string;
    /**
     * ID of the app that created the trigger.
     * @format GUID
     */
    appId?: string;
}
interface SubtotalRange {
    /**
     * Relevant scopes for `SPECIFIC_ITEMS` target type.
     * @maxSize 50
     */
    scopes?: Scope[];
    /**
     * Minimum subtotal price (inclusive).
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    from?: string | null;
    /**
     * Maximum subtotal price (inclusive).
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    to?: string | null;
}
interface ItemQuantityRange {
    /**
     * Relevant scopes for `SPECIFIC_ITEMS` target type.
     * @maxSize 50
     */
    scopes?: Scope[];
    /**
     * Minimum item quantity (inclusive).
     * @min 1
     */
    from?: number | null;
    /**
     * Maximum item quantity (inclusive).
     * @min 1
     */
    to?: number | null;
}
interface CustomerEligibility extends CustomerEligibilityOptionsOneOf {
    /** Information about specific members. */
    individualMembersInfo?: IndividualMembers;
}
/** @oneof */
interface CustomerEligibilityOptionsOneOf {
    /** Information about specific members. */
    individualMembersInfo?: IndividualMembers;
}
declare enum EligibilityType {
    /** Eligibility type is not defined. */
    UNKNOWN_ELIGIBILITY_TYPE = "UNKNOWN_ELIGIBILITY_TYPE",
    /** Only specific customers based on member id. */
    INDIVIDUAL_MEMBERS = "INDIVIDUAL_MEMBERS"
}
/** @enumType */
type EligibilityTypeWithLiterals = EligibilityType | 'UNKNOWN_ELIGIBILITY_TYPE' | 'INDIVIDUAL_MEMBERS';
interface ContactSegments {
    /**
     * Eligible segment ids.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    segmentIds?: string[];
}
interface ContactTags {
    /**
     * Eligible tag and label ids.
     * @minSize 1
     * @maxSize 100
     */
    tagReferences?: TagReference[];
}
interface TagReference {
    /**
     * Eligible tag id.
     * @maxLength 5
     */
    tagId?: string;
    /**
     * Eligible label id.
     * @maxLength 80
     */
    labelKey?: string;
}
interface IndividualMembers {
    /**
     * Eligible member ids.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    memberIds?: string[];
}
declare enum TriggerType {
    UNDEFINED = "UNDEFINED",
    /** Operator used for chaining multiple triggers. Currently 1 `AND` chain operator is supported. */
    AND = "AND",
    /** Subtotal must be within the specified `subtotalRange` values. */
    SUBTOTAL_RANGE = "SUBTOTAL_RANGE",
    /** Quantity of items in scope must be within specified `itemQuantityRange` values. */
    ITEM_QUANTITY_RANGE = "ITEM_QUANTITY_RANGE",
    /** Custom trigger type defined in `customTrigger` object. */
    CUSTOM = "CUSTOM",
    /** Chain multiple triggers with OR operator */
    OR = "OR"
}
/** @enumType */
type TriggerTypeWithLiterals = TriggerType | 'UNDEFINED' | 'AND' | 'SUBTOTAL_RANGE' | 'ITEM_QUANTITY_RANGE' | 'CUSTOM' | 'OR';
interface ActiveTimeInfo {
    /** Date and time the discount rule is active **from**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    start?: Date | null;
    /** Date and time the discount rule is active **till**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    end?: Date | null;
}
interface Recurrence {
    /** Weekly discount recurrence. */
    weeklySchedule?: WeeklySchedule;
}
declare enum DayOfWeek {
    UNKOWN_DAY_OF_WEEK = "UNKOWN_DAY_OF_WEEK",
    /** Monday. */
    MON = "MON",
    /** Tuesday. */
    TUE = "TUE",
    /** Wednesday. */
    WED = "WED",
    /** Thursday. */
    THU = "THU",
    /** Friday. */
    FRI = "FRI",
    /** Saturday. */
    SAT = "SAT",
    /** Sunday. */
    SUN = "SUN"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'UNKOWN_DAY_OF_WEEK' | 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT' | 'SUN';
interface TimeOfDay {
    /**
     * Hours. Min: `0`. Max: `23`.
     * @max 23
     */
    hours?: number;
    /**
     * Minutes. Min: `0`. Max: `59`.
     * @max 59
     */
    minutes?: number;
}
interface TimeWindow {
    /** Day of week. */
    dayOfWeek?: DayOfWeekWithLiterals;
    /** Start time window during each recurrence. */
    startTime?: TimeOfDay;
    /** End time window during each recurrence. */
    endTime?: TimeOfDay;
}
interface WeeklySchedule {
    /**
     * A list of days with their respective active time ranges.
     * @minSize 1
     * @maxSize 100
     */
    timeWindows?: TimeWindow[];
}
interface Discounts {
    /**
     * Discounts.
     * @minSize 1
     * @maxSize 1
     */
    values?: Discount[];
}
interface Discount extends DiscountDiscountOneOf {
    /**
     * Percentage to discount from original price.
     * @min 0.1
     * @max 100
     */
    percentage?: number;
    /**
     * Amount to discount from original price.
     * @decimalValue options { gt:0, lte:1000000000000000, maxScale:4 }
     */
    fixedAmount?: string;
    /**
     * Fixed price. Line item will be fixed to this price.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    fixedPrice?: string;
    /** A special price is applied for a specific quantity of items. For example, 3 for $10. */
    quantityBased?: QuantityBased;
    /**
     * Discount target.
     *
     * + `SPECIFIC_ITEMS`: Discount applies to a specific set of items.
     */
    targetType?: TypeWithLiterals;
    /** Data related to `SPECIFIC_ITEMS` target type. */
    specificItemsInfo?: SpecificItemsInfo;
    /** Discount type. */
    discountType?: DiscountTypeWithLiterals;
}
/** @oneof */
interface DiscountDiscountOneOf {
    /**
     * Percentage to discount from original price.
     * @min 0.1
     * @max 100
     */
    percentage?: number;
    /**
     * Amount to discount from original price.
     * @decimalValue options { gt:0, lte:1000000000000000, maxScale:4 }
     */
    fixedAmount?: string;
    /**
     * Fixed price. Line item will be fixed to this price.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    fixedPrice?: string;
    /** A special price is applied for a specific quantity of items. For example, 3 for $10. */
    quantityBased?: QuantityBased;
}
declare enum Type {
    /** Target type is not defined */
    UNDEFINED = "UNDEFINED",
    /** Target type is a set of specific items */
    SPECIFIC_ITEMS = "SPECIFIC_ITEMS"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNDEFINED' | 'SPECIFIC_ITEMS';
interface SpecificItemsInfo {
    /**
     * All associated scopes for `SPECIFIC_ITEMS` target type.
     * @minSize 1
     * @maxSize 50
     */
    scopes?: Scope[];
}
/** A special price is applied for a specific quantity of items. For example, 3 for $10. */
interface QuantityBased {
    /**
     * list of discountConfig options.
     * @minSize 1
     * @maxSize 1
     */
    configurations?: DiscountConfig[];
}
interface DiscountConfig {
    /**
     * DiscountConfig ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * The number of items that must be added to the cart to be eligible for the discount (Represents X).
     * @min 2
     */
    quantity?: number;
    /**
     * The DiscountConfig price (Represents Amount).
     * @decimalValue options { gte:0, lte:1000000, maxScale:4 }
     */
    price?: string;
}
declare enum DiscountType {
    UNDEFINED = "UNDEFINED",
    /** Price is reduced by percentage value. */
    PERCENTAGE = "PERCENTAGE",
    /** Price is reduced by fixed amount. */
    FIXED_AMOUNT = "FIXED_AMOUNT",
    /** Price will be set to fixed amount. */
    FIXED_PRICE = "FIXED_PRICE",
    /**
     * Quantity based options for Buy X For Amount.
     * @documentationMaturity preview
     */
    QUANTITY_BASED = "QUANTITY_BASED"
}
/** @enumType */
type DiscountTypeWithLiterals = DiscountType | 'UNDEFINED' | 'PERCENTAGE' | 'FIXED_AMOUNT' | 'FIXED_PRICE' | 'QUANTITY_BASED';
interface BuyXGetYInfo {
    /** Information about which items must be in the cart (buy X) for the discount to apply (get Y). */
    customerBuys?: CustomerBuy;
    /** Information about which items will be discounted (get Y). */
    customerGets?: CustomerGet;
    /**
     * The maximum number of times the 'buy X get Y' discount can be applied.
     * For example, when the value of `limit` is `2`, with a "2+1" sale on all items, the following logic applies:
     * + Buy 2 get 1, buy 3 get 1.
     * + Buy 4 get 2, buy 6 get 2, buy 9 get 2, and so on.
     * @min 1
     */
    limit?: number | null;
}
interface CustomerBuy extends CustomerBuyConditionOneOf {
    /**
     * Minimum number of items the customer must add to the cart to be eligible for a discount.
     * @min 1
     */
    minimumQuantity?: number;
    /**
     * Minimum price the customer must add to the cart to be eligible for a discount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    minimumSpend?: string | null;
    /**
     * Scopes of the items that must be added to the cart to enable the discount.
     * @minSize 1
     * @maxSize 50
     */
    scopes?: Scope[];
}
/** @oneof */
interface CustomerBuyConditionOneOf {
    /**
     * Minimum number of items the customer must add to the cart to be eligible for a discount.
     * @min 1
     */
    minimumQuantity?: number;
    /**
     * Minimum price the customer must add to the cart to be eligible for a discount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    minimumSpend?: string | null;
}
interface CustomerGet {
    /**
     * Exact number of items in the cart that will be discounted.
     * If the cart contains fewer items than the value of quantity, the discount will not apply.
     * @min 1
     */
    quantity?: number;
    /**
     * Scopes of the items that will be discounted.
     * @minSize 1
     * @maxSize 50
     */
    scopes?: Scope[];
}
declare enum Status {
    /** Rule status is not defined. */
    UNDEFINED = "UNDEFINED",
    /** Rule status is live. */
    LIVE = "LIVE",
    /** Rule status is expired, it might have been live in the past. */
    EXPIRED = "EXPIRED",
    /** Rule status is pending, it might be live in the future. */
    PENDING = "PENDING"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNDEFINED' | 'LIVE' | 'EXPIRED' | 'PENDING';
/** The discount settings */
interface DiscountSettings {
    /** Discount applies to either `ALL_ITEMS`, or to the `LOWEST_PRICED_ITEM`. */
    appliesTo?: AppliedSubjectTypeWithLiterals;
    /**
     * Whether the discount will apply to subscriptions.
     *
     * Default: `false`
     */
    includeSubscription?: boolean | null;
    /**
     * Maximum total number of uses allowed for the discount rule.
     * @min 1
     * @max 2147483646
     */
    usageLimit?: number | null;
    /**
     * The usage limit per user per discount.
     * When not provided, this setting will not apply.
     * @min 1
     * @max 2147483646
     */
    usageLimitPerUser?: number | null;
}
/** TODO: check if can be removed */
declare enum AppliedSubjectType {
    UNDEFINED = "UNDEFINED",
    /** Discount applies to all items at checkout. */
    ALL_ITEMS = "ALL_ITEMS",
    /** Discount applies to the lowest priced item at checkout. */
    LOWEST_PRICED_ITEM = "LOWEST_PRICED_ITEM"
}
/** @enumType */
type AppliedSubjectTypeWithLiterals = AppliedSubjectType | 'UNDEFINED' | 'ALL_ITEMS' | 'LOWEST_PRICED_ITEM';
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface CreateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
interface CreateDiscountRuleResponse {
    /** Discount rule. */
    discountRule?: DiscountRule;
}
interface GetDiscountRuleRequest {
    /**
     * ID of the discount rule to retrieve.
     * @format GUID
     */
    discountRuleId: string;
}
interface GetDiscountRuleResponse {
    /** The requested discount rule. */
    discountRule?: DiscountRule;
}
interface UpdateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
interface UpdateDiscountRuleResponse {
    /** Updated discount rule. */
    discountRule?: DiscountRule;
}
interface DeleteDiscountRuleRequest {
    /**
     * ID of the discount rule to delete.
     * @format GUID
     */
    discountRuleId: string;
}
interface DeleteDiscountRuleResponse {
}
interface QueryDiscountRulesRequest {
    /** Query options. */
    query?: PlatformQuery;
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface PlatformPaging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryDiscountRulesResponse {
    /** List of discount rules. */
    discountRules?: DiscountRule[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PlatformPagingMetadata;
}
interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface GetAppliedDiscountsRequest {
    /**
     * Line items for which to check for discount rules.
     * @maxSize 1000
     */
    lineItems?: LineItem[];
    /**
     * Persistent ID that correlates between the various eCommerce elements: cart, checkout, and order.
     * @format GUID
     */
    purchaseFlowId?: string | null;
    /** Buyer Information */
    buyerInfo?: BuyerInfo;
    /** Shipping information. */
    shippingInfo?: ShippingInfo;
    /**
     * The business location ID to be used as the basis for some calculations.
     * Learn more about the [Locations API](https://dev.wix.com/docs/rest/business-management/locations/introduction).
     * @format GUID
     */
    businessLocationId?: string | null;
}
interface LineItem {
    /**
     * Line item ID.
     * @minLength 1
     * @maxLength 100
     */
    id?: string;
    /**
     * Line item quantity.
     * @max 100000
     */
    quantity?: number | null;
    /** Catalog and item reference info. Learn more about [integrating Wix Stores products with Wix eCommerce](https://dev.wix.com/api/rest/wix-stores/catalog/ecommerce-integration). */
    catalogReference?: CatalogReference;
    /**
     * Line item price.
     * @decimalValue options { gte:0 }
     */
    price?: string;
    /**
     * Additional ID for the item in the catalog.
     * This field provides an additional identifier for the item if your flow requires another ID as well as `catalogReference.catalogItemId`.
     * Can be used for membership validation.
     * @minLength 1
     * @maxLength 36
     */
    rootCatalogItemId?: string | null;
}
/** Used for grouping line items. Sent when an item is added to a cart, checkout, or order. */
interface CatalogReference {
    /**
     * ID of the item within the catalog it belongs to.
     * @minLength 1
     * @maxLength 36
     */
    catalogItemId?: string;
    /**
     * ID of the app providing the catalog.
     *
     * You can get your app's ID from its page in the [app dashboard](https://dev.wix.com/dc3/my-apps/).
     *
     * For items from Wix catalogs, the following values always apply:
     * + Wix Stores: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`
     * + Wix Bookings: `"13d21c63-b5ec-5912-8397-c3a5ddb27a97"`
     * + Wix Restaurants: `"9a5d83fd-8570-482e-81ab-cfa88942ee60"`
     * @minLength 1
     */
    appId?: string;
    /**
     * Additional item details in key:value pairs. Use this optional field to provide more specificity with item selection. The `options` field values differ depending on which catalog is providing the items.
     *
     * For products and variants from a Wix Stores catalog, learn more about [eCommerce integration](https://dev.wix.com/docs/rest/business-solutions/stores/catalog/e-commerce-integration).
     */
    options?: Record<string, any> | null;
}
interface BuyerInfo {
    /**
     * Email of the customer.
     * @format EMAIL
     */
    buyerEmail?: string | null;
    /**
     * Member id of the customer.
     * @format GUID
     */
    memberId?: string | null;
}
interface ShippingInfo {
    /** Address (if applicable). */
    address?: Address;
    /**
     * Preferred shipping option code. For example, "usps_std_overnight".
     * @minLength 1
     * @maxLength 100
     */
    preferredShippingOptionCode?: string | null;
}
interface Address {
    /**
     * Two-letter country code in [ISO-3166 alpha-2](https://www.iso.org/obp/ui/#search/code/) format.
     * @format COUNTRY
     */
    country?: string | null;
    /**
     * Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://www.iso.org/standard/72483.html) format.
     * @maxLength 50
     */
    subdivision?: string | null;
    /**
     * City name.
     * @maxLength 50
     */
    city?: string | null;
}
interface GetAppliedDiscountsResponse {
    /** All eligible discounts. */
    appliedDiscounts?: AppliedDiscount[];
}
interface AppliedDiscount {
    /** Discount type. */
    discountType?: TypeWithLiterals;
    /**
     * IDs of line items the discount applies to, in GUID format.
     * @format GUID
     * @maxSize 1000
     */
    lineItemIds?: string[];
    /** Applied discount rule. */
    appliedDiscountRule?: AppliedDiscountRule;
}
interface AppliedDiscountRule {
    /**
     * Applied discount rule ID.
     * @format GUID
     */
    id?: string;
    /** Discount rule name. */
    name?: DiscountRuleName;
    /** Total amount reduced from all discounted line items. */
    amount?: MultiCurrencyPrice;
    /** Discount rule type. */
    discountRuleType?: DiscountTypeWithLiterals;
}
interface DiscountRuleName {
    /**
     * Original discount rule name (in site's default language).
     * @minLength 1
     * @maxLength 256
     */
    original?: string;
    /**
     * Translated discount rule name according to buyer language.
     *
     * Default: `original`
     * @minLength 1
     * @maxLength 500
     */
    translated?: string | null;
}
interface MultiCurrencyPrice {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Converted amount.
     * @readonly
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    convertedAmount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
    /**
     * Converted amount formatted with currency symbol.
     * @readonly
     */
    formattedConvertedAmount?: string;
}
interface BundleParticipation {
    /**
     * Number of times this specific bundle composition was formed
     * by the discount rule.
     */
    repeatCount?: number;
    /**
     * Line items that participated together in this bundle composition.
     * @maxSize 100
     */
    lineItems?: BundleParticipationItem[];
}
interface BundleParticipationItem {
    /**
     * Line item ID that took part in this bundle composition.
     * @format GUID
     */
    lineItemId?: string;
    /** Discount amount applied to this line item *per bundle composition*. */
    amount?: MultiCurrencyPrice;
    /**
     * Number of units from this line item that participated
     * in a single bundle composition.
     * @min 1
     * @max 1000000
     */
    discountedQuantity?: number;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface Empty {
}
interface DiscountRuleUsageLimitReached {
    /** Discount Rule */
    rule?: DiscountRule;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type CreateDiscountRuleApplicationErrors = {
    code?: 'MAX_DISCOUNT_RULES_REACHED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'MAX_QUANTITY_BASED_DISCOUNTS_REACHED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CreateDiscountRuleValidationErrors = {
    ruleName?: 'INVALID_ACTIVE_TIME_RANGE';
} | {
    ruleName?: 'INVALID_EMPTY_DISCOUNT';
} | {
    ruleName?: 'INVALID_DISCOUNT_TYPE';
} | {
    ruleName?: 'MISSING_SUBTOTAL_RANGE';
} | {
    ruleName?: 'MISSING_ITEM_QUANTITY_RANGE';
} | {
    ruleName?: 'INVALID_SUBTOTAL_RANGE';
} | {
    ruleName?: 'INVALID_ITEM_QUANTITY_RANGE';
} | {
    ruleName?: 'INVALID_TARGET_TYPE_FIELD';
} | {
    ruleName?: 'OPERATOR_TOO_DEEPLY_NESTED';
} | {
    ruleName?: 'INVALID_SCOPE_TYPE';
} | {
    ruleName?: 'INVALID_TRIGGER_TYPE';
} | {
    ruleName?: 'INVALID_SETTINGS_SUBJECT_TYPE';
} | {
    ruleName?: 'INVALID_CUSTOMER_BUY_CONDITION';
} | {
    ruleName?: 'INVALID_SCOPE';
};

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createDiscountRule(): __PublicMethodMetaInfo<'POST', {}, CreateDiscountRuleRequest$1, CreateDiscountRuleRequest, CreateDiscountRuleResponse$1, CreateDiscountRuleResponse>;
declare function getDiscountRule(): __PublicMethodMetaInfo<'GET', {
    discountRuleId: string;
}, GetDiscountRuleRequest$1, GetDiscountRuleRequest, GetDiscountRuleResponse$1, GetDiscountRuleResponse>;
declare function updateDiscountRule(): __PublicMethodMetaInfo<'PATCH', {
    discountRuleId: string;
}, UpdateDiscountRuleRequest$1, UpdateDiscountRuleRequest, UpdateDiscountRuleResponse$1, UpdateDiscountRuleResponse>;
declare function deleteDiscountRule(): __PublicMethodMetaInfo<'DELETE', {
    discountRuleId: string;
}, DeleteDiscountRuleRequest$1, DeleteDiscountRuleRequest, DeleteDiscountRuleResponse$1, DeleteDiscountRuleResponse>;
declare function queryDiscountRules(): __PublicMethodMetaInfo<'POST', {}, QueryDiscountRulesRequest$1, QueryDiscountRulesRequest, QueryDiscountRulesResponse$1, QueryDiscountRulesResponse>;

export { type ActionEvent as ActionEventOriginal, type ActiveTimeInfo as ActiveTimeInfoOriginal, type Address as AddressOriginal, type And as AndOriginal, type AppliedDiscount as AppliedDiscountOriginal, type AppliedDiscountRule as AppliedDiscountRuleOriginal, AppliedSubjectType as AppliedSubjectTypeOriginal, type AppliedSubjectTypeWithLiterals as AppliedSubjectTypeWithLiteralsOriginal, type BundleParticipationItem as BundleParticipationItemOriginal, type BundleParticipation as BundleParticipationOriginal, type BuyXGetYInfo as BuyXGetYInfoOriginal, type BuyerInfo as BuyerInfoOriginal, type CatalogItemFilter as CatalogItemFilterOriginal, type CatalogReference as CatalogReferenceOriginal, type ContactSegments as ContactSegmentsOriginal, type ContactTags as ContactTagsOriginal, type CreateDiscountRuleApplicationErrors as CreateDiscountRuleApplicationErrorsOriginal, type CreateDiscountRuleRequest as CreateDiscountRuleRequestOriginal, type CreateDiscountRuleResponse as CreateDiscountRuleResponseOriginal, type CreateDiscountRuleValidationErrors as CreateDiscountRuleValidationErrorsOriginal, type CursorPaging as CursorPagingOriginal, type Cursors as CursorsOriginal, type CustomFilter as CustomFilterOriginal, type Custom as CustomOriginal, type CustomerBuyConditionOneOf as CustomerBuyConditionOneOfOriginal, type CustomerBuy as CustomerBuyOriginal, type CustomerEligibilityOptionsOneOf as CustomerEligibilityOptionsOneOfOriginal, type CustomerEligibility as CustomerEligibilityOriginal, type CustomerGet as CustomerGetOriginal, DayOfWeek as DayOfWeekOriginal, type DayOfWeekWithLiterals as DayOfWeekWithLiteralsOriginal, type DeleteDiscountRuleRequest as DeleteDiscountRuleRequestOriginal, type DeleteDiscountRuleResponse as DeleteDiscountRuleResponseOriginal, type DiscountConfig as DiscountConfigOriginal, type DiscountDiscountOneOf as DiscountDiscountOneOfOriginal, type Discount as DiscountOriginal, type DiscountRuleName as DiscountRuleNameOriginal, type DiscountRule as DiscountRuleOriginal, type DiscountRuleUsageLimitReached as DiscountRuleUsageLimitReachedOriginal, type DiscountSettings as DiscountSettingsOriginal, type DiscountTrigger as DiscountTriggerOriginal, type DiscountTriggerTriggerOneOf as DiscountTriggerTriggerOneOfOriginal, DiscountType as DiscountTypeOriginal, type DiscountTypeWithLiterals as DiscountTypeWithLiteralsOriginal, type Discounts as DiscountsOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, EligibilityType as EligibilityTypeOriginal, type EligibilityTypeWithLiterals as EligibilityTypeWithLiteralsOriginal, type Empty as EmptyOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, type ExtendedFields as ExtendedFieldsOriginal, type GetAppliedDiscountsRequest as GetAppliedDiscountsRequestOriginal, type GetAppliedDiscountsResponse as GetAppliedDiscountsResponseOriginal, type GetDiscountRuleRequest as GetDiscountRuleRequestOriginal, type GetDiscountRuleResponse as GetDiscountRuleResponseOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type IndividualMembers as IndividualMembersOriginal, type ItemQuantityRange as ItemQuantityRangeOriginal, type LineItem as LineItemOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type MultiCurrencyPrice as MultiCurrencyPriceOriginal, type Or as OrOriginal, type PlatformPagingMetadata as PlatformPagingMetadataOriginal, type PlatformPaging as PlatformPagingOriginal, type PlatformQuery as PlatformQueryOriginal, type PlatformQueryPagingMethodOneOf as PlatformQueryPagingMethodOneOfOriginal, type QuantityBased as QuantityBasedOriginal, type QueryDiscountRulesRequest as QueryDiscountRulesRequestOriginal, type QueryDiscountRulesResponse as QueryDiscountRulesResponseOriginal, type Recurrence as RecurrenceOriginal, type RestoreInfo as RestoreInfoOriginal, type Scope as ScopeOriginal, type ScopeScopeItemsOneOf as ScopeScopeItemsOneOfOriginal, ScopeType as ScopeTypeOriginal, type ScopeTypeWithLiterals as ScopeTypeWithLiteralsOriginal, type ShippingInfo as ShippingInfoOriginal, SortOrder as SortOrderOriginal, type SortOrderWithLiterals as SortOrderWithLiteralsOriginal, type Sorting as SortingOriginal, type SpecificItemsInfo as SpecificItemsInfoOriginal, Status as StatusOriginal, type StatusWithLiterals as StatusWithLiteralsOriginal, type SubtotalRange as SubtotalRangeOriginal, type TagReference as TagReferenceOriginal, type TimeOfDay as TimeOfDayOriginal, type TimeWindow as TimeWindowOriginal, TriggerType as TriggerTypeOriginal, type TriggerTypeWithLiterals as TriggerTypeWithLiteralsOriginal, Type as TypeOriginal, type TypeWithLiterals as TypeWithLiteralsOriginal, type UpdateDiscountRuleRequest as UpdateDiscountRuleRequestOriginal, type UpdateDiscountRuleResponse as UpdateDiscountRuleResponseOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type WeeklySchedule as WeeklyScheduleOriginal, type __PublicMethodMetaInfo, createDiscountRule, deleteDiscountRule, getDiscountRule, queryDiscountRules, updateDiscountRule };
