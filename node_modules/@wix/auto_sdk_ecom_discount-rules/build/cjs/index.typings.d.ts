import { QuerySpec, Query, NonNullablePaths } from '@wix/sdk-types';

interface DiscountRule {
    /**
     * Discount rule ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the discount rule is updated.
     * To prevent conflicting changes, the current `revision` must be passed when updating the discount rule.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the discount rule was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the discount rule was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Whether the discount rule is active.
     *
     * Default: `true`
     */
    active?: boolean | null;
    /**
     * Discount rule name.
     * @minLength 1
     * @maxLength 50
     */
    name?: string | null;
    /**
     * Discount rule trigger.
     * A set of conditions that must be met for the `discounts` to be applied.
     * Not passing a trigger will cause the discount to always apply.
     */
    trigger?: DiscountTrigger;
    /** Time frame in which the discount rule is active. */
    activeTimeInfo?: ActiveTimeInfo;
    /**
     * List of discounts that are applied when one or more triggers are met.
     *
     * > **Notes:**
     * >
     * > + Currently, only 1 discount can be defined per discount rule.
     * > + A discount rule can be applied on multiple items per cart.
     * > + A discount rule can only be applied once per item.
     */
    discounts?: Discounts;
    /**
     * Discount rule status.
     * Default: `UNDEFINED`
     * @readonly
     */
    status?: StatusWithLiterals;
    /**
     * Number of times the discount rule was used.
     * @readonly
     */
    usageCount?: number;
}
/** DiscountTrigger - description of a set of conditions, that if met, will trigger the associated rule actions */
interface DiscountTrigger extends DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
    /**
     * Trigger type.
     *
     * + `"AND"`: Operator used for chaining multiple triggers. Currently 1 `"AND"` chain operator is supported.
     * + `"SUBTOTAL_RANGE"`: Subtotal must be within the specified `subtotalRange` values.
     * + `"ITEM_QUANTITY_RANGE"`: Quantity of items in scope must be within specified `itemQuantityRange` values.
     * + `"CUSTOM"`: Custom trigger type defined in `customTrigger` object.
     */
    triggerType?: TriggerTypeWithLiterals;
}
/** @oneof */
interface DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
}
/**
 * This object represents a scope of catalog items. Examples:
 * 1. All catalog items of a specific app - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id`
 * 2. Specific catalog item - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id` + `catalog_item_ids`
 * 3. External catalog filter - type = CUSTOM_FILTER, CustomFilter with 'app_id' + 'params'
 */
interface Scope extends ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
    /**
     * Scope ID.
     * @minLength 1
     * @maxLength 100
     */
    _id?: string;
    /** Scope type. */
    type?: ScopeTypeWithLiterals;
}
/** @oneof */
interface ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
}
declare enum ScopeType {
    UNDEFINED_SCOPE = "UNDEFINED_SCOPE",
    /** Specific catalog items */
    CATALOG_ITEM = "CATALOG_ITEM",
    /** Specific items by custom filters */
    CUSTOM_FILTER = "CUSTOM_FILTER"
}
/** @enumType */
type ScopeTypeWithLiterals = ScopeType | 'UNDEFINED_SCOPE' | 'CATALOG_ITEM' | 'CUSTOM_FILTER';
interface CatalogItemFilter {
    /**
     * Catalog App ID. For example, the Wix Stores, Wix Bookings, or 3rd-party `appId`.
     * @format GUID
     */
    catalogAppId?: string;
    /**
     * ID of the item within its Wix or 3rd-party catalog. For example, `productId` for Wix Stores.
     * @minLength 1
     * @maxLength 36
     * @maxSize 50
     */
    catalogItemIds?: string[];
}
interface CustomFilter {
    /**
     * Custom filter app ID, when relevant.
     * @format GUID
     */
    appId?: string;
    /**
     * Custom filter in `{ "key": "value" }` form.
     * For example, an array of `collectionIDs`:
     * `{ ["collectionId": "12345"], ["collectionId": "67890"] }`.
     */
    params?: Record<string, any> | null;
}
interface And {
    /**
     * List of triggers to have an "AND" operator between their results.
     * @minSize 2
     * @maxSize 5
     */
    triggers?: DiscountTrigger[];
}
interface Or {
    /**
     * List of triggers to have an "OR" operator between their results.
     * @minSize 2
     * @maxSize 5
     */
    triggers?: DiscountTrigger[];
}
interface Custom {
    /**
     * Trigger ID.
     * @minLength 1
     * @maxLength 100
     */
    _id?: string;
    /**
     * ID of the app that created the trigger.
     * @format GUID
     */
    appId?: string;
}
interface SubtotalRange {
    /**
     * Relevant scopes for `"SPECIFIC_ITEMS"` target type.
     * @maxSize 50
     */
    scopes?: Scope[];
    /**
     * Minimum subtotal price (inclusive).
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    from?: string | null;
    /**
     * Maximum subtotal price (inclusive).
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    to?: string | null;
}
interface ItemQuantityRange {
    /**
     * Relevant scopes for `"SPECIFIC_ITEMS"` target type.
     * @maxSize 50
     */
    scopes?: Scope[];
    /**
     * Minimum item quantity (inclusive).
     * @min 1
     */
    from?: number | null;
    /**
     * Maximum item quantity (inclusive).
     * @min 1
     */
    to?: number | null;
}
interface CustomerEligibility extends CustomerEligibilityOptionsOneOf {
    /** Information about specific members. */
    individualMembersInfo?: IndividualMembers;
}
/** @oneof */
interface CustomerEligibilityOptionsOneOf {
    /** Information about specific members. */
    individualMembersInfo?: IndividualMembers;
}
declare enum EligibilityType {
    /** Eligibility type is not defined. */
    UNKNOWN_ELIGIBILITY_TYPE = "UNKNOWN_ELIGIBILITY_TYPE",
    /** Only specific customers based on member id. */
    INDIVIDUAL_MEMBERS = "INDIVIDUAL_MEMBERS"
}
/** @enumType */
type EligibilityTypeWithLiterals = EligibilityType | 'UNKNOWN_ELIGIBILITY_TYPE' | 'INDIVIDUAL_MEMBERS';
interface ContactSegments {
    /**
     * Eligible segment ids.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    segmentIds?: string[];
}
interface ContactTags {
    /**
     * Eligible tag and label ids.
     * @minSize 1
     * @maxSize 100
     */
    tagReferences?: TagReference[];
}
interface TagReference {
    /**
     * Eligible tag id.
     * @maxLength 5
     */
    tagId?: string;
    /**
     * Eligible label id.
     * @maxLength 80
     */
    labelKey?: string;
}
interface IndividualMembers {
    /**
     * Eligible member ids.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    memberIds?: string[];
}
declare enum TriggerType {
    UNDEFINED = "UNDEFINED",
    /** Operator used for chaining multiple triggers. Currently 1 `AND` chain operator is supported. */
    AND = "AND",
    /** Subtotal must be within the specified `subtotalRange` values. */
    SUBTOTAL_RANGE = "SUBTOTAL_RANGE",
    /** Quantity of items in scope must be within specified `itemQuantityRange` values. */
    ITEM_QUANTITY_RANGE = "ITEM_QUANTITY_RANGE",
    /** Custom trigger type defined in `customTrigger` object. */
    CUSTOM = "CUSTOM",
    /** Chain multiple triggers with OR operator */
    OR = "OR"
}
/** @enumType */
type TriggerTypeWithLiterals = TriggerType | 'UNDEFINED' | 'AND' | 'SUBTOTAL_RANGE' | 'ITEM_QUANTITY_RANGE' | 'CUSTOM' | 'OR';
interface ActiveTimeInfo {
    /** Date and time the discount rule is active **from**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    start?: Date | null;
    /** Date and time the discount rule is active **till**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    end?: Date | null;
}
interface Recurrence {
    /** Weekly discount recurrence. */
    weeklySchedule?: WeeklySchedule;
}
declare enum DayOfWeek {
    UNKOWN_DAY_OF_WEEK = "UNKOWN_DAY_OF_WEEK",
    /** Monday. */
    MON = "MON",
    /** Tuesday. */
    TUE = "TUE",
    /** Wednesday. */
    WED = "WED",
    /** Thursday. */
    THU = "THU",
    /** Friday. */
    FRI = "FRI",
    /** Saturday. */
    SAT = "SAT",
    /** Sunday. */
    SUN = "SUN"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'UNKOWN_DAY_OF_WEEK' | 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT' | 'SUN';
interface TimeOfDay {
    /**
     * Hours. Min: `0`. Max: `23`.
     * @max 23
     */
    hours?: number;
    /**
     * Minutes. Min: `0`. Max: `59`.
     * @max 59
     */
    minutes?: number;
}
interface TimeWindow {
    /** Day of week. */
    dayOfWeek?: DayOfWeekWithLiterals;
    /** Start time window during each recurrence. */
    startTime?: TimeOfDay;
    /** End time window during each recurrence. */
    endTime?: TimeOfDay;
}
interface WeeklySchedule {
    /**
     * A list of days with their respective active time ranges.
     * @minSize 1
     * @maxSize 100
     */
    timeWindows?: TimeWindow[];
}
interface Discounts {
    /**
     * Discounts.
     * @minSize 1
     * @maxSize 1
     */
    values?: Discount[];
}
interface Discount extends DiscountDiscountOneOf {
    /**
     * Percentage to discount from original price.
     * @min 0.1
     * @max 100
     */
    percentage?: number;
    /**
     * Amount to discount from original price.
     * @decimalValue options { gt:0, lte:1000000000000000, maxScale:4 }
     */
    fixedAmount?: string;
    /**
     * Fixed price. Line item will be fixed to this price.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    fixedPrice?: string;
    /** A special price is applied for a specific quantity of items. For example, 3 for $10. */
    quantityBased?: QuantityBased;
    /**
     * Discount target.
     *
     * + `"SPECIFIC_ITEMS"`: Discount applies to a specific set of items.
     */
    targetType?: TypeWithLiterals;
    /** Data related to `"SPECIFIC_ITEMS"` target type. */
    specificItemsInfo?: SpecificItemsInfo;
    /**
     * Discount type.
     *
     * + `"PERCENTAGE"`: Price is reduced by percentage value.
     * + `"FIXED_AMOUNT"`: Price is reduced by fixed amount.
     * + `"FIXED_PRICE"`: Price will be set to fixed amount.
     */
    discountType?: DiscountTypeWithLiterals;
}
/** @oneof */
interface DiscountDiscountOneOf {
    /**
     * Percentage to discount from original price.
     * @min 0.1
     * @max 100
     */
    percentage?: number;
    /**
     * Amount to discount from original price.
     * @decimalValue options { gt:0, lte:1000000000000000, maxScale:4 }
     */
    fixedAmount?: string;
    /**
     * Fixed price. Line item will be fixed to this price.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:4 }
     */
    fixedPrice?: string;
    /** A special price is applied for a specific quantity of items. For example, 3 for $10. */
    quantityBased?: QuantityBased;
}
declare enum Type {
    /** Target type is not defined */
    UNDEFINED = "UNDEFINED",
    /** Target type is a set of specific items */
    SPECIFIC_ITEMS = "SPECIFIC_ITEMS"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNDEFINED' | 'SPECIFIC_ITEMS';
interface SpecificItemsInfo {
    /**
     * All associated scopes for `"SPECIFIC_ITEMS"` target type.
     * @minSize 1
     * @maxSize 50
     */
    scopes?: Scope[];
}
/** A special price is applied for a specific quantity of items. For example, 3 for $10. */
interface QuantityBased {
    /**
     * list of discountConfig options.
     * @minSize 1
     * @maxSize 1
     */
    configurations?: DiscountConfig[];
}
interface DiscountConfig {
    /**
     * DiscountConfig ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * The number of items that must be added to the cart to be eligible for the discount (Represents X).
     * @min 2
     */
    quantity?: number;
    /**
     * The DiscountConfig price (Represents Amount).
     * @decimalValue options { gte:0, lte:1000000, maxScale:4 }
     */
    price?: string;
}
declare enum DiscountType {
    UNDEFINED = "UNDEFINED",
    /** Price is reduced by percentage value. */
    PERCENTAGE = "PERCENTAGE",
    /** Price is reduced by fixed amount. */
    FIXED_AMOUNT = "FIXED_AMOUNT",
    /** Price will be set to fixed amount. */
    FIXED_PRICE = "FIXED_PRICE",
    /**
     * Quantity based options for Buy X For Amount.
     * @documentationMaturity preview
     */
    QUANTITY_BASED = "QUANTITY_BASED"
}
/** @enumType */
type DiscountTypeWithLiterals = DiscountType | 'UNDEFINED' | 'PERCENTAGE' | 'FIXED_AMOUNT' | 'FIXED_PRICE' | 'QUANTITY_BASED';
interface BuyXGetYInfo {
    /** Information about which items must be in the cart (buy X) for the discount to apply (get Y). */
    customerBuys?: CustomerBuy;
    /** Information about which items will be discounted (get Y). */
    customerGets?: CustomerGet;
    /**
     * The maximum number of times the 'buy X get Y' discount can be applied.
     * For example, when the value of `limit` is `2`, with a "2+1" sale on all items, the following logic applies:
     * + Buy 2 get 1, buy 3 get 1.
     * + Buy 4 get 2, buy 6 get 2, buy 9 get 2, and so on.
     * @min 1
     */
    limit?: number | null;
}
interface CustomerBuy extends CustomerBuyConditionOneOf {
    /**
     * Minimum number of items the customer must add to the cart to be eligible for a discount.
     * @min 1
     */
    minimumQuantity?: number;
    /**
     * Minimum price the customer must add to the cart to be eligible for a discount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    minimumSpend?: string | null;
    /**
     * Scopes of the items that must be added to the cart to enable the discount.
     * @minSize 1
     * @maxSize 50
     */
    scopes?: Scope[];
}
/** @oneof */
interface CustomerBuyConditionOneOf {
    /**
     * Minimum number of items the customer must add to the cart to be eligible for a discount.
     * @min 1
     */
    minimumQuantity?: number;
    /**
     * Minimum price the customer must add to the cart to be eligible for a discount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    minimumSpend?: string | null;
}
interface CustomerGet {
    /**
     * Exact number of items in the cart that will be discounted.
     * If the cart contains fewer items than the value of quantity, the discount will not apply.
     * @min 1
     */
    quantity?: number;
    /**
     * Scopes of the items that will be discounted.
     * @minSize 1
     * @maxSize 50
     */
    scopes?: Scope[];
}
declare enum Status {
    /** Rule status is not defined. */
    UNDEFINED = "UNDEFINED",
    /** Rule status is live. */
    LIVE = "LIVE",
    /** Rule status is expired, it might have been live in the past. */
    EXPIRED = "EXPIRED",
    /** Rule status is pending, it might be live in the future. */
    PENDING = "PENDING"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNDEFINED' | 'LIVE' | 'EXPIRED' | 'PENDING';
/** The discount settings */
interface DiscountSettings {
    /** Discount applies to either `ALL_ITEMS`, or to the `LOWEST_PRICED_ITEM`. */
    appliesTo?: AppliedSubjectTypeWithLiterals;
    /**
     * Whether the discount will apply to subscriptions.
     *
     * Default: `false`
     */
    includeSubscription?: boolean | null;
    /**
     * Maximum total number of uses allowed for the discount rule.
     * @min 1
     * @max 2147483646
     */
    usageLimit?: number | null;
    /**
     * The usage limit per user per discount.
     * When not provided, this setting will not apply.
     * @min 1
     * @max 2147483646
     */
    usageLimitPerUser?: number | null;
}
/** TODO: check if can be removed */
declare enum AppliedSubjectType {
    UNDEFINED = "UNDEFINED",
    /** Discount applies to all items at checkout. */
    ALL_ITEMS = "ALL_ITEMS",
    /** Discount applies to the lowest priced item at checkout. */
    LOWEST_PRICED_ITEM = "LOWEST_PRICED_ITEM"
}
/** @enumType */
type AppliedSubjectTypeWithLiterals = AppliedSubjectType | 'UNDEFINED' | 'ALL_ITEMS' | 'LOWEST_PRICED_ITEM';
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface CreateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
interface CreateDiscountRuleResponse {
    /** Discount rule. */
    discountRule?: DiscountRule;
}
interface GetDiscountRuleRequest {
    /**
     * ID of the discount rule to retrieve.
     * @format GUID
     */
    discountRuleId: string;
}
interface GetDiscountRuleResponse {
    /** The requested discount rule. */
    discountRule?: DiscountRule;
}
interface UpdateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
interface UpdateDiscountRuleResponse {
    /** Updated discount rule. */
    discountRule?: DiscountRule;
}
interface DeleteDiscountRuleRequest {
    /**
     * ID of the discount rule to delete.
     * @format GUID
     */
    discountRuleId: string;
}
interface DeleteDiscountRuleResponse {
}
interface QueryDiscountRulesRequest {
    /** Query options. */
    query?: PlatformQuery;
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface PlatformPaging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryDiscountRulesResponse {
    /** List of discount rules. */
    discountRules?: DiscountRule[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PlatformPagingMetadata;
}
interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface GetAppliedDiscountsRequest {
    /**
     * Line items for which to check for discount rules.
     * @maxSize 1000
     */
    lineItems?: LineItem[];
    /**
     * Persistent ID that correlates between the various eCommerce elements: cart, checkout, and order.
     * @format GUID
     */
    purchaseFlowId?: string | null;
    /** Buyer Information */
    buyerInfo?: BuyerInfo;
    /** Shipping information. */
    shippingInfo?: ShippingInfo;
    /**
     * The business location ID to be used as the basis for some calculations.
     * Learn more about the [Locations API](https://dev.wix.com/docs/rest/business-management/locations/introduction).
     * @format GUID
     */
    businessLocationId?: string | null;
}
interface LineItem {
    /**
     * Line item ID.
     * @minLength 1
     * @maxLength 100
     */
    _id?: string;
    /**
     * Line item quantity.
     * @max 100000
     */
    quantity?: number | null;
    /** Catalog and item reference info. Learn more about [integrating Wix Stores products with Wix eCommerce](https://dev.wix.com/api/rest/wix-stores/catalog/ecommerce-integration). */
    catalogReference?: CatalogReference;
    /**
     * Line item price.
     * @decimalValue options { gte:0 }
     */
    price?: string;
    /**
     * Additional ID for the item in the catalog.
     * This field provides an additional identifier for the item if your flow requires another ID as well as `catalogReference.catalogItemId`.
     * Can be used for membership validation.
     * @minLength 1
     * @maxLength 36
     */
    rootCatalogItemId?: string | null;
}
/** Used for grouping line items. Sent when an item is added to a cart, checkout, or order. */
interface CatalogReference {
    /**
     * ID of the item within the catalog it belongs to.
     * @minLength 1
     * @maxLength 36
     */
    catalogItemId?: string;
    /**
     * ID of the app providing the catalog.
     *
     * You can get your app's ID from its page in the [app dashboard](https://dev.wix.com/dc3/my-apps/).
     *
     * For items from Wix catalogs, the following values always apply:
     * + Wix Stores: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`
     * + Wix Bookings: `"13d21c63-b5ec-5912-8397-c3a5ddb27a97"`
     * + Wix Restaurants: `"9a5d83fd-8570-482e-81ab-cfa88942ee60"`
     * @minLength 1
     */
    appId?: string;
    /**
     * Additional item details in key:value pairs. Use this optional field to provide more specificity with item selection. The `options` field values differ depending on which catalog is providing the items.
     *
     * For products and variants from a Wix Stores catalog, learn more about [eCommerce integration](https://dev.wix.com/docs/rest/business-solutions/stores/catalog/e-commerce-integration).
     */
    options?: Record<string, any> | null;
}
interface BuyerInfo {
    /**
     * Email of the customer.
     * @format EMAIL
     */
    buyerEmail?: string | null;
    /**
     * Member id of the customer.
     * @format GUID
     */
    memberId?: string | null;
}
interface ShippingInfo {
    /** Address (if applicable). */
    address?: Address;
    /**
     * Preferred shipping option code. For example, "usps_std_overnight".
     * @minLength 1
     * @maxLength 100
     */
    preferredShippingOptionCode?: string | null;
}
interface Address {
    /**
     * Two-letter country code in [ISO-3166 alpha-2](https://www.iso.org/obp/ui/#search/code/) format.
     * @format COUNTRY
     */
    country?: string | null;
    /**
     * Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://www.iso.org/standard/72483.html) format.
     * @maxLength 50
     */
    subdivision?: string | null;
    /**
     * City name.
     * @maxLength 50
     */
    city?: string | null;
}
interface GetAppliedDiscountsResponse {
    /** All eligible discounts. */
    appliedDiscounts?: AppliedDiscount[];
}
interface AppliedDiscount {
    /** Discount type. */
    discountType?: TypeWithLiterals;
    /**
     * IDs of line items the discount applies to, in GUID format.
     * @format GUID
     * @maxSize 1000
     */
    lineItemIds?: string[];
    /** Applied discount rule. */
    appliedDiscountRule?: AppliedDiscountRule;
}
interface AppliedDiscountRule {
    /**
     * Applied discount rule ID.
     * @format GUID
     */
    _id?: string;
    /** Discount rule name. */
    name?: DiscountRuleName;
    /** Total amount reduced from all discounted line items. */
    amount?: MultiCurrencyPrice;
    /** Discount rule type. */
    discountRuleType?: DiscountTypeWithLiterals;
}
interface DiscountRuleName {
    /**
     * Original discount rule name (in site's default language).
     * @minLength 1
     * @maxLength 256
     */
    original?: string;
    /**
     * Translated discount rule name according to buyer language.
     *
     * Default: `original`
     * @minLength 1
     * @maxLength 500
     */
    translated?: string | null;
}
interface MultiCurrencyPrice {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Converted amount.
     * @readonly
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    convertedAmount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
    /**
     * Converted amount formatted with currency symbol.
     * @readonly
     */
    formattedConvertedAmount?: string;
}
interface BundleParticipation {
    /**
     * Number of times this specific bundle composition was formed
     * by the discount rule.
     */
    repeatCount?: number;
    /**
     * Line items that participated together in this bundle composition.
     * @maxSize 100
     */
    lineItems?: BundleParticipationItem[];
}
interface BundleParticipationItem {
    /**
     * Line item ID that took part in this bundle composition.
     * @format GUID
     */
    lineItemId?: string;
    /** Discount amount applied to this line item *per bundle composition*. */
    amount?: MultiCurrencyPrice;
    /**
     * Number of units from this line item that participated
     * in a single bundle composition.
     * @min 1
     * @max 1000000
     */
    discountedQuantity?: number;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface DiscountRuleUsageLimitReached {
    /** Discount Rule */
    rule?: DiscountRule;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type CreateDiscountRuleApplicationErrors = {
    code?: 'MAX_DISCOUNT_RULES_REACHED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'MAX_QUANTITY_BASED_DISCOUNTS_REACHED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CreateDiscountRuleValidationErrors = {
    ruleName?: 'INVALID_ACTIVE_TIME_RANGE';
} | {
    ruleName?: 'INVALID_EMPTY_DISCOUNT';
} | {
    ruleName?: 'INVALID_DISCOUNT_TYPE';
} | {
    ruleName?: 'MISSING_SUBTOTAL_RANGE';
} | {
    ruleName?: 'MISSING_ITEM_QUANTITY_RANGE';
} | {
    ruleName?: 'INVALID_SUBTOTAL_RANGE';
} | {
    ruleName?: 'INVALID_ITEM_QUANTITY_RANGE';
} | {
    ruleName?: 'INVALID_TARGET_TYPE_FIELD';
} | {
    ruleName?: 'OPERATOR_TOO_DEEPLY_NESTED';
} | {
    ruleName?: 'INVALID_SCOPE_TYPE';
} | {
    ruleName?: 'INVALID_TRIGGER_TYPE';
} | {
    ruleName?: 'INVALID_SETTINGS_SUBJECT_TYPE';
} | {
    ruleName?: 'INVALID_CUSTOMER_BUY_CONDITION';
} | {
    ruleName?: 'INVALID_SCOPE';
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface DiscountRuleCreatedEnvelope {
    entity: DiscountRule;
    metadata: EventMetadata;
}
/**
 * Triggered when a discount rule is created.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionId ECOM.DISCOUNT_RULES_READ
 * @webhook
 * @eventType wix.ecom.discounts.v1.discount_rule_created
 * @serviceIdentifier com.wix.ecom.discounts.DiscountRuleService
 * @slug created
 */
declare function onDiscountRuleCreated(handler: (event: DiscountRuleCreatedEnvelope) => void | Promise<void>): void;
interface DiscountRuleDeletedEnvelope {
    metadata: EventMetadata;
}
/**
 * Triggered when a discount rule is deleted.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionId ECOM.DISCOUNT_RULES_READ
 * @webhook
 * @eventType wix.ecom.discounts.v1.discount_rule_deleted
 * @serviceIdentifier com.wix.ecom.discounts.DiscountRuleService
 * @slug deleted
 */
declare function onDiscountRuleDeleted(handler: (event: DiscountRuleDeletedEnvelope) => void | Promise<void>): void;
interface DiscountRuleUpdatedEnvelope {
    entity: DiscountRule;
    metadata: EventMetadata;
    /** @hidden */
    modifiedFields: Record<string, any>;
}
/**
 * Triggered when a discount rule is updated.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionId ECOM.DISCOUNT_RULES_READ
 * @webhook
 * @eventType wix.ecom.discounts.v1.discount_rule_updated
 * @serviceIdentifier com.wix.ecom.discounts.DiscountRuleService
 * @slug updated
 */
declare function onDiscountRuleUpdated(handler: (event: DiscountRuleUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a new discount rule.
 *
 *
 * The `createDiscountRule()` function returns a Promise that resolves to the new discount rule when it's created.
 * @param discountRule - Discount rule info.
 * @public
 * @requiredField discountRule
 * @requiredField discountRule.discounts
 * @requiredField discountRule.name
 * @permissionId ECOM.DISCOUNT_RULES_CREATE
 * @applicableIdentity APP
 * @returns Discount rule.
 * @fqn com.wix.ecom.discounts.DiscountRuleService.CreateDiscountRule
 */
declare function createDiscountRule(discountRule: NonNullablePaths<DiscountRule, `discounts` | `name`, 2>): Promise<NonNullablePaths<DiscountRule, `trigger.and.triggers` | `trigger.or.triggers` | `trigger.customTrigger._id` | `trigger.customTrigger.appId` | `trigger.subtotalRange.scopes` | `trigger.subtotalRange.scopes.${number}.catalogItemFilter.catalogAppId` | `trigger.subtotalRange.scopes.${number}.customFilter.appId` | `trigger.subtotalRange.scopes.${number}._id` | `trigger.subtotalRange.scopes.${number}.type` | `trigger.itemQuantityRange.scopes` | `trigger.triggerType` | `discounts.values` | `discounts.values.${number}.percentage` | `discounts.values.${number}.fixedAmount` | `discounts.values.${number}.fixedPrice` | `discounts.values.${number}.targetType` | `discounts.values.${number}.discountType` | `status` | `usageCount`, 7> & {
    __applicationErrorsType?: CreateDiscountRuleApplicationErrors;
    __validationErrorsType?: CreateDiscountRuleValidationErrors;
}>;
/**
 * Retrieves a discount rule.
 *
 *
 * The `getDiscountRule()` function returns a Promise that resolves when the specified discount rule is retrieved.
 * @param discountRuleId - ID of the discount rule to retrieve.
 * @public
 * @requiredField discountRuleId
 * @permissionId ECOM.DISCOUNT_RULES_READ
 * @applicableIdentity APP
 * @returns The requested discount rule.
 * @fqn com.wix.ecom.discounts.DiscountRuleService.GetDiscountRule
 */
declare function getDiscountRule(discountRuleId: string): Promise<NonNullablePaths<DiscountRule, `trigger.and.triggers` | `trigger.or.triggers` | `trigger.customTrigger._id` | `trigger.customTrigger.appId` | `trigger.subtotalRange.scopes` | `trigger.subtotalRange.scopes.${number}.catalogItemFilter.catalogAppId` | `trigger.subtotalRange.scopes.${number}.customFilter.appId` | `trigger.subtotalRange.scopes.${number}._id` | `trigger.subtotalRange.scopes.${number}.type` | `trigger.itemQuantityRange.scopes` | `trigger.triggerType` | `discounts.values` | `discounts.values.${number}.percentage` | `discounts.values.${number}.fixedAmount` | `discounts.values.${number}.fixedPrice` | `discounts.values.${number}.targetType` | `discounts.values.${number}.discountType` | `status` | `usageCount`, 7>>;
/**
 * Updates a discount rule's properties.
 *
 *
 * The `updateDiscountRule()` function returns a Promise that resolves when the specified discount rule's properties are updated.
 *
 * Each time the discount rule is updated, `revision` increments by 1. The existing `revision` must be included when updating the discount rule. This ensures you're working with the latest discount rule information, and it prevents unintended overwrites.
 * @param _id - Discount rule ID.
 * @public
 * @requiredField _id
 * @requiredField discountRule
 * @requiredField discountRule.revision
 * @param discountRule - Discount rule info.
 * @param options - Discount rule info.
 * @permissionId ECOM.DISCOUNT_RULES_UPDATE
 * @applicableIdentity APP
 * @returns Updated discount rule.
 * @fqn com.wix.ecom.discounts.DiscountRuleService.UpdateDiscountRule
 */
declare function updateDiscountRule(_id: string, discountRule: NonNullablePaths<UpdateDiscountRule, `revision`, 2>): Promise<NonNullablePaths<DiscountRule, `trigger.and.triggers` | `trigger.or.triggers` | `trigger.customTrigger._id` | `trigger.customTrigger.appId` | `trigger.subtotalRange.scopes` | `trigger.subtotalRange.scopes.${number}.catalogItemFilter.catalogAppId` | `trigger.subtotalRange.scopes.${number}.customFilter.appId` | `trigger.subtotalRange.scopes.${number}._id` | `trigger.subtotalRange.scopes.${number}.type` | `trigger.itemQuantityRange.scopes` | `trigger.triggerType` | `discounts.values` | `discounts.values.${number}.percentage` | `discounts.values.${number}.fixedAmount` | `discounts.values.${number}.fixedPrice` | `discounts.values.${number}.targetType` | `discounts.values.${number}.discountType` | `status` | `usageCount`, 7>>;
interface UpdateDiscountRule {
    /**
     * Discount rule ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the discount rule is updated.
     * To prevent conflicting changes, the current `revision` must be passed when updating the discount rule.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the discount rule was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the discount rule was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Whether the discount rule is active.
     *
     * Default: `true`
     */
    active?: boolean | null;
    /**
     * Discount rule name.
     * @minLength 1
     * @maxLength 50
     */
    name?: string | null;
    /**
     * Discount rule trigger.
     * A set of conditions that must be met for the `discounts` to be applied.
     * Not passing a trigger will cause the discount to always apply.
     */
    trigger?: DiscountTrigger;
    /** Time frame in which the discount rule is active. */
    activeTimeInfo?: ActiveTimeInfo;
    /**
     * List of discounts that are applied when one or more triggers are met.
     *
     * > **Notes:**
     * >
     * > + Currently, only 1 discount can be defined per discount rule.
     * > + A discount rule can be applied on multiple items per cart.
     * > + A discount rule can only be applied once per item.
     */
    discounts?: Discounts;
    /**
     * Discount rule status.
     * Default: `UNDEFINED`
     * @readonly
     */
    status?: StatusWithLiterals;
    /**
     * Number of times the discount rule was used.
     * @readonly
     */
    usageCount?: number;
}
/**
 * Deletes a discount rule.
 *
 *
 * The `deleteDiscountRule()` function returns a Promise that resolves when the specified discount rule is deleted.
 * @param discountRuleId - ID of the discount rule to delete.
 * @public
 * @requiredField discountRuleId
 * @permissionId ECOM.DISCOUNT_RULES_DELETE
 * @applicableIdentity APP
 * @fqn com.wix.ecom.discounts.DiscountRuleService.DeleteDiscountRule
 */
declare function deleteDiscountRule(discountRuleId: string): Promise<void>;
/**
 * Creates a query to retrieve a list of discount rules.
 *
 *
 * The `queryDiscountRules()` function builds a query to retrieve a list of up to 100 discount rules, and returns a [`DiscountRulesQueryBuilder`](#discountrulesquerybuilder) object.
 *
 * The returned object contains the query definition which is typically used to run the query using the [`find()`](/discount-rules/discount-rules-query-builder/find) function.
 *
 * You can refine the query by chaining `DiscountRulesQueryBuilder` functions onto the query. `DiscountRulesQueryBuilder` functions enable you to sort, filter, and control the results queryDiscountRules() returns.
 *
 * By default, `queryDiscountRules()` sorts results by [`ascending("_id")`](/discount-rules/discount-rules-query-builder/ascending) by default. This can be overridden.
 *
 * To learn how to query posts, refer to the table below.
 *
 * The following `DiscountRulesQueryBuilder` functions are supported for the `queryDiscountRules()` function. For a full description of the discount rule object, see the object returned for the [`items`](/discount-rules/discount-rules-query-result/items) property in the `DiscountRulesQueryResult`.
 * @public
 * @permissionId ECOM.DISCOUNT_RULES_READ
 * @applicableIdentity APP
 * @fqn com.wix.ecom.discounts.DiscountRuleService.QueryDiscountRules
 */
declare function queryDiscountRules(): DiscountRulesQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface DiscountRulesQueryResult extends QueryCursorResult {
    items: DiscountRule[];
    query: DiscountRulesQueryBuilder;
    next: () => Promise<DiscountRulesQueryResult>;
    prev: () => Promise<DiscountRulesQueryResult>;
}
interface DiscountRulesQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'active' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: any) => DiscountRulesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'active' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: any) => DiscountRulesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: any) => DiscountRulesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: any) => DiscountRulesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: any) => DiscountRulesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: any) => DiscountRulesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     */
    startsWith: (propertyName: '_id' | 'name', value: string) => DiscountRulesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasSome: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'active' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: any[]) => DiscountRulesQueryBuilder;
    in: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'active' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: any) => DiscountRulesQueryBuilder;
    exists: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'active' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end', value: boolean) => DiscountRulesQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_id' | 'revision' | '_createdDate' | '_updatedDate' | 'active' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end'>) => DiscountRulesQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_id' | 'revision' | '_createdDate' | '_updatedDate' | 'active' | 'name' | 'activeTimeInfo.start' | 'activeTimeInfo.end'>) => DiscountRulesQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => DiscountRulesQueryBuilder;
    /** @param cursor - A pointer to specific record */
    skipTo: (cursor: string) => DiscountRulesQueryBuilder;
    find: () => Promise<DiscountRulesQueryResult>;
}
/**
 * @hidden
 * @fqn com.wix.ecom.discounts.DiscountRuleService.QueryDiscountRules
 * @requiredField query
 */
declare function typedQueryDiscountRules(query: DiscountRuleQuery): Promise<NonNullablePaths<QueryDiscountRulesResponse, `discountRules` | `discountRules.${number}.trigger.customTrigger._id` | `discountRules.${number}.trigger.customTrigger.appId` | `discountRules.${number}.trigger.triggerType` | `discountRules.${number}.status` | `discountRules.${number}.usageCount`, 6>>;
interface DiscountRuleQuerySpec extends QuerySpec {
    paging: 'cursor';
    wql: [
        {
            fields: [
                '_createdDate',
                '_id',
                '_updatedDate',
                'active',
                'activeTimeInfo.end',
                'activeTimeInfo.start',
                'name',
                'revision'
            ];
            operators: '*';
            sort: 'BOTH';
        }
    ];
}
type CommonQueryWithEntityContext = Query<DiscountRule, DiscountRuleQuerySpec>;
type DiscountRuleQuery = {
    /**
    Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`.
    */
    cursorPaging?: {
        /**
      Maximum number of items to return in the results.
      @max: 100
      */
        limit?: NonNullable<CommonQueryWithEntityContext['cursorPaging']>['limit'] | null;
        /**
      Pointer to the next or previous page in the list of results.
    
      Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
      Not relevant for the first request.
      @maxLength: 16000
      */
        cursor?: NonNullable<CommonQueryWithEntityContext['cursorPaging']>['cursor'] | null;
    };
    /**
    Filter object.
    */
    filter?: CommonQueryWithEntityContext['filter'] | null;
    /**
    Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`.
    */
    sort?: {
        /**
      Name of the field to sort by.
      @maxLength: 512
      */
        fieldName?: NonNullable<CommonQueryWithEntityContext['sort']>[number]['fieldName'];
        /**
      Sort order.
      */
        order?: NonNullable<CommonQueryWithEntityContext['sort']>[number]['order'];
    }[];
};

export { type ActionEvent, type ActiveTimeInfo, type Address, type And, type AppliedDiscount, type AppliedDiscountRule, AppliedSubjectType, type AppliedSubjectTypeWithLiterals, type BaseEventMetadata, type BundleParticipation, type BundleParticipationItem, type BuyXGetYInfo, type BuyerInfo, type CatalogItemFilter, type CatalogReference, type CommonQueryWithEntityContext, type ContactSegments, type ContactTags, type CreateDiscountRuleApplicationErrors, type CreateDiscountRuleRequest, type CreateDiscountRuleResponse, type CreateDiscountRuleValidationErrors, type CursorPaging, type Cursors, type Custom, type CustomFilter, type CustomerBuy, type CustomerBuyConditionOneOf, type CustomerEligibility, type CustomerEligibilityOptionsOneOf, type CustomerGet, DayOfWeek, type DayOfWeekWithLiterals, type DeleteDiscountRuleRequest, type DeleteDiscountRuleResponse, type Discount, type DiscountConfig, type DiscountDiscountOneOf, type DiscountRule, type DiscountRuleCreatedEnvelope, type DiscountRuleDeletedEnvelope, type DiscountRuleName, type DiscountRuleQuery, type DiscountRuleQuerySpec, type DiscountRuleUpdatedEnvelope, type DiscountRuleUsageLimitReached, type DiscountRulesQueryBuilder, type DiscountRulesQueryResult, type DiscountSettings, type DiscountTrigger, type DiscountTriggerTriggerOneOf, DiscountType, type DiscountTypeWithLiterals, type Discounts, type DomainEvent, type DomainEventBodyOneOf, EligibilityType, type EligibilityTypeWithLiterals, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type ExtendedFields, type GetAppliedDiscountsRequest, type GetAppliedDiscountsResponse, type GetDiscountRuleRequest, type GetDiscountRuleResponse, type IdentificationData, type IdentificationDataIdOneOf, type IndividualMembers, type ItemQuantityRange, type LineItem, type MessageEnvelope, type MultiCurrencyPrice, type Or, type PlatformPaging, type PlatformPagingMetadata, type PlatformQuery, type PlatformQueryPagingMethodOneOf, type QuantityBased, type QueryDiscountRulesRequest, type QueryDiscountRulesResponse, type Recurrence, type RestoreInfo, type Scope, type ScopeScopeItemsOneOf, ScopeType, type ScopeTypeWithLiterals, type ShippingInfo, SortOrder, type SortOrderWithLiterals, type Sorting, type SpecificItemsInfo, Status, type StatusWithLiterals, type SubtotalRange, type TagReference, type TimeOfDay, type TimeWindow, TriggerType, type TriggerTypeWithLiterals, Type, type TypeWithLiterals, type UpdateDiscountRule, type UpdateDiscountRuleRequest, type UpdateDiscountRuleResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, type WeeklySchedule, createDiscountRule, deleteDiscountRule, getDiscountRule, onDiscountRuleCreated, onDiscountRuleDeleted, onDiscountRuleUpdated, queryDiscountRules, typedQueryDiscountRules, updateDiscountRule };
