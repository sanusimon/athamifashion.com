import { NonNullablePaths } from '@wix/sdk-types';

interface OrderTransactions {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Record of payments made to the merchant.
     * @maxSize 100
     */
    payments?: Payment[];
    /**
     * Record of refunds made to the buyer.
     * @maxSize 300
     */
    refunds?: Refund[];
}
interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Receipt created by Wix
     * @internal
     */
    wixReceipt?: WixReceiptInfo;
    /**
     * Receipt created by an external system.
     * @internal
     */
    externalReceipt?: ExternalReceiptInfo;
    /**
     * Payment ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
    /**
     * Whether receipt generation for this payment are allowed.
     * + `true`: This payment supports receipt generation.
     * + `false`: This payment not supports receipt generation, or receipt already generated
     * @internal
     * @readonly
     */
    supportReceiptGeneration?: boolean;
}
/** @oneof */
interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
interface PaymentReceiptInfoOneOf {
    /**
     * Receipt created by Wix
     * @internal
     */
    wixReceipt?: WixReceiptInfo;
    /**
     * Receipt created by an external system.
     * @internal
     */
    externalReceipt?: ExternalReceiptInfo;
}
interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Credit card details. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Wix Payments order ID.
     * @maxLength 100
     */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID.
     * This field is only returned when the value of `offline_payment` is `false`.
     * @maxLength 100
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 100
     */
    paymentMethod?: string | null;
    /**
     * Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments.
     * @maxLength 100
     */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
    /**
     * Whether there is a payment agreement that allows for future charges.
     * @immutable
     */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
    /**
     * Payment service provider display name. Non-exhaustive list of supported values: Wix Payments, PayPal, Square, Stripe, etc.
     * @internal
     * @maxLength 300
     */
    paymentProvider?: string | null;
    /**
     * Record of chargebacks made by the buyer.
     * @maxSize 6
     */
    chargebacks?: Chargeback[];
    /**
     * Payment method ID.
     * @internal
     * @maxLength 36
     */
    paymentMethodId?: string | null;
    /**
     * Platform fee amount.
     * @internal
     */
    platformFee?: Price;
}
/** @oneof */
interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Credit card details. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
/** @enumType */
type TransactionStatusWithLiterals = TransactionStatus | 'UNDEFINED' | 'APPROVED' | 'PENDING' | 'PENDING_MERCHANT' | 'CANCELED' | 'DECLINED' | 'REFUNDED' | 'PARTIALLY_REFUNDED' | 'AUTHORIZED' | 'VOIDED';
interface CreditCardPaymentMethodDetails {
    /**
     * The last 4 digits of the card number.
     * @maxLength 4
     */
    lastFourDigits?: string | null;
    /**
     * Card issuer's brand.
     * @maxLength 100
     */
    brand?: string | null;
}
interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     * @maxSize 1
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: ScheduledAction;
}
interface AuthorizationCapture {
    /**
     * Capture ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatusWithLiterals;
    /**
     * Amount of this capture
     * @immutable
     */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    _createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationCaptureStatusWithLiterals = AuthorizationCaptureStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
interface AuthorizationActionFailureDetails {
    /** @maxLength 100 */
    failureCode?: string;
}
interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatusWithLiterals;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: ReasonWithLiterals;
}
declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** @enumType */
type AuthorizationVoidStatusWithLiterals = AuthorizationVoidStatus | 'UNKNOWN_STATUS' | 'PENDING' | 'SUCCEEDED' | 'FAILED';
/** Reason the authorization was voided. */
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'MANUAL' | 'SCHEDULED';
interface ScheduledAction {
    /** Type of the action. */
    actionType?: ActionTypeWithLiterals;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
/** @enumType */
type ActionTypeWithLiterals = ActionType | 'UNKNOWN_ACTION_TYPE' | 'VOID' | 'CAPTURE';
interface Chargeback {
    /**
     * Chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    _id?: string;
    /**
     * Date and time the chargeback was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Date and time the chargeback was updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Amount.
     * @readonly
     * @immutable
     */
    amount?: Price;
    /**
     * Reversal amount. Present only when status is REVERSED.
     * @readonly
     */
    reversalAmount?: Price;
    /**
     * Status.
     *
     * Default: `"APPROVED"`.
     */
    status?: ChargebackStatusWithLiterals;
    /**
     * External chargeback ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    externalId?: string | null;
}
declare enum ChargebackStatus {
    UNSPECIFIED = "UNSPECIFIED",
    /** Chargeback was approved. */
    APPROVED = "APPROVED",
    /** Chargeback was reversed. */
    REVERSED = "REVERSED"
}
/** @enumType */
type ChargebackStatusWithLiterals = ChargebackStatus | 'UNSPECIFIED' | 'APPROVED' | 'REVERSED';
interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @minLength 1
     * @maxLength 100
     */
    giftCardPaymentId?: string;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
    /**
     * Gift card obfuscated code.
     * @internal
     * @maxLength 30
     * @immutable
     */
    obfuscatedCode?: string | null;
}
interface MembershipPaymentDetails {
    /**
     * Membership ID.
     * @minLength 1
     * @maxLength 100
     */
    membershipId?: string;
    /**
     * ID of the line item this membership applies to.
     * @minLength 1
     * @maxLength 100
     */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatusWithLiterals;
    /** Membership name. */
    name?: MembershipName;
    /**
     * The transaction ID in the membership system. Can be used to void the transaction.
     * @minLength 1
     * @maxLength 100
     */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /**
     * ID of the application providing this payment option.
     * @format GUID
     */
    providerAppId?: string;
}
declare enum MembershipPaymentStatus {
    /** Payment was charged. */
    CHARGED = "CHARGED",
    /** The attempt to charge the payment failed, for example, due to lack of credits. */
    CHARGE_FAILED = "CHARGE_FAILED"
}
/** @enumType */
type MembershipPaymentStatusWithLiterals = MembershipPaymentStatus | 'CHARGED' | 'CHARGE_FAILED';
interface MembershipName {
    /**
     * Membership name.
     * @maxLength 100
     */
    original?: string;
    /**
     * Translated membership name. Defaults to `original` when not provided.
     * @maxLength 100
     */
    translated?: string | null;
}
interface WixReceiptInfo {
    /**
     * Receipt ID
     * @format GUID
     */
    receiptId?: string;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface ExternalReceiptInfo {
    /**
     * External receipt ID
     * @maxLength 100
     */
    receiptId?: string | null;
    /**
     * ID of the app providing the receipt
     * @format GUID
     */
    appId?: string | null;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
interface Refund {
    /**
     * Refund ID.
     * @format GUID
     * @readonly
     */
    _id?: string;
    /**
     * List of transactions.
     * @maxSize 50
     */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Aggregated refund summary.
     * @readonly
     */
    summary?: AggregatedRefundSummary;
    /**
     * ID of the app that initiated this refund.
     * @format GUID
     * @readonly
     * @immutable
     */
    requestingServiceAppId?: string | null;
}
interface RefundTransaction {
    /**
     * ID of the payment associated with this refund.
     * @format GUID
     * @immutable
     */
    paymentId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatusWithLiterals;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID.
     * This field is only returned when the value of `external_refund` is `false`.
     * @format GUID
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /**
     * Whether refund was made externally and manually on the payment provider's side.
     * @immutable
     */
    externalRefund?: boolean;
}
/** Refund transaction status. */
declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
/** @enumType */
type RefundStatusWithLiterals = RefundStatus | 'PENDING' | 'SUCCEEDED' | 'FAILED' | 'SCHEDULED' | 'STARTED';
interface RefundStatusInfo {
    /**
     * Reason code for the refund's current status.
     *
     * Learn more about [reason codes](https://dev.wix.com/docs/rest/business-management/payments/service-plugins/payment-service-provider-service-plugin/reason-codes).
     * @minLength 1
     * @maxLength 10
     */
    paymentGatewayReasonCode?: string | null;
    /**
     * Free text explanation of current refund status.
     * @minLength 1
     * @maxLength 1000
     */
    description?: string | null;
}
/** Business model of a refund request */
interface RefundDetails {
    /**
     * Order line item IDs and quantities that were refunded.
     * @maxSize 300
     */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /**
     * Reason for the refund, provided by customer (optional).
     * @maxLength 200
     */
    reason?: string | null;
    /**
     * Line items that were refunded.
     * @maxSize 300
     */
    lineItems?: LineItemRefund[];
    /**
     * Additional fees that were refunded.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefund[];
    /** Shipping amount that was refunded. */
    shipping?: ShippingRefund;
}
interface RefundItem {
    /**
     * Line item ID the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity refunded.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     * @immutable
     */
    lineItemId?: string;
    /**
     * Refund quantity.
     * @min 1
     * @max 100000
     * @immutable
     */
    quantity?: number;
}
interface AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     * @immutable
     */
    additionalFeeId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface ShippingRefund {
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
interface AggregatedRefundSummary {
    /** Total amount requested for refund. */
    requestedRefund?: Price;
    /** Pending refund amount - the portion of `requestedRefund` that is still pending. */
    pendingRefund?: Price;
    /** Refunded amount - the portion of `requestedRefund` that refunded successfully. */
    refunded?: Price;
    /** Failed refund amount - the portion of `requestedRefund` that failed. */
    failedRefundAmount?: Price;
    /** Whether at least one refund transaction is still in `"PENDING"` status. */
    pending?: boolean;
    /** Breakdown of refunded items. Available only after refund is complete. */
    breakdown?: RefundItemsBreakdown;
}
interface RefundItemsBreakdown {
    /**
     * Refunded line items and the amount refunded for each.
     * @maxSize 300
     */
    lineItems?: LineItemRefundSummary[];
}
interface LineItemRefundSummary {
    /**
     * ID of the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /** Total refunded amount for the line item. */
    totalRefundedAmount?: Price;
}
/** Triggered when a payment is updated. */
interface PaymentsUpdated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /**
     * List of IDs of the updated payments.
     * @maxSize 100
     */
    paymentIds?: string[];
    /**
     * List of IDs of the updated refunds.
     * @maxSize 300
     */
    refundIds?: string[];
}
/** Triggered when a payment is updated. */
interface PaymentDetailsUpdated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /**
     * List of IDs of the updated payments.
     * @format GUID
     * @maxSize 100
     */
    paymentIds?: string[];
    /**
     * List of IDs of the updated refunds.
     * @format GUID
     * @maxSize 300
     */
    refundIds?: string[];
}
/** Triggered when a refund is created. */
interface RefundCreated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /** ID of the created refund. */
    refundId?: string;
    /** Inventory restock details as part of this refund.. */
    restockInfo?: RestockInfo;
    /** Whether to send a refund confirmation email to the customer. */
    sendOrderRefundedEmail?: boolean;
    /** Custom message added to the refund confirmation email. */
    customMessage?: string | null;
    /** Refunded line items and quantities that are part of the created refund. */
    refundItems?: RefundItem[];
}
interface RestockInfo {
    /** Restock type. */
    type?: RestockTypeWithLiterals;
    /**
     * Restocked line items and quantities. Only relevant for `{"type": "SOME_ITEMS"}`.
     * @maxSize 300
     */
    items?: RestockItem[];
}
declare enum RestockType {
    NO_ITEMS = "NO_ITEMS",
    ALL_ITEMS = "ALL_ITEMS",
    SOME_ITEMS = "SOME_ITEMS"
}
/** @enumType */
type RestockTypeWithLiterals = RestockType | 'NO_ITEMS' | 'ALL_ITEMS' | 'SOME_ITEMS';
interface RestockItem {
    /**
     * ID of the line item being restocked.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity being restocked.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
interface RefundCompleted {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /** Completed refund. */
    refund?: Refund;
    /** Refund side effects. */
    sideEffects?: RefundSideEffects;
    /** Order transactions after refund is completed. */
    orderTransactions?: OrderTransactions;
}
interface RefundSideEffects {
    /** Inventory restock details as part of this refund. */
    restockInfo?: RestockInfo;
    /** Whether to send a refund confirmation email to the customer. */
    sendOrderRefundedEmail?: boolean;
    /**
     * Custom message added to the refund confirmation email.
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
interface ChargebackApproved {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /** Approved chargeback. */
    chargeback?: Chargeback;
    /** Order transactions after chargeback is approved. */
    orderTransactions?: OrderTransactions;
}
interface ChargebackReversed {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /** Reversed chargeback. */
    chargeback?: Chargeback;
    /** Order transactions after chargeback is reversed. */
    orderTransactions?: OrderTransactions;
}
interface ListTransactionsForSingleOrderRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId: string;
}
interface ListTransactionsForSingleOrderResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
}
interface ListTransactionsForMultipleOrdersRequest {
    /**
     * Order IDs for which to retrieve transactions.
     * @minSize 1
     * @maxSize 100
     * @minLength 1
     * @maxLength 100
     */
    orderIds: string[];
}
interface ListTransactionsForMultipleOrdersResponse {
    /** List of order IDs and their associated transactions. */
    orderTransactions?: OrderTransactions[];
}
interface AddPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * Payments to be added to order.
     * @minSize 1
     * @maxSize 50
     */
    payments: Payment[];
}
interface AddPaymentsResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
    /** IDs of added order payments. */
    paymentsIds?: string[];
}
interface AddRefundRequest {
    /**
     * Order ID this refunds related to
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
    /** Refund with refund transactions to be added to order. */
    refund?: Refund;
    /** Side effect details related to refund */
    sideEffects?: RefundSideEffects;
}
interface AddRefundResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
    /** Created refund ID */
    refundId?: string;
}
interface UpdatePaymentStatusRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId: string;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
}
interface UpdatePaymentStatusResponse {
    /** Order ID and its associated transactions after update. */
    orderTransactions?: OrderTransactions;
}
interface BulkUpdatePaymentStatusesRequest {
    /**
     * Order and payment IDs for which to update payment status.
     * @minSize 1
     * @maxSize 300
     */
    paymentAndOrderIds: PaymentAndOrderId[];
    /** Whether to return the full payment entity (`results.item`) in the response. */
    returnFullEntity?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
}
interface PaymentAndOrderId {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * todo: remove comment once UI will use BulkMarkOrderAsPaid
     */
    paymentId?: string;
}
interface BulkUpdatePaymentStatusesResponse {
    /** Bulk operation results. */
    results?: BulkPaymentResult[];
    /** Bulk operation metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkPaymentResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Updated payment. Returned if `return_full_entity` set to `true`. */
    item?: Payment;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateRefundRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /** Refund with updated field values. */
    refund?: Refund;
}
interface UpdateRefundResponse {
    /** Refund after update. */
    refund?: Refund;
    /** Order transactions after update. */
    orderTransactions?: OrderTransactions;
}
interface UpdateRefundTransactionRequest {
    /**
     * Order ID.
     * @internal
     * @format GUID
     */
    orderId: string;
    /**
     * Payment ID.
     * @internal
     * @format GUID
     */
    refundId: string;
    /**
     * Updated refund transaction
     * @internal
     */
    transaction: RefundTransaction;
}
interface UpdateRefundTransactionResponse {
    /**
     * OrderTransactions with updated refund transaction
     * @internal
     */
    orderTransactions?: OrderTransactions;
}
interface UpdatePaymentsRequest {
}
interface MaskedPayment {
}
interface UpdatePaymentsResponse {
    /**
     * OrderTransactions with updated payments
     * @internal
     */
    orderTransactions?: OrderTransactions;
}
interface QueryOrderTransactionsRequest {
    /**
     * Query options.
     * @internal
     */
    query?: CursorQuery;
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     * @maxSize 5
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    /** Ascending order. */
    ASC = "ASC",
    /** Descending order. */
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryOrderTransactionsResponse {
    /**
     * Order transactions.
     * @internal
     * @maxSize 100
     */
    orderTransactions?: OrderTransactions[];
    /**
     * Details on the paged set of results returned.
     * @internal
     */
    metadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface AddChargebackRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /** Chargeback. */
    chargeback?: Chargeback;
}
interface AddChargebackResponse {
    /** Chargeback. */
    chargeback?: Chargeback;
    /**
     * Payment ID of a payment which received chargeback.
     * @format GUID
     */
    paymentId?: string;
    /** Order transactions. */
    orderTransactions?: OrderTransactions;
}
interface ReverseChargebackRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Chargeback ID.
     * @format GUID
     */
    chargebackId?: string;
    /**
     * Reversal amount.
     *
     * Default: original chargeback amount.
     */
    reversalAmount?: Price;
}
interface ReverseChargebackResponse {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
}
interface TriggerRefundRequest {
    /**
     * The order this refund related to
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
    /**
     * Refund operations information
     * Currently, only *one* payment refund is supported per request
     * @minSize 1
     * @maxSize 1
     */
    payments?: PaymentRefund[];
    /** Business model of a refund */
    details?: RefundDetails;
    /** How to restock items as part of this refund */
    restockInfo?: RestockInfo;
    /** Should send a confirmation mail to the customer */
    sendOrderRefundedEmail?: boolean;
    /**
     * Personal note added to the email
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
interface PaymentRefund {
    /**
     * Specific payment within the order to refund
     * @format GUID
     */
    paymentId?: string;
    /** Refund amount. Not relevant for membership and gift card refunds. */
    amount?: Price;
    /**
     * Whether refund is made externally and manually (on the payment provider's side)
     * When false (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * When true, the payment will only be *marked* as refunded, and no actual refund will be performed.
     */
    externalRefund?: boolean;
}
interface TriggerRefundResponse {
    /** All order's transactions after the refunds were added */
    orderTransactions?: OrderTransactions;
    /** Created refund ID */
    refundId?: string;
}
interface CalculateRefundRequest {
    /**
     * Order ID
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
    /**
     * Refunded line items and quantity
     * @maxSize 300
     */
    refundItems?: CalculateRefundItemRequest[];
    /** Should include shipping in refund calculation */
    refundShipping?: boolean;
}
interface CalculateRefundItemRequest {
    /**
     * ID of the line item being refunded
     * @format GUID
     */
    lineItemId?: string;
    /**
     * How much of that line item is being refunded
     * @min 1
     * @max 100000
     */
    quantity?: number;
    /** Should this item be restocked (used for validation purposes) */
    restock?: boolean;
}
interface CalculateRefundResponse {
    /**
     * Total refundable amount
     * @format DECIMAL_VALUE
     */
    total?: string;
    /**
     * Tax cost of the order
     * @format DECIMAL_VALUE
     */
    tax?: string;
    /**
     * Discount given for this order
     * @format DECIMAL_VALUE
     */
    discount?: string;
    /**
     * Total cost of the order (without tax)
     * @format DECIMAL_VALUE
     */
    subtotal?: string;
    /**
     * Previous refund given on that order
     * @format DECIMAL_VALUE
     */
    previouslyRefundedAmount?: string | null;
    /** The refundable items of that order */
    items?: CalculateRefundItemResponse[];
}
interface CalculateRefundItemResponse {
    /** Line item ID */
    lineItemId?: string;
    /** The line item's price */
    lineItemPrice?: number;
}
interface GetRefundabilityStatusRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
}
interface GetRefundabilityStatusResponse {
    /**
     * Refundability details.
     * @maxSize 1
     */
    refundabilities?: Refundability[];
    /** Whether the order supports refunding per item. */
    refundablePerItem?: boolean;
}
interface Refundability extends RefundabilityAdditionalRefundabilityInfoOneOf {
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReasonWithLiterals;
    /** Reason why payment is only refundable manually. */
    manuallyRefundableReason?: ManuallyRefundableReasonWithLiterals;
    /** Payment ID. */
    paymentId?: string;
    /** Payment refundability status. */
    refundabilityStatus?: RefundableStatusWithLiterals;
    /** Link to payment provider dashboard. */
    providerLink?: string | null;
}
/** @oneof */
interface RefundabilityAdditionalRefundabilityInfoOneOf {
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReasonWithLiterals;
    /** Reason why payment is only refundable manually. */
    manuallyRefundableReason?: ManuallyRefundableReasonWithLiterals;
}
declare enum RefundableStatus {
    /** Not refundable. */
    NOT_REFUNDABLE = "NOT_REFUNDABLE",
    /** Refundable manually. */
    MANUAL = "MANUAL",
    /** Refundable. */
    REFUNDABLE = "REFUNDABLE"
}
/** @enumType */
type RefundableStatusWithLiterals = RefundableStatus | 'NOT_REFUNDABLE' | 'MANUAL' | 'REFUNDABLE';
declare enum NonRefundableReason {
    /** No reason. */
    NONE = "NONE",
    /** Payment already refunded. */
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    /** Payment provider is down. */
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    /** Internal error occurred. */
    INTERNAL_ERROR = "INTERNAL_ERROR",
    /** Payment not made. */
    NOT_PAID = "NOT_PAID",
    /** Access denied. */
    ACCESS_DENIED = "ACCESS_DENIED",
    /** Payment amount is zero. */
    ZERO_PRICE = "ZERO_PRICE",
    /** Disabled by provider. */
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    /** Payment partially paid. */
    PARTIALLY_PAID = "PARTIALLY_PAID",
    /** Deposit for online item. */
    DEPOSIT_ONLINE_ITEM = "DEPOSIT_ONLINE_ITEM",
    /** Refund is pending. */
    PENDING_REFUND = "PENDING_REFUND",
    /** Action forbidden. */
    FORBIDDEN = "FORBIDDEN"
}
/** @enumType */
type NonRefundableReasonWithLiterals = NonRefundableReason | 'NONE' | 'ALREADY_REFUNDED' | 'PROVIDER_IS_DOWN' | 'INTERNAL_ERROR' | 'NOT_PAID' | 'ACCESS_DENIED' | 'ZERO_PRICE' | 'DISABLED_BY_PROVIDER' | 'PARTIALLY_PAID' | 'DEPOSIT_ONLINE_ITEM' | 'PENDING_REFUND' | 'FORBIDDEN';
declare enum ManuallyRefundableReason {
    /** Payment expired. */
    EXPIRED = "EXPIRED",
    /** Payment method not supported. */
    NOT_SUPPORTED = "NOT_SUPPORTED",
    /** Payment not found. */
    NOT_FOUND = "NOT_FOUND",
    /** Payment made offline. */
    OFFLINE = "OFFLINE",
    /** Refund requires interaction with card reader. */
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
/** @enumType */
type ManuallyRefundableReasonWithLiterals = ManuallyRefundableReason | 'EXPIRED' | 'NOT_SUPPORTED' | 'NOT_FOUND' | 'OFFLINE' | 'REQUIRES_CARD_READER';
interface ListInvoicesForSingleOrderRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
}
interface ListInvoicesForSingleOrderResponse {
    /** List of invoices. */
    invoices?: InvoiceInfo[];
}
interface InvoiceInfo {
    /** Invoice ID. */
    _id?: string;
    /** ID of the app that set the invoice. */
    appId?: string;
    /**
     * Invoice URL.
     * @deprecated
     */
    url?: string | null;
    /**
     * Invoice creation date and time.
     * @deprecated
     */
    _createdDate?: Date | null;
}
interface ListInvoicesForMultipleOrdersRequest {
    /**
     * Order IDs for which to retrieve invoices.
     * @maxSize 300
     * @minLength 1
     * @maxLength 100
     */
    orderIds?: string[];
}
interface ListInvoicesForMultipleOrdersResponse {
    /** List of order IDs and their associated invoices. */
    invoicesForOrder?: InvoicesForOrder[];
}
interface InvoicesForOrder {
    /** Order ID. */
    orderId?: string;
    /** Invoices info. */
    invoicesInfo?: InvoiceInfo[];
}
interface GenerateInvoiceRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
}
interface GenerateInvoiceResponse {
    /** Invoice ID. */
    invoiceId?: string;
}
interface BulkGenerateInvoicesRequest {
    /**
     * Order IDs.
     * @minSize 1
     * @maxSize 100
     * @minLength 1
     * @maxLength 100
     */
    orderIds?: string[];
}
interface BulkGenerateInvoicesResponse {
    results?: BulkInvoiceResult[];
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkInvoiceResult {
    itemMetadata?: ItemMetadata;
    item?: InvoiceForOrder;
}
interface InvoiceForOrder {
    /** Order ID. */
    orderId?: string;
    /** Invoice ID. */
    invoiceId?: string;
}
interface AddInvoiceToOrderRequest {
    /**
     * Order ID.
     * @minLength 1
     * @maxLength 100
     */
    orderId?: string;
    /** Invoice info. */
    invoiceInfo?: InvoiceInfo;
}
interface AddInvoiceToOrderResponse {
    /** List of order invoices. */
    orderInvoices?: InvoiceInfo[];
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type UpdateRefundTransactionApplicationErrors = {
    code?: 'ORDER_TRANSACTIONS_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'REFUND_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'REFUND_TRANSACTION_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type UpdatePaymentsApplicationErrors = {
    code?: 'ORDER_TRANSACTIONS_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PAYMENT_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface OrderTransactionsChargebackApprovedEnvelope {
    data: ChargebackApproved;
    metadata: EventMetadata;
}
/**
 * Triggered when a new chargeback is added to an order.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_TRANSACTIONS
 * @webhook
 * @eventType wix.ecom.v1.order_transactions_chargeback_approved
 * @slug chargeback_approved
 */
declare function onOrderTransactionsChargebackApproved(handler: (event: OrderTransactionsChargebackApprovedEnvelope) => void | Promise<void>): void;
interface OrderTransactionsChargebackReversedEnvelope {
    data: ChargebackReversed;
    metadata: EventMetadata;
}
/**
 * Triggered when an existing chargeback is reversed.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_TRANSACTIONS
 * @webhook
 * @eventType wix.ecom.v1.order_transactions_chargeback_reversed
 * @slug chargeback_reversed
 */
declare function onOrderTransactionsChargebackReversed(handler: (event: OrderTransactionsChargebackReversedEnvelope) => void | Promise<void>): void;
interface OrderTransactionsDetailsUpdatedEnvelope {
    data: PaymentDetailsUpdated;
    metadata: EventMetadata;
}
/**
 * Triggered when a payment or refund is added to an order, or when an existing payment is updated.
 *
 * Contains the ID of the updated order and details of its associated transactions,
 * as well as IDs of the updated payments and refunds.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_TRANSACTIONS
 * @webhook
 * @eventType wix.ecom.v1.order_transactions_details_updated
 * @slug details_updated
 */
declare function onOrderTransactionsDetailsUpdated(handler: (event: OrderTransactionsDetailsUpdatedEnvelope) => void | Promise<void>): void;
interface OrderTransactionsRefundCompletedEnvelope {
    data: RefundCompleted;
    metadata: EventMetadata;
}
/**
 * Triggered when a refund has been fully processed and completed.
 *
 * This event is fired once when all refund transactions within a refund have reached
 * their final state (either `SUCCEEDED` or `FAILED`). Contains the order ID, completed
 * refund details, any side effects (such as inventory restocking or email notifications),
 * and the updated order transaction state.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_TRANSACTIONS
 * @webhook
 * @eventType wix.ecom.v1.order_transactions_refund_completed
 * @slug refund_completed
 */
declare function onOrderTransactionsRefundCompleted(handler: (event: OrderTransactionsRefundCompletedEnvelope) => void | Promise<void>): void;
interface OrderTransactionsUpdatedEnvelope {
    data: PaymentsUpdated;
    metadata: EventMetadata;
}
/**
 * Triggered when a payment or refund is added to an order, or when an existing payment is updated.
 *
 * Contains the ID of the updated order and details of its associated transactions,
 * as well as IDs of the updated payments and refunds.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_TRANSACTIONS
 * @webhook
 * @eventType wix.ecom.v1.order_transactions_updated
 * @slug updated
 * @deprecated
 * @replacedBy com.wix.ecom.orders.payments.v1.Payments.details_updated
 * @targetRemovalDate 2025-11-30
 */
declare function onOrderTransactionsUpdated(handler: (event: OrderTransactionsUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Retrieves information about payments and refunds associated with a specified order.
 *
 *
 * The `listTransactionsForSingleOrder()` function returns a Promise that resolves when the specified order's transaction records are retrieved.
 * @param orderId - Order ID.
 * @public
 * @requiredField orderId
 * @permissionId ECOM.READ_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.ListTransactionsForSingleOrder
 */
declare function listTransactionsForSingleOrder(orderId: string): Promise<NonNullablePaths<ListTransactionsForSingleOrderResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7>>;
/**
 * Retrieves information about payments and refunds associated with all specified orders.
 *
 *
 * The `listTransactionsForMultipleOrders()` function returns a Promise that resolves when the specified orders' transaction records are retrieved.
 * @param orderIds - Order IDs for which to retrieve transactions.
 * @public
 * @requiredField orderIds
 * @permissionId ECOM.READ_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.ListTransactionsForMultipleOrders
 */
declare function listTransactionsForMultipleOrders(orderIds: string[]): Promise<NonNullablePaths<ListTransactionsForMultipleOrdersResponse, `orderTransactions` | `orderTransactions.${number}.orderId`, 4>>;
/**
 * Adds up to 50 payment records to an order.
 *
 *
 * The `addPayments()` function returns a Promise that resolves when the payment records are added to an order.
 *
 * > **Note:** This does **NOT** perform the actual charging - the order is only updated with records of the payments.
 * @param orderId - Order ID.
 * @param payments - Payments to be added to order.
 * @public
 * @requiredField orderId
 * @requiredField payments
 * @requiredField payments.amount
 * @requiredField payments.paymentDetails
 * @requiredField payments.paymentDetails.giftcardPaymentDetails.giftCardPaymentId
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.AddPayments
 */
declare function addPayments(orderId: string, payments: NonNullablePaths<Payment, `amount` | `giftcardPaymentDetails.giftCardPaymentId`, 3>[]): Promise<NonNullablePaths<AddPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending` | `paymentsIds`, 7>>;
/**
 * Updates the status of an order's payment.
 *
 *
 * The `updatePaymentStatus()` function returns a Promise that resolves when the payment status is updated.
 * @public
 * @requiredField identifiers
 * @requiredField identifiers.orderId
 * @requiredField identifiers.paymentId
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.UpdatePaymentStatus
 */
declare function updatePaymentStatus(identifiers: NonNullablePaths<UpdatePaymentStatusIdentifiers, `orderId` | `paymentId`, 2>, options?: UpdatePaymentStatusOptions): Promise<NonNullablePaths<UpdatePaymentStatusResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.amount.amount` | `orderTransactions.payments.${number}.amount.formattedAmount` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`, 7>>;
interface UpdatePaymentStatusIdentifiers {
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId: string;
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
}
interface UpdatePaymentStatusOptions {
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
}
/**
 * Updates multiple order payments with a specified status.
 *
 *
 * The `bulkUpdatePaymentStatus()` function returns a Promise that resolves when the payment statuses are updated.
 * @param paymentAndOrderIds - Order and payment IDs for which to update payment status.
 * @public
 * @requiredField paymentAndOrderIds
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.BulkUpdatePaymentStatuses
 */
declare function bulkUpdatePaymentStatuses(paymentAndOrderIds: PaymentAndOrderId[], options?: BulkUpdatePaymentStatusesOptions): Promise<NonNullablePaths<BulkUpdatePaymentStatusesResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.regularPaymentDetails.offlinePayment` | `results.${number}.item.regularPaymentDetails.status` | `results.${number}.item.regularPaymentDetails.savedPaymentMethod` | `results.${number}.item.giftcardPaymentDetails.giftCardPaymentId` | `results.${number}.item.giftcardPaymentDetails.appId` | `results.${number}.item.giftcardPaymentDetails.voided` | `results.${number}.item.amount.amount` | `results.${number}.item.amount.formattedAmount` | `results.${number}.item.refundDisabled` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkUpdatePaymentStatusesOptions {
    /** Whether to return the full payment entity (`results.item`) in the response. */
    returnFullEntity?: boolean;
    /** Payment status. */
    status?: TransactionStatusWithLiterals;
}
/**
 * Updates OrderTransactions.refunds.transactions properties
 * @param orderId - Order ID.
 * @param refundId - Payment ID.
 * @internal
 * @documentationMaturity preview
 * @requiredField orderId
 * @requiredField refundId
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.UpdateRefundTransaction
 */
declare function updateRefundTransaction(orderId: string, refundId: string, options?: UpdateRefundTransactionOptions): Promise<void & {
    __applicationErrorsType?: UpdateRefundTransactionApplicationErrors;
}>;
interface UpdateRefundTransactionOptions {
    /**
     * Updated refund transaction
     * @internal
     */
    transaction: RefundTransaction;
}
/**
 * Updates properties of payments associated to order.
 *
 * Currently, the following fields can be updated:
 * + `payment.payment_details.regular_payment_details.provider_transaction_id`
 * + `payment.payment_details.regular_payment_details.status`
 * + `payment.payment_details.regular_payment_details.payment_method_details.credit_card_details`
 * + `payment.payment_details.regular_payment_details.authorization_details`
 * + `payment.payment_details.regular_payment_details.authorization_details.scheduled_action`
 * + `payment.payment_details.regular_payment_details.authorization_details.authorized_date`
 * + `payment.payment_details.regular_payment_details.authorization_details.captures`
 * + `payment.payment_details.regular_payment_details.authorization_details.captures.status`
 * + `payment.payment_details.regular_payment_details.authorization_details.captures.created_date`
 * + `payment.payment_details.regular_payment_details.authorization_details.captures.failure_details`
 * + `payment.payment_details.regular_payment_details.authorization_details.void`
 * + `payment.payment_details.regular_payment_details.authorization_details.void.status`
 * + `payment.payment_details.regular_payment_details.authorization_details.void.voided_date`
 * + `payment.payment_details.regular_payment_details.authorization_details.void.reason`
 * + `payment.payment_details.regular_payment_details.authorization_details.void.failure_details`
 * + `payment.receipt_info`
 * + `payment.receipt_info.wix_receipt`
 * + `payment.receipt_info.wix_receipt.receipt_id`
 * + `payment.receipt_info.wix_receipt.display_number`
 * + `payment.receipt_info.external_receipt`
 * + `payment.receipt_info.external_receipt.receipt_id`
 * + `payment.receipt_info.external_receipt.display_number`
 * + `payment.receipt_info.external_receipt.app_id`
 *
 * To update a field's value, include the new value in the `payment` object in the body params.
 *
 * > **Note:** Removing fields value results in an error.
 * @internal
 * @documentationMaturity preview
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.UpdatePayments
 */
declare function updatePayments(): Promise<void & {
    __applicationErrorsType?: UpdatePaymentsApplicationErrors;
}>;

export { type ActionEvent, ActionType, type ActionTypeWithLiterals, type AddChargebackRequest, type AddChargebackResponse, type AddInvoiceToOrderRequest, type AddInvoiceToOrderResponse, type AddPaymentsRequest, type AddPaymentsResponse, type AddRefundRequest, type AddRefundResponse, type AdditionalFeeRefund, type AggregatedRefundSummary, type ApplicationError, type AuthorizationActionFailureDetails, type AuthorizationCapture, AuthorizationCaptureStatus, type AuthorizationCaptureStatusWithLiterals, type AuthorizationDetails, type AuthorizationVoid, AuthorizationVoidStatus, type AuthorizationVoidStatusWithLiterals, type BaseEventMetadata, type BulkActionMetadata, type BulkGenerateInvoicesRequest, type BulkGenerateInvoicesResponse, type BulkInvoiceResult, type BulkPaymentResult, type BulkUpdatePaymentStatusesOptions, type BulkUpdatePaymentStatusesRequest, type BulkUpdatePaymentStatusesResponse, type CalculateRefundItemRequest, type CalculateRefundItemResponse, type CalculateRefundRequest, type CalculateRefundResponse, type Chargeback, type ChargebackApproved, type ChargebackReversed, ChargebackStatus, type ChargebackStatusWithLiterals, type CreditCardPaymentMethodDetails, type CursorPaging, type CursorPagingMetadata, type CursorQuery, type CursorQueryPagingMethodOneOf, type Cursors, type DomainEvent, type DomainEventBodyOneOf, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type ExternalReceiptInfo, type GenerateInvoiceRequest, type GenerateInvoiceResponse, type GetRefundabilityStatusRequest, type GetRefundabilityStatusResponse, type GiftCardPaymentDetails, type IdentificationData, type IdentificationDataIdOneOf, type InvoiceForOrder, type InvoiceInfo, type InvoicesForOrder, type ItemMetadata, type LineItemRefund, type LineItemRefundSummary, type ListInvoicesForMultipleOrdersRequest, type ListInvoicesForMultipleOrdersResponse, type ListInvoicesForSingleOrderRequest, type ListInvoicesForSingleOrderResponse, type ListTransactionsForMultipleOrdersRequest, type ListTransactionsForMultipleOrdersResponse, type ListTransactionsForSingleOrderRequest, type ListTransactionsForSingleOrderResponse, ManuallyRefundableReason, type ManuallyRefundableReasonWithLiterals, type MaskedPayment, type MembershipName, type MembershipPaymentDetails, MembershipPaymentStatus, type MembershipPaymentStatusWithLiterals, type MessageEnvelope, NonRefundableReason, type NonRefundableReasonWithLiterals, type OrderTransactions, type OrderTransactionsChargebackApprovedEnvelope, type OrderTransactionsChargebackReversedEnvelope, type OrderTransactionsDetailsUpdatedEnvelope, type OrderTransactionsRefundCompletedEnvelope, type OrderTransactionsUpdatedEnvelope, type Payment, type PaymentAndOrderId, type PaymentDetailsUpdated, type PaymentPaymentDetailsOneOf, type PaymentReceiptInfoOneOf, type PaymentRefund, type PaymentsUpdated, type Price, type QueryOrderTransactionsRequest, type QueryOrderTransactionsResponse, Reason, type ReasonWithLiterals, type Refund, type RefundCompleted, type RefundCreated, type RefundDetails, type RefundItem, type RefundItemsBreakdown, type RefundSideEffects, RefundStatus, type RefundStatusInfo, type RefundStatusWithLiterals, type RefundTransaction, type Refundability, type RefundabilityAdditionalRefundabilityInfoOneOf, RefundableStatus, type RefundableStatusWithLiterals, type RegularPaymentDetails, type RegularPaymentDetailsPaymentMethodDetailsOneOf, type RestockInfo, type RestockItem, RestockType, type RestockTypeWithLiterals, type RestoreInfo, type ReverseChargebackRequest, type ReverseChargebackResponse, type ScheduledAction, type ShippingRefund, SortOrder, type SortOrderWithLiterals, type Sorting, TransactionStatus, type TransactionStatusWithLiterals, type TriggerRefundRequest, type TriggerRefundResponse, type UpdatePaymentStatusIdentifiers, type UpdatePaymentStatusOptions, type UpdatePaymentStatusRequest, type UpdatePaymentStatusResponse, type UpdatePaymentsApplicationErrors, type UpdatePaymentsRequest, type UpdatePaymentsResponse, type UpdateRefundRequest, type UpdateRefundResponse, type UpdateRefundTransactionApplicationErrors, type UpdateRefundTransactionOptions, type UpdateRefundTransactionRequest, type UpdateRefundTransactionResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, type WixReceiptInfo, addPayments, bulkUpdatePaymentStatuses, listTransactionsForMultipleOrders, listTransactionsForSingleOrder, onOrderTransactionsChargebackApproved, onOrderTransactionsChargebackReversed, onOrderTransactionsDetailsUpdated, onOrderTransactionsRefundCompleted, onOrderTransactionsUpdated, updatePaymentStatus, updatePayments, updateRefundTransaction };
