import { MonitoringClient } from '@wix/monitoring-types';
import { PlatformShowError } from '@wix/error-handler-types/v2';
export { ErrorCodesMap, ErrorHandlerPublicAPI as ErrorHandler, ResolvedError, ShowErrorMapFunction, ShowErrorProps, StatusCodeMap } from '@wix/error-handler-types/v2';
import { ConditionalExcept, EmptyObject, Simplify, Paths, SetRequiredDeep, JsonObject } from 'type-fest';
export { ErrorHandlerInternalAPI as WixClientErrorHandler } from '@wix/error-handler-types';

type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel?: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Optional function to get a monitoring client
     */
    getMonitoringClient?: () => MonitoringClient;
    /**
     * Optional function to display an error notification to the user.
     * Can be used to show a toast, modal, or any other UI element
     * that informs the user about an error that occurred.
     */
    showError?: PlatformShowError;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * The timezone of the currently viewed session
         */
        timezone?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type HTTPMethod = 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type ResponseTransformer$1 = (data: any) => any;
type RequestOptions<_TResponse = any, Data = any> = {
    method: HTTPMethod;
    url: string;
    data?: Data;
    params?: URLSearchParams;
    fallback?: RequestOptions<any, any>[];
    /**
     * The array option is for interoperability, defacto only the first function is used
     * if an array is provided
     */
    transformResponse?: ResponseTransformer$1 | ResponseTransformer$1[];
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
    migrationOptions?: MigrationOptions;
};
type MigrationOptions = {
    optInTransformResponse?: boolean;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type RestModuleMeta<TMethod extends HTTPMethod = HTTPMethod, TPathParams = unknown, RequestType = unknown, TOriginalRequestType = unknown, ResponseType = unknown, OriginalResponseType = unknown> = {
    getUrl(context: {
        host: string;
    }): string;
    httpMethod: TMethod;
    pathParams: TPathParams;
    path: string;
    __requestType: RequestType;
    __originalRequestType: TOriginalRequestType;
    __responseType: ResponseType;
    __originalResponseType: OriginalResponseType;
};

type AuthenticationStrategy<Host = unknown> = {
    getAuthHeaders: (host: Host) => Promise<{
        headers: Record<string, string>;
    }> | {
        headers: Record<string, string>;
    };
    decodeJWT?: (token: string, verifyCallerClaims?: boolean) => Promise<{
        decoded: {
            data: unknown;
        };
        valid: boolean;
    }>;
    /**
     * This function is used to get the token that is currently active in the context of the strategy.
     * This is useful when direct access to the access token is needed
     * (such as getTokenInfo that requires the token in the body of the request).
     * @returns the token that is currently active in the context of the strategy
     */
    getActiveToken?: () => string | undefined;
    shouldUseCDN?: boolean;
};
type BoundAuthenticationStrategy = {
    getAuthHeaders: () => Promise<{
        headers: Record<string, string>;
    }> | {
        headers: Record<string, string>;
    };
};

type EventIdentity = {
    identityType: 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
    anonymousVisitorId: string;
    memberId: string;
    wixUserId: string;
    appId: string;
};
type BaseEventMetadata = {
    instanceId: string;
    identity?: EventIdentity;
};
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

/**
 * Expose fields based on the current exposure toggle.
 * @param T - The type to expose fields from.
 * @param FieldsScope - A map of fields to their exposure scope, missing fields are considered public.
 * @example Exposure toggle not set:
 * ```ts
 * type MyType = {
 *  publicField: string;
 *  alphaField: string;
 * };
 *
 * type ExposedType = ExposeFieldsBasedOnToggle<MyType, { alphaField: 'alpha' }>;
 * // ExposedType = { publicField: string; }
 * ```
 * @example Exposure toggle set to alpha:
 * ```ts
 * declare global {
 *  interface SDKExposureToggle {
 *   alpha: true;
 *  }
 * }
 *
 * type MyType = {
 *  publicField: string;
 *  alphaField: string;
 * };
 *
 * type ExposedType = ExposeFieldsBasedOnToggle<MyType, { alphaField: 'alpha' }>;
 * // ExposedType = { publicField: string; alphaField: string; }
 */
type ExposeFieldsBasedOnToggle<T extends Record<string, any>, FieldsScope extends Partial<Record<keyof T, Exposure>>> = Simplify<{
    [K in keyof T as IsExposed<K, FieldsScope[K] extends Exposure ? FieldsScope[K] : 'public'>]: T[K];
}>;
declare global {
    /**
     * A global interface to set the exposure toggle for the SDK.
     * @example
     * ```ts
     * declare global {
     *  interface SDKExposureToggle {
     *    alpha: true;
     *  }
     * }
     */
    interface SDKExposureToggle {
    }
}
type Exposure = 'alpha' | 'public';
type IsExposed<T, Scope extends Exposure> = Scope extends 'public' ? T : globalThis.SDKExposureToggle extends {
    alpha: true;
} ? T : never;

declare global {
    /**
     * A global interface to set the type mode for the SDK.
     * @example
     * ```ts
     * declare global {
     *  interface SDKTypeMode {
     *    strict: true;
     *  }
     * }
     */
    interface SDKTypeMode {
    }
}
type NonNullablePaths<T, K extends Paths<T, {
    maxRecursionDepth: MaxDepth;
}>, MaxDepth extends number = 11> = globalThis.SDKTypeMode extends {
    strict: true;
} ? SetRequiredDeep<T, K> : T;

/**
 * Constant used to indicate all applicable operators for a field type
 */
declare const ALL_APPLICABLE_OPERATORS: "*";
/**
 * Operators available for string fields
 */
type StringOperators = '$eq' | '$ne' | '$gt' | '$lt' | '$gte' | '$lte' | '$isEmpty' | '$exists' | '$in' | '$nin' | '$startsWith';
/**
 * Operators available for number fields
 */
type NumberOperators = '$eq' | '$ne' | '$gt' | '$lt' | '$gte' | '$lte' | '$exists' | '$in' | '$nin';
/**
 * Operators available for boolean fields
 */
type BooleanOperators = '$eq' | '$ne' | '$exists' | '$in' | '$nin';
/**
 * Operators available for enum fields
 */
type EnumOperators = '$eq' | '$ne' | '$in' | '$nin' | '$exists';
/**
 * Operators available for date fields
 */
type DateOperators = '$eq' | '$ne' | '$gt' | '$lt' | '$gte' | '$lte' | '$exists' | '$in' | '$nin';
/**
 * Operators available for object fields
 */
type ObjectOperators = '$exists';
/**
 * Base operators available for all array types
 */
type ArrayBaseOperators = '$isEmpty' | '$exists';
/**
 * Operators available for arrays of primitive values
 */
type ArrayOfPrimitivesOperators = '$hasAll' | '$hasSome' | ArrayBaseOperators;
/**
 * Operators available for arrays of objects
 */
type ArrayOfObjectsOperators = ArrayBaseOperators | '$matchItems';
type OperatorsWithBooleanValues = '$isEmpty' | '$exists';
type OperatorsWithArrayValues = '$in' | '$nin' | '$hasAll' | '$hasSome';
type OperatorForArrayFiltering = '$matchItems';

/**
 * Sort direction type for requests
 */
type SortOrder = 'ASC' | 'DESC';
/**
 * Sort capability type for defining field sort options in SearchSpec
 */
type SortCapability = SortOrder | 'BOTH' | 'NONE';
/**
 * Constants for sort directions
 */
declare const SORT_DIRECTIONS: {
    readonly ASC: "ASC";
    readonly DESC: "DESC";
};
/**
 * Constants for sort capabilities
 */
declare const SORT_CAPABILITIES: {
    readonly BOTH: "BOTH";
    readonly NONE: "NONE";
    readonly ASC: "ASC";
    readonly DESC: "DESC";
};
/**
 * Helper type to get the fields from a WQL group
 * @template WQLGroup The WQL group type
 */
type WQLFields<WQLGroup> = WQLGroup extends {
    fields: readonly string[];
} ? WQLGroup['fields'][number] : never;
/**
 * Sorting configuration for search/query results
 * @template Spec The WQL specification type
 */
type Sorting<Spec extends WQLSpec> = Spec['wql'] extends {
    length: 0;
} | [] ? {
    fieldName?: string;
    order?: SortOrder;
    selectItemsBy?: Record<string, any>[] | null;
} : {
    [WQLGroupIndex in keyof Spec['wql']]: Spec['wql'][WQLGroupIndex] extends {
        fields: readonly string[];
        sort: infer GroupSortCapability;
    } ? GroupSortCapability extends typeof SORT_DIRECTIONS.ASC ? {
        fieldName: WQLFields<Spec['wql'][WQLGroupIndex]>;
        order: typeof SORT_DIRECTIONS.ASC;
        selectItemsBy?: Record<string, any>[] | null;
    } : GroupSortCapability extends typeof SORT_DIRECTIONS.DESC ? {
        fieldName: WQLFields<Spec['wql'][WQLGroupIndex]>;
        order: typeof SORT_DIRECTIONS.DESC;
        selectItemsBy?: Record<string, any>[] | null;
    } : GroupSortCapability extends typeof SORT_CAPABILITIES.BOTH ? {
        fieldName: WQLFields<Spec['wql'][WQLGroupIndex]>;
        order: SortOrder;
        selectItemsBy?: Record<string, any>[] | null;
    } : GroupSortCapability extends typeof SORT_CAPABILITIES.NONE ? {
        fieldName?: never;
        order?: never;
        selectItemsBy?: Record<string, any>[] | null;
    } : never : never;
}[keyof Spec['wql']];

/**
 * Defines a group of fields that share the same operator and sorting capabilities
 * This is part of the Wix Query Language (WQL) specification
 * @example
 * const wql: WQL = {
 *   operators: ['$eq', '$ne', '$startsWith'],
 *   fields: ['name', 'description'],
 *   sort: 'BOTH'
 * };
 */
interface WQL {
    /**
     * List of operators that can be used with these fields
     * If not specified, uses ALL_APPLICABLE_OPERATORS
     */
    operators?: typeof ALL_APPLICABLE_OPERATORS | readonly string[];
    /**
     * List of fields that share these operator capabilities
     * These fields can be used in filters and sorting
     */
    fields: readonly string[];
    /**
     * Sort capabilities for fields in this group
     * If omitted, sorting is not allowed for these fields
     */
    sort?: SortCapability;
}

/**
 * Base specification interface for APIs that support WQL (Wix Query Language)
 */
interface WQLSpec {
    /**
     * Groups of fields with shared operator and sorting capabilities
     * Each group defines what operations can be performed on its fields
     */
    wql: readonly WQL[];
}

/**
 * Gets the type of a field at a nested path
 */
type GetNestedType<Entity, Path extends string> = Path extends keyof Entity ? Entity[Path] extends (infer ArrayElement)[] | null | undefined ? ArrayElement : Exclude<Entity[Path], null | undefined> : Path extends `${infer FirstPathPart}.${infer RemainingPath}` ? FirstPathPart extends keyof Entity ? Entity[FirstPathPart] extends (infer ArrayElement)[] | null | undefined ? GetNestedType<NonNullable<ArrayElement>, RemainingPath> : Entity[FirstPathPart] extends object | null | undefined ? GetNestedType<NonNullable<Entity[FirstPathPart]>, RemainingPath> : never : never : never;
/**
 * Extracts all filterable field paths from a spec
 * @template Spec The WQL specification type
 * // Results in a union type of all field paths that can be filtered
 */
type FilterableFields<Spec extends WQLSpec> = Spec['wql'][number]['fields'][number];

/**
 * Helper type to detect if a type is an enum-like union of string literals
 * This checks if the type is a union of specific string literals (not a generic string)
 * It handles both simple enums and complex enum + literal unions like EnumWithTypeAlias
 */
type IsEnumLike<T> = T extends string | null | undefined ? string extends NonNullable<T> ? false : NonNullable<T> extends string ? true : false : false;
/**
 * Determines operators applicable to a field based on its type
 * @template Entity The entity type
 * @template Path The field path to check
 */
type ApplicableOperators<Entity, Path extends string> = Path extends keyof Entity ? Entity[Path] extends string | null | undefined ? IsEnumLike<Entity[Path]> extends true ? EnumOperators : StringOperators : Entity[Path] extends number | null | undefined ? NumberOperators : Entity[Path] extends boolean | null | undefined ? BooleanOperators : Entity[Path] extends Date | null | undefined ? DateOperators : Entity[Path] extends (infer E)[] | null | undefined ? E extends object ? ArrayOfObjectsOperators : ArrayOfPrimitivesOperators : Entity[Path] extends object | null | undefined ? ObjectOperators : never : Path extends `${infer K}.${infer R}` ? K extends keyof Entity ? Entity[K] extends (infer U)[] | null | undefined ? ApplicableOperators<NonNullable<U>, R> : Entity[K] extends object | null | undefined ? ApplicableOperators<NonNullable<Entity[K]>, R> : never : never : never;
/**
 * Determines allowed operators for a field based on the spec
 * @template Entity The entity type
 * @template Spec The WQL specification type
 * @template Field The field to check
 */
type AllowedOperators<Entity, Spec extends WQLSpec, Field extends FilterableFields<Spec>> = Spec['wql'][number] extends infer WQLGroup ? WQLGroup extends WQL ? Field extends WQLGroup['fields'][number] ? WQLGroup['operators'] extends typeof ALL_APPLICABLE_OPERATORS ? ApplicableOperators<Entity, Field & string> : WQLGroup['operators'] extends readonly string[] ? WQLGroup['operators'][number] : never : never : never : never;
/**
 * Filter operations type for individual field conditions
 * @template Entity The entity type
 * @template Spec The WQL specification type
 * @template Field The field to filter on
 */
type FilterOps<Entity, Spec extends WQLSpec, Field extends FilterableFields<Spec>> = Simplify<{
    [Op in AllowedOperators<Entity, Spec, Field>]?: Op extends OperatorsWithBooleanValues ? boolean : Op extends OperatorForArrayFiltering ? JsonObject[] : Op extends OperatorsWithArrayValues ? GetNestedType<Entity, Field & string>[] : GetNestedType<Entity, Field & string>;
}>;
/**
 * Filter type for building type-safe query filters
 * @template Entity The entity type
 * @template Spec The WQL specification type
 * @example
 * // Simple filter
 * const filter: Filter<Product, ProductSpec> = {
 *   name: { $eq: 'iPhone' },
 *   price: { $gte: 100 }
 * };
 *
 * // Complex filter with logical operators
 * const filter: Filter<Product, ProductSpec> = {
 *   $and: [
 *     { name: { $startsWith: 'i' } },
 *     { $or: [
 *       { price: { $lt: 1000 } },
 *       { onSale: { $eq: true } }
 *     ]}
 *   ]
 * };
 */
type Filter<Entity, Spec extends WQLSpec> = Simplify<{
    [Field in FilterableFields<Spec>]?: AllowedOperators<Entity, Spec, Field> extends infer AllowedOps ? AllowedOps extends '$eq' ? GetNestedType<Entity, Field & string> | FilterOps<Entity, Spec, Field> : FilterOps<Entity, Spec, Field> : never;
} | {
    $and?: Filter<Entity, Spec>[];
    $or?: Filter<Entity, Spec>[];
    $not?: Filter<Entity, Spec>;
}>;

/**
 * Cursor-based paging configuration
 */
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
/**
 * Offset-based paging configuration
 */
interface OffsetPaging {
    /** Number of items to load */
    limit?: number | null;
    /** Number of items to skip in the current sort order */
    offset?: number | null;
}
/**
 * Supported paging types for search APIs
 */
type PagingType = 'cursor' | 'offset';
/**
 * Paging type based on the SearchSpec's paging type
 */
type Paging<Spec extends {
    paging?: PagingType;
}> = Spec['paging'] extends 'cursor' ? {
    cursorPaging: CursorPaging;
} : Spec['paging'] extends 'offset' ? {
    paging: OffsetPaging;
} : {};

/**
 * Specification for a search API
 * Defines what fields can be filtered, sorted, searched, and aggregated
 * @example
 * interface MySearchSpec extends SearchSpec {
 *   wql: [{
 *     operators: ['$eq', '$ne'], // or 'typeof ALL_APPLICABLE_OPERATORS' for all operators that can be used based on the field type
 *     fields: ['id', 'title'],
 *     sort: 'BOTH' // or 'ASC' / 'DESC' for specific sorting
 *   }],
 *   paging: 'offset', // or 'cursor' for cursor-based pagination
 *   searchable: ['title', 'description'],
 *   aggregatable: ['category', 'price']
 * };
 */
interface SearchSpec extends WQLSpec {
    /**
     * Supported paging type for this search API
     * - 'cursor': Uses cursor-based pagination
     * - 'offset': Uses offset-based pagination
     */
    paging: PagingType;
    /**
     * Fields that can be used for full-text search
     * If not specified, all fields are searchable
     */
    searchable?: readonly string[];
    /**
     * Fields that can be used for aggregations
     * These fields must be searchable and not contain PII
     */
    aggregatable?: readonly string[];
}

/**
 * Type of scalar aggregation to perform
 */
type ScalarType = 'COUNT_DISTINCT' | 'MIN' | 'MAX' | 'SUM' | 'AVG';
/**
 * Sort type for value aggregations
 */
type ValueSortType = 'COUNT' | 'VALUE';
/**
 * Sort direction for value aggregations
 */
type ValueSortDirection = 'DESC' | 'ASC';
/**
 * Missing values handling for value aggregations
 */
type MissingValues = 'EXCLUDE' | 'INCLUDE';
/**
 * Date histogram interval
 */
type DateHistogramInterval = 'YEAR' | 'MONTH' | 'WEEK' | 'DAY' | 'HOUR' | 'MINUTE' | 'SECOND';
/**
 * Range bucket for range aggregations
 */
interface RangeBucket {
    from?: number | null;
    to?: number | null;
}
/**
 * Value aggregation configuration
 */
interface ValueAggregation {
    sortType?: ValueSortType;
    sortDirection?: ValueSortDirection;
    limit?: number | null;
    missingValues?: MissingValues;
    includeOptions?: {
        addToBucket?: string;
    };
}
/**
 * Range aggregation configuration
 */
interface RangeAggregation {
    buckets?: RangeBucket[];
}
/**
 * Group by aggregation configuration.
 */
interface GroupByAggregation {
    name?: string | null;
    fieldPath?: string | null;
    value?: ValueAggregation;
}
/**
 * Scalar aggregation configuration
 */
interface ScalarAggregation {
    type?: ScalarType;
}
/**
 * Date histogram aggregation configuration
 */
interface DateHistogramAggregation {
    interval?: DateHistogramInterval;
}
/**
 * Nested aggregation item
 */
type NestedAggregationItem<Spec extends SearchSpec> = BaseAggregationWithoutType<Spec> & {
    type?: NonNestedAggregationType;
};
/**
 * Nested aggregation configuration
 */
interface NestedAggregation<Spec extends SearchSpec> {
    nestedAggregations?: NestedAggregationItem<Spec>[];
}
/**
 * Extracts all aggregatable field paths from a search spec
 * @template Spec The search specification type
 */
type AggregatableFields<Spec extends SearchSpec> = Spec extends {
    aggregatable: readonly string[];
} ? Spec['aggregatable'][number] : string;
/**
 * Base aggregation type that can be used for both top-level and nested aggregations
 */
type NonNestedAggregationType = 'DATE_HISTOGRAM' | 'RANGE' | 'SCALAR' | 'VALUE';
type AggregationTypeWithNested = 'NESTED' | NonNestedAggregationType;
type BaseAggregationWithoutType<Spec extends SearchSpec> = {
    name?: string | null;
    fieldPath?: AggregatableFields<Spec>;
    dateHistogram?: DateHistogramAggregation;
    range?: RangeAggregation;
    scalar?: ScalarAggregation;
    value?: ValueAggregation;
    groupBy?: GroupByAggregation;
};
/**
 * Base aggregation interface
 * @template Spec The search specification type
 */
type Aggregation<Spec extends SearchSpec> = BaseAggregationWithoutType<Spec> & {
    type?: AggregationTypeWithNested;
    nested?: NestedAggregation<Spec>;
};

/**
 * Extracts all searchable field paths from a search spec
 * @template Spec The search specification type
 * // Results in a union type of all field paths that can be searched
 */
type SearchableFields<Spec extends SearchSpec> = Spec extends {
    searchable: readonly string[];
} ? Spec['searchable'][number] : string;

/**
 * Configuration for full-text search functionality
 * @template Spec The search specification type
 * @example
 * const search: SearchDetails<MySearchSpec> = {
 *   expression: 'urgent task',
 *   mode: 'AND',
 *   fields: ['title', 'description'],
 *   fuzzy: true
 * };
 */
interface SearchDetails<Spec extends SearchSpec> {
    /**
     * Search term or expression.
     */
    expression?: string | null;
    /**
     * How to combine multiple search terms
     * - 'AND': All terms must match
     * - 'OR': Any term can match
     */
    mode?: 'AND' | 'OR';
    /**
     Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path.
     */
    fields?: SearchableFields<Spec>[];
    /**
     * Whether to enable fuzzy matching
     * Fuzzy matching allows for approximate matches
     */
    fuzzy?: boolean;
}
/**
 * Base search request without paging
 * @template Entity The entity type being searched
 * @template Spec The search specification type
 */
type BaseSearch<Entity, Spec extends SearchSpec> = {
    /**
     * Filter object.
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Filter<Entity, Spec>;
    /**
     * List of sort objects.
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting<Spec>[];
    /**
     * Free text to match in searchable fields.
     */
    search?: SearchDetails<Spec>;
    /**
     * Aggregations are a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition.
     */
    aggregations?: Aggregation<Spec>[];
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. e.g. `"2023-12-20T10:52:34.795Z"`
     */
    timeZone?: string | null;
};
/**
 * Complete search request for an entity type
 * @template Entity The entity type being searched
 * @template Spec The search specification type
 * @example
 * // Define a search type for products
 * type SearchProducts = Search<Product, ProductSearchSpec>;
 *
 * // Create a search request
 * const search: SearchProducts = {
 *   filter: { price: { $gte: 10 } },
 *   sort: [{ fieldName: 'price', order: 'ASC' }],
 *   search: { expression: 'shirt', mode: 'AND' },
 *
 *   // For offset paging:
 *   paging: { limit: 20, offset: 0 }
 *
 *   // For cursor paging:
 *   cursorPaging: { limit: 20, cursor: "..." }
 * };
 */
type Search<Entity, Spec extends SearchSpec> = BaseSearch<Entity, Spec> & Partial<Paging<Spec>>;

/**
 * Specification for a query API
 * Defines what fields can be filtered and sorted
 * @example
 * interface MyQuerySpec extends QuerySpec {
 *   wql: [{
 *     operators: ['$eq', '$ne'],
 *     fields: ['id', 'title'],
 *     sort: 'BOTH'
 *   }],
 *   paging: 'offset', // or 'cursor' for cursor-based pagination
 * };
 */
interface QuerySpec extends WQLSpec {
    /**
     * Supported paging type for this query API
     * - 'cursor': Uses cursor-based pagination
     * - 'offset': Uses offset-based pagination
     */
    paging: PagingType;
}

/**
 * Complete query request for an entity type
 * @template Entity The entity type being queried
 * @template Spec The query specification type
 * @example
 * // Define a query type for products
 * type QueryProducts = Query<Product, ProductQuerySpec>;
 *
 * // Create a query request with offset paging
 * const query: QueryProducts = {
 *   filter: { price: { $gte: 10 } },
 *   sort: [{ fieldName: 'price', order: 'ASC' }],
 *   paging: { limit: 20, offset: 0 }
 * };
 *
 * // Or with cursor paging (if spec.paging = 'cursor')
 * const query: QueryProducts = {
 *   filter: { price: { $gte: 10 } },
 *   sort: [{ fieldName: 'price', order: 'ASC' }],
 *   cursorPaging: { limit: 20, cursor: "..." }
 * };
 */
type Query<Entity, Spec extends QuerySpec> = {
    /**
     * Filter object.
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Filter<Entity, Spec>;
    /**
     * List of sort objects.
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting<Spec>[];
} & Partial<Paging<Spec>>;

export { type APIMetadata, type AmbassadorFactory, type AmbassadorFunctionDescriptor, type AmbassadorRequestOptions, type AuthenticationStrategy, type BaseEventMetadata, type BoundAuthenticationStrategy, type BuildAmbassadorFunction, type BuildDescriptors, type BuildEventDefinition, type BuildRESTFunction, type BuildServicePluginDefinition, type Descriptors, EventDefinition, type EventHandler, type EventIdentity, type ExposeFieldsBasedOnToggle, type Filter, type FilterableFields, type GetNestedType, type HTTPMethod, type Host, type HostModule, type HostModuleAPI, type HttpClient, type HttpResponse, type MaybeContext, type Method, type MigrationOptions, type NonNullablePaths, type PublicMetadata, type Query, type QuerySpec, type RESTFunctionDescriptor, type RequestContext, type RequestOptions, type RequestOptionsFactory, type RestModuleMeta, SERVICE_PLUGIN_ERROR_TYPE, SORT_CAPABILITIES, SORT_DIRECTIONS, type Search, type SearchSpec, type ServicePluginContract, ServicePluginDefinition, type ServicePluginMethodInput, type ServicePluginMethodMetadata, type SortCapability, type SortOrder, type Sorting, type WQL, type WQLSpec };
