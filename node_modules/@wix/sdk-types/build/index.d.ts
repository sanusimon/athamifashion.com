import { MonitoringClient } from '@wix/monitoring-types';
import { ConditionalExcept, EmptyObject, Simplify, Paths, SetRequiredDeep, JsonObject } from 'type-fest';

type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel?: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Optional function to get a monitoring client
     */
    getMonitoringClient?: () => MonitoringClient;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type HTTPMethod = 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: HTTPMethod;
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type RestModuleMeta<TMethod extends HTTPMethod = HTTPMethod, TPathParams = unknown, RequestType = unknown, TOriginalRequestType = unknown, ResponseType = unknown, OriginalResponseType = unknown> = {
    getUrl(context: {
        host: string;
    }): string;
    httpMethod: TMethod;
    pathParams: TPathParams;
    path: string;
    __requestType: RequestType;
    __originalRequestType: TOriginalRequestType;
    __responseType: ResponseType;
    __originalResponseType: OriginalResponseType;
};

type AuthenticationStrategy<Host = unknown> = {
    getAuthHeaders: (host: Host) => Promise<{
        headers: Record<string, string>;
    }> | {
        headers: Record<string, string>;
    };
    decodeJWT?: (token: string, verifyCallerClaims?: boolean) => Promise<{
        decoded: {
            data: unknown;
        };
        valid: boolean;
    }>;
    /**
     * This function is used to get the token that is currently active in the context of the strategy.
     * This is useful when direct access to the access token is needed
     * (such as getTokenInfo that requires the token in the body of the request).
     * @returns the token that is currently active in the context of the strategy
     */
    getActiveToken?: () => string | undefined;
};
type BoundAuthenticationStrategy = {
    getAuthHeaders: () => Promise<{
        headers: Record<string, string>;
    }> | {
        headers: Record<string, string>;
    };
};

type EventIdentity = {
    identityType: 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
    anonymousVisitorId: string;
    memberId: string;
    wixUserId: string;
    appId: string;
};
type BaseEventMetadata = {
    instanceId: string;
    identity?: EventIdentity;
};
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

/**
 * Expose fields based on the current exposure toggle.
 * @param T - The type to expose fields from.
 * @param FieldsScope - A map of fields to their exposure scope, missing fields are considered public.
 * @example Exposure toggle not set:
 * ```ts
 * type MyType = {
 *  publicField: string;
 *  alphaField: string;
 * };
 *
 * type ExposedType = ExposeFieldsBasedOnToggle<MyType, { alphaField: 'alpha' }>;
 * // ExposedType = { publicField: string; }
 * ```
 * @example Exposure toggle set to alpha:
 * ```ts
 * declare global {
 *  interface SDKExposureToggle {
 *   alpha: true;
 *  }
 * }
 *
 * type MyType = {
 *  publicField: string;
 *  alphaField: string;
 * };
 *
 * type ExposedType = ExposeFieldsBasedOnToggle<MyType, { alphaField: 'alpha' }>;
 * // ExposedType = { publicField: string; alphaField: string; }
 */
type ExposeFieldsBasedOnToggle<T extends Record<string, any>, FieldsScope extends Partial<Record<keyof T, Exposure>>> = Simplify<{
    [K in keyof T as IsExposed<K, FieldsScope[K] extends Exposure ? FieldsScope[K] : 'public'>]: T[K];
}>;
declare global {
    /**
     * A global interface to set the exposure toggle for the SDK.
     * @example
     * ```ts
     * declare global {
     *  interface SDKExposureToggle {
     *    alpha: true;
     *  }
     * }
     */
    interface SDKExposureToggle {
    }
}
type Exposure = 'alpha' | 'public';
type IsExposed<T, Scope extends Exposure> = Scope extends 'public' ? T : globalThis.SDKExposureToggle extends {
    alpha: true;
} ? T : never;

declare global {
    /**
     * A global interface to set the type mode for the SDK.
     * @example
     * ```ts
     * declare global {
     *  interface SDKTypeMode {
     *    strict: true;
     *  }
     * }
     */
    interface SDKTypeMode {
    }
}
type NonNullablePaths<T, K extends Paths<T>> = globalThis.SDKTypeMode extends {
    strict: true;
} ? SetRequiredDeep<T, K> : T;

/**
 * Constant used to indicate all applicable operators for a field type
 */
declare const ALL_APPLICABLE_OPERATORS: "*";
/**
 * Operators available for string fields
 */
type StringOperators = '$eq' | '$ne' | '$gt' | '$lt' | '$gte' | '$lte' | '$isEmpty' | '$exists' | '$in' | '$nin' | '$startsWith';
/**
 * Operators available for number fields
 */
type NumberOperators = '$eq' | '$ne' | '$gt' | '$lt' | '$gte' | '$lte' | '$exists' | '$in' | '$nin';
/**
 * Operators available for boolean fields
 */
type BooleanOperators = '$eq' | '$ne' | '$exists' | '$in' | '$nin';
/**
 * Operators available for date fields
 */
type DateOperators = '$eq' | '$ne' | '$gt' | '$lt' | '$gte' | '$lte' | '$exists' | '$in' | '$nin';
/**
 * Operators available for object fields
 */
type ObjectOperators = '$exists';
/**
 * Base operators available for all array types
 */
type ArrayBaseOperators = '$isEmpty' | '$exists';
/**
 * Operators available for arrays of primitive values
 */
type ArrayOfPrimitivesOperators = '$hasAll' | '$hasSome' | ArrayBaseOperators;
/**
 * Operators available for arrays of objects
 */
type ArrayOfObjectsOperators = ArrayBaseOperators | '$matchItems';
type OperatorsWithBooleanValues = '$isEmpty' | '$exists';
type OperatorsWithArrayValues = '$in' | '$nin' | '$hasAll' | '$hasSome';
type OperatorForArrayFiltering = '$matchItems';

/**
 * Cursor-based paging configuration
 */
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
/**
 * Offset-based paging configuration
 */
interface OffsetPaging {
    /** Number of items to load */
    limit?: number | null;
    /** Number of items to skip in the current sort order */
    offset?: number | null;
}
/**
 * Supported paging types for search APIs
 */
type PagingType = 'cursor' | 'offset';
/**
 * Paging type based on the SearchSpec's paging type
 */
type Paging<Spec extends {
    paging?: PagingType;
}> = Spec['paging'] extends 'cursor' ? {
    cursorPaging: CursorPaging;
} : Spec['paging'] extends 'offset' ? {
    paging: OffsetPaging;
} : {};

/**
 * Sort direction type for requests
 */
type SortOrder = 'ASC' | 'DESC';
/**
 * Sort capability type for defining field sort options in SearchSpec
 */
type SortCapability = SortOrder | 'BOTH' | 'NONE';
/**
 * Constants for sort directions
 */
declare const SORT_DIRECTIONS: {
    readonly ASC: "ASC";
    readonly DESC: "DESC";
};
/**
 * Constants for sort capabilities
 */
declare const SORT_CAPABILITIES: {
    readonly BOTH: "BOTH";
    readonly NONE: "NONE";
    readonly ASC: "ASC";
    readonly DESC: "DESC";
};
/**
 * Helper type to get the fields from a WQL group
 * @template WQLGroup The WQL group type
 */
type WQLFields<WQLGroup> = WQLGroup extends {
    fields: readonly string[];
} ? WQLGroup['fields'][number] : never;
/**
 * Sorting configuration for search results
 * @template Spec The search specification type
 */
type Sorting<Spec extends SearchSpec> = Spec['wql'] extends {
    length: 0;
} | [] ? {
    fieldName?: string;
    order?: SortOrder;
    selectItemsBy?: Record<string, any>[] | null;
} : {
    [WQLGroupIndex in keyof Spec['wql']]: Spec['wql'][WQLGroupIndex] extends {
        fields: readonly string[];
        sort: infer GroupSortCapability;
    } ? GroupSortCapability extends typeof SORT_DIRECTIONS.ASC ? {
        fieldName: WQLFields<Spec['wql'][WQLGroupIndex]>;
        order: typeof SORT_DIRECTIONS.ASC;
        selectItemsBy?: Record<string, any>[] | null;
    } : GroupSortCapability extends typeof SORT_DIRECTIONS.DESC ? {
        fieldName: WQLFields<Spec['wql'][WQLGroupIndex]>;
        order: typeof SORT_DIRECTIONS.DESC;
        selectItemsBy?: Record<string, any>[] | null;
    } : GroupSortCapability extends typeof SORT_CAPABILITIES.BOTH ? {
        fieldName: WQLFields<Spec['wql'][WQLGroupIndex]>;
        order: SortOrder;
        selectItemsBy?: Record<string, any>[] | null;
    } : GroupSortCapability extends typeof SORT_CAPABILITIES.NONE ? {
        fieldName?: never;
        order?: never;
        selectItemsBy?: Record<string, any>[] | null;
    } : never : never;
}[keyof Spec['wql']];

/**
 * Defines a group of fields that share the same operator and sorting capabilities
 * This is part of the Wix Query Language (WQL) specification
 * @example
 * const wql: WQL = {
 *   operators: ['$eq', '$ne', '$startsWith'],
 *   fields: ['name', 'description'],
 *   sort: 'BOTH'
 * };
 */
interface WQL {
    /**
     * List of operators that can be used with these fields
     * If not specified, uses ALL_APPLICABLE_OPERATORS
     */
    operators?: typeof ALL_APPLICABLE_OPERATORS | readonly string[];
    /**
     * List of fields that share these operator capabilities
     * These fields can be used in filters and sorting
     */
    fields: readonly string[];
    /**
     * Sort capabilities for fields in this group
     * If omitted, sorting is not allowed for these fields
     */
    sort?: SortCapability;
}

/**
 * Specification for a search API
 * Defines what fields can be filtered, sorted, searched, and aggregated
 * @example
 * interface MySearchSpec extends SearchSpec {
 *   wql: [{
 *     operators: ['$eq', '$ne'], // or 'typeof ALL_APPLICABLE_OPERATORS' for all operators that can be used based on the field type
 *     fields: ['id', 'title'],
 *     sort: 'BOTH' // or 'ASC' / 'DESC' for specific sorting
 *   }],
 *   paging: 'offset', // or 'cursor' for cursor-based pagination
 *   searchable: ['title', 'description'],
 *   aggregatable: ['category', 'price']
 * };
 */
interface SearchSpec {
    /**
     * Groups of fields with shared operator and sorting capabilities
     * Each group defines what operations can be performed on its fields
     */
    wql: readonly WQL[];
    /**
     * Supported paging type for this search API
     * - 'cursor': Uses cursor-based pagination
     * - 'offset': Uses offset-based pagination
     */
    paging: PagingType;
    /**
     * Fields that can be used for full-text search
     * If not specified, all fields are searchable
     */
    searchable?: readonly string[];
    /**
     * Fields that can be used for aggregations
     * These fields must be searchable and not contain PII
     */
    aggregatable?: readonly string[];
}

/**
 * Gets the type of a field at a nested path
 */
type GetNestedType<Entity, Path extends string> = Path extends keyof Entity ? Entity[Path] extends (infer ArrayElement)[] | null | undefined ? ArrayElement : Exclude<Entity[Path], null | undefined> : Path extends `${infer FirstPathPart}.${infer RemainingPath}` ? FirstPathPart extends keyof Entity ? Entity[FirstPathPart] extends (infer ArrayElement)[] | null | undefined ? GetNestedType<NonNullable<ArrayElement>, RemainingPath> : Entity[FirstPathPart] extends object | null | undefined ? GetNestedType<NonNullable<Entity[FirstPathPart]>, RemainingPath> : never : never : never;
/**
 * Extracts all filterable field paths from a search spec
 * @template Spec The search specification type
 * // Results in a union type of all field paths that can be filtered
 */
type FilterableFields<Spec extends SearchSpec> = Spec['wql'][number]['fields'][number];
/**
 * Extracts all searchable field paths from a search spec
 * @template Spec The search specification type
 * // Results in a union type of all field paths that can be searched
 */
type SearchableFields<Spec extends SearchSpec> = Spec extends {
    searchable: readonly string[];
} ? Spec['searchable'][number] : string;

/**
 * Determines operators applicable to a field based on its type
 * @template Entity The entity type
 * @template Path The field path to check
 */
type ApplicableOperators<Entity, Path extends string> = Path extends keyof Entity ? Entity[Path] extends string | null | undefined ? StringOperators : Entity[Path] extends number | null | undefined ? NumberOperators : Entity[Path] extends boolean | null | undefined ? BooleanOperators : Entity[Path] extends Date | null | undefined ? DateOperators : Entity[Path] extends (infer E)[] | null | undefined ? E extends object ? ArrayOfObjectsOperators : ArrayOfPrimitivesOperators : Entity[Path] extends object | null | undefined ? ObjectOperators : never : Path extends `${infer K}.${infer R}` ? K extends keyof Entity ? Entity[K] extends (infer U)[] | null | undefined ? ApplicableOperators<NonNullable<U>, R> : Entity[K] extends object | null | undefined ? ApplicableOperators<NonNullable<Entity[K]>, R> : never : never : never;
/**
 * Determines allowed operators for a field based on the search spec
 * @template Entity The entity type
 * @template Spec The search specification type
 * @template Field The field to check
 */
type AllowedOperators<Entity, Spec extends SearchSpec, Field extends FilterableFields<Spec>> = Spec['wql'][number] extends infer WQLGroup ? WQLGroup extends WQL ? Field extends WQLGroup['fields'][number] ? WQLGroup['operators'] extends typeof ALL_APPLICABLE_OPERATORS ? ApplicableOperators<Entity, Field & string> : WQLGroup['operators'] extends readonly string[] ? WQLGroup['operators'][number] : never : never : never : never;
/**
 * Filter operations type for individual field conditions
 * @template Entity The entity type
 * @template Spec The search specification type
 * @template Field The field to filter on
 */
type FilterOps<Entity, Spec extends SearchSpec, Field extends FilterableFields<Spec>> = Simplify<{
    [Op in AllowedOperators<Entity, Spec, Field>]?: Op extends OperatorsWithBooleanValues ? boolean : Op extends OperatorForArrayFiltering ? JsonObject[] : Op extends OperatorsWithArrayValues ? GetNestedType<Entity, Field & string>[] : GetNestedType<Entity, Field & string>;
}>;
/**
 * Filter type for building type-safe query filters
 * @template Entity The entity type
 * @template Spec The search specification type
 * @example
 * // Simple filter
 * const filter: Filter<Product, ProductSpec> = {
 *   name: { $eq: 'iPhone' },
 *   price: { $gte: 100 }
 * };
 *
 * // Complex filter with logical operators
 * const filter: Filter<Product, ProductSpec> = {
 *   $and: [
 *     { name: { $startsWith: 'i' } },
 *     { $or: [
 *       { price: { $lt: 1000 } },
 *       { onSale: { $eq: true } }
 *     ]}
 *   ]
 * };
 */
type Filter<Entity, Spec extends SearchSpec> = Simplify<{
    [Field in FilterableFields<Spec>]?: AllowedOperators<Entity, Spec, Field> extends infer AllowedOps ? AllowedOps extends '$eq' ? GetNestedType<Entity, Field & string> | FilterOps<Entity, Spec, Field> : FilterOps<Entity, Spec, Field> : never;
} | {
    $and?: Filter<Entity, Spec>[];
    $or?: Filter<Entity, Spec>[];
    $not?: Filter<Entity, Spec>;
}>;

/**
 * Type of scalar aggregation to perform
 */
type ScalarType = 'COUNT_DISTINCT' | 'MIN' | 'MAX' | 'SUM' | 'AVG';
/**
 * Sort type for value aggregations
 */
type ValueSortType = 'COUNT' | 'VALUE';
/**
 * Sort direction for value aggregations
 */
type ValueSortDirection = 'DESC' | 'ASC';
/**
 * Missing values handling for value aggregations
 */
type MissingValues = 'EXCLUDE' | 'INCLUDE';
/**
 * Date histogram interval
 */
type DateHistogramInterval = 'YEAR' | 'MONTH' | 'WEEK' | 'DAY' | 'HOUR' | 'MINUTE' | 'SECOND';
/**
 * Range bucket for range aggregations
 */
interface RangeBucket {
    from?: number | null;
    to?: number | null;
}
/**
 * Value aggregation configuration
 */
interface ValueAggregation {
    sortType?: ValueSortType;
    sortDirection?: ValueSortDirection;
    limit?: number | null;
    missingValues?: MissingValues;
    includeOptions?: {
        addToBucket?: string;
    };
}
/**
 * Range aggregation configuration
 */
interface RangeAggregation {
    buckets?: RangeBucket[];
}
/**
 * Scalar aggregation configuration
 */
interface ScalarAggregation {
    type?: ScalarType;
}
/**
 * Date histogram aggregation configuration
 */
interface DateHistogramAggregation {
    interval?: DateHistogramInterval;
}
/**
 * Nested aggregation item
 */
type NestedAggregationItem<Spec extends SearchSpec> = BaseAggregationWithoutType<Spec> & {
    type?: NonNestedAggregationType;
};
/**
 * Nested aggregation configuration
 */
interface NestedAggregation<Spec extends SearchSpec> {
    nestedAggregations?: NestedAggregationItem<Spec>[];
}
/**
 * Extracts all aggregatable field paths from a search spec
 * @template Spec The search specification type
 */
type AggregatableFields<Spec extends SearchSpec> = Spec extends {
    aggregatable: readonly string[];
} ? Spec['aggregatable'][number] : string;
/**
 * Base aggregation type that can be used for both top-level and nested aggregations
 */
type NonNestedAggregationType = 'DATE_HISTOGRAM' | 'RANGE' | 'SCALAR' | 'VALUE';
type AggregationTypeWithNested = 'NESTED' | NonNestedAggregationType;
type BaseAggregationWithoutType<Spec extends SearchSpec> = {
    name?: string | null;
    fieldPath?: AggregatableFields<Spec>;
    dateHistogram?: DateHistogramAggregation;
    range?: RangeAggregation;
    scalar?: ScalarAggregation;
    value?: ValueAggregation;
};
/**
 * Base aggregation interface
 * @template Spec The search specification type
 */
type Aggregation<Spec extends SearchSpec> = BaseAggregationWithoutType<Spec> & {
    type?: AggregationTypeWithNested;
    nested?: NestedAggregation<Spec>;
};

/**
 * Configuration for full-text search functionality
 * @template Spec The search specification type
 * @example
 * const search: SearchDetails<MySearchSpec> = {
 *   expression: 'urgent task',
 *   mode: 'AND',
 *   fields: ['title', 'description'],
 *   fuzzy: true
 * };
 */
interface SearchDetails<Spec extends SearchSpec> {
    /**
     * Search term or expression.
     */
    expression?: string | null;
    /**
     * How to combine multiple search terms
     * - 'AND': All terms must match
     * - 'OR': Any term can match
     */
    mode?: 'AND' | 'OR';
    /**
     Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path.
     */
    fields?: SearchableFields<Spec>[];
    /**
     * Whether to enable fuzzy matching
     * Fuzzy matching allows for approximate matches
     */
    fuzzy?: boolean;
}
/**
 * Base search request without paging
 * @template Entity The entity type being searched
 * @template Spec The search specification type
 */
type BaseSearch<Entity, Spec extends SearchSpec> = {
    /**
     * Filter object.
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Filter<Entity, Spec>;
    /**
     * List of sort objects.
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting<Spec>[];
    /**
     * Free text to match in searchable fields.
     */
    search?: SearchDetails<Spec>;
    /**
     * Aggregations are a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition.
     */
    aggregations?: Aggregation<Spec>[];
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. e.g. `"2023-12-20T10:52:34.795Z"`
     */
    timeZone?: string | null;
};
/**
 * Complete search request for an entity type
 * @template Entity The entity type being searched
 * @template Spec The search specification type
 * @example
 * // Define a search type for products
 * type SearchProducts = Search<Product, ProductSearchSpec>;
 *
 * // Create a search request
 * const search: SearchProducts = {
 *   filter: { price: { $gte: 10 } },
 *   sort: [{ fieldName: 'price', order: 'ASC' }],
 *   search: { expression: 'shirt', mode: 'AND' },
 *
 *   // For offset paging:
 *   paging: { limit: 20, offset: 0 }
 *
 *   // For cursor paging:
 *   cursorPaging: { limit: 20, cursor: "..." }
 * };
 */
type Search<Entity, Spec extends SearchSpec> = BaseSearch<Entity, Spec> & Partial<Paging<Spec>>;

export { type APIMetadata, type AmbassadorFactory, type AmbassadorFunctionDescriptor, type AmbassadorRequestOptions, type AuthenticationStrategy, type BaseEventMetadata, type BoundAuthenticationStrategy, type BuildAmbassadorFunction, type BuildDescriptors, type BuildEventDefinition, type BuildRESTFunction, type BuildServicePluginDefinition, type Descriptors, EventDefinition, type EventHandler, type EventIdentity, type ExposeFieldsBasedOnToggle, type HTTPMethod, type Host, type HostModule, type HostModuleAPI, type HttpClient, type HttpResponse, type MaybeContext, type Method, type NonNullablePaths, type PublicMetadata, type RESTFunctionDescriptor, type RequestContext, type RequestOptions, type RequestOptionsFactory, type RestModuleMeta, SERVICE_PLUGIN_ERROR_TYPE, type Search, type SearchSpec, type ServicePluginContract, ServicePluginDefinition, type ServicePluginMethodInput, type ServicePluginMethodMetadata };
